{"ast":null,"code":"/* eslint-disable */\nvar workerURL;\nexport function createDeflateWorker() {\n  // Lazily compute the worker URL to allow importing the SDK in NodeJS\n  if (!workerURL) {\n    workerURL = URL.createObjectURL(new Blob([\"(\" + workerCodeFn + \")(self)\"]));\n  }\n\n  return new Worker(workerURL);\n}\n\nfunction workerCodeFn() {\n  monitor(function () {\n    var _a = makePakoDeflate(),\n        Deflate = _a.Deflate,\n        constants = _a.constants;\n\n    var deflate = new Deflate();\n    var rawSize = 0;\n    self.addEventListener('message', monitor(function (event) {\n      var data = event.data;\n\n      switch (data.action) {\n        case 'write':\n          var additionalRawSize = pushData(data.data);\n          self.postMessage({\n            id: data.id,\n            compressedSize: deflate.chunks.reduce(function (total, chunk) {\n              return total + chunk.length;\n            }, 0),\n            additionalRawSize: additionalRawSize\n          });\n          break;\n\n        case 'flush':\n          var additionalRawSize = data.data ? pushData(data.data) : 0;\n          deflate.push('', constants.Z_FINISH);\n          self.postMessage({\n            id: data.id,\n            result: deflate.result,\n            additionalRawSize: additionalRawSize,\n            rawSize: rawSize\n          });\n          deflate = new Deflate();\n          rawSize = 0;\n          break;\n      }\n    }));\n\n    function pushData(data) {\n      var binaryData = new TextEncoder().encode(data);\n      deflate.push(binaryData, constants.Z_SYNC_FLUSH);\n      rawSize += binaryData.length;\n      return binaryData.length;\n    }\n  })();\n\n  function monitor(fn) {\n    return function () {\n      try {\n        return fn.apply(this, arguments);\n      } catch (e) {\n        try {\n          self.postMessage({\n            error: e\n          });\n        } catch (_) {\n          // DATA_CLONE_ERR, cf https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n          self.postMessage({\n            error: '' + e\n          });\n        }\n      }\n    };\n  } // https://github.com/nodeca/pako/blob/034669ba0f1a4c0590e45f7c2820128200f972b3/dist/pako_deflate.es5.js\n\n\n  function makePakoDeflate() {\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    /* eslint-disable space-unary-ops */\n\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n    // const Z_FILTERED          = 1;\n    // const Z_HUFFMAN_ONLY      = 2;\n    // const Z_RLE               = 3;\n    var Z_FIXED = 4; // const Z_DEFAULT_STRATEGY  = 0;\n\n    /* Possible values of the data_type field (though see inflate()) */\n\n    var Z_BINARY = 0;\n    var Z_TEXT = 1; // const Z_ASCII             = 1; // = Z_TEXT\n\n    var Z_UNKNOWN = 2;\n    /* ============================================================================ */\n\n    function zero(buf) {\n      var len = buf.length;\n\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    } // From zutil.h\n\n\n    var STORED_BLOCK = 0;\n    var STATIC_TREES = 1;\n    var DYN_TREES = 2;\n    /* The three kinds of block type */\n\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    /* The minimum and maximum match lengths */\n    // From deflate.h\n\n    /* ===========================================================================\n     * Internal compression state.\n     */\n\n    var LENGTH_CODES = 29;\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    var LITERALS = 256;\n    /* number of literal bytes 0..255 */\n\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    var D_CODES = 30;\n    /* number of distance codes */\n\n    var BL_CODES = 19;\n    /* number of codes used to transfer the bit lengths */\n\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    /* maximum heap size */\n\n    var MAX_BITS = 15;\n    /* All codes must not exceed MAX_BITS bits */\n\n    var Buf_size = 16;\n    /* size of bit buffer in bi_buf */\n\n    /* ===========================================================================\n     * Constants\n     */\n\n    var MAX_BL_BITS = 7;\n    /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n    var END_BLOCK = 256;\n    /* end of block literal code */\n\n    var REP_3_6 = 16;\n    /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n    var REPZ_3_10 = 17;\n    /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n    var REPZ_11_138 = 18;\n    /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n    /* eslint-disable comma-spacing,array-bracket-spacing */\n\n    var extra_lbits =\n    /* extra bits for each length code */\n    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);\n    var extra_dbits =\n    /* extra bits for each distance code */\n    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);\n    var extra_blbits =\n    /* extra bits for each bit length code */\n    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);\n    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n    /* eslint-enable comma-spacing,array-bracket-spacing */\n\n    /* The lengths of the bit length codes are sent in order of decreasing\n     * probability, to avoid transmitting the lengths for unused bit length codes.\n     */\n\n    /* ===========================================================================\n     * Local data. These are initialized only once.\n     */\n    // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n    var DIST_CODE_LEN = 512;\n    /* see definition of array dist_code below */\n    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\n    var static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    /* The static literal tree. Since the bit lengths are imposed, there is no\n     * need for the L_CODES extra codes used during heap construction. However\n     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n     * below).\n     */\n\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    /* The static distance tree. (Actually a trivial tree since all codes use\n     * 5 bits.)\n     */\n\n    var _dist_code = new Array(DIST_CODE_LEN);\n\n    zero(_dist_code);\n    /* Distance codes. The first 256 values correspond to the distances\n     * 3 .. 258, the last 256 values correspond to the top 8 bits of\n     * the 15 bit distances.\n     */\n\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n\n    zero(_length_code);\n    /* length code for each normalized match length (0 == MIN_MATCH) */\n\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    /* First normalized length for each code (0 = MIN_MATCH) */\n\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    /* First normalized distance for each code (0 = distance of 1) */\n\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree;\n      /* static tree or NULL */\n\n      this.extra_bits = extra_bits;\n      /* extra bits for each code or NULL */\n\n      this.extra_base = extra_base;\n      /* base index for extra_bits */\n\n      this.elems = elems;\n      /* max number of elements in the tree */\n\n      this.max_length = max_length;\n      /* max bit length for the codes */\n      // show if `static_tree` has data or dummy - needed for monomorphic objects\n\n      this.has_stree = static_tree && static_tree.length;\n    }\n\n    var static_l_desc;\n    var static_d_desc;\n    var static_bl_desc;\n\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree;\n      /* the dynamic tree */\n\n      this.max_code = 0;\n      /* largest code with non zero frequency */\n\n      this.stat_desc = stat_desc;\n      /* the corresponding static tree */\n    }\n\n    var d_code = function d_code(dist) {\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    };\n    /* ===========================================================================\n     * Output a short LSB first on the stream.\n     * IN assertion: there is enough room in pendingBuf.\n     */\n\n\n    var put_short = function put_short(s, w) {\n      //    put_byte(s, (uch)((w) & 0xff));\n      //    put_byte(s, (uch)((ush)(w) >> 8));\n      s.pending_buf[s.pending++] = w & 0xff;\n      s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n    };\n    /* ===========================================================================\n     * Send a value on a given number of bits.\n     * IN assertion: length <= 16 and value fits in length bits.\n     */\n\n\n    var send_bits = function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> Buf_size - s.bi_valid;\n        s.bi_valid += length - Buf_size;\n      } else {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        s.bi_valid += length;\n      }\n    };\n\n    var send_code = function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2],\n      /* .Code */\n      tree[c * 2 + 1]\n      /* .Len */\n      );\n    };\n    /* ===========================================================================\n     * Reverse the first len bits of a code, using straightforward code (a faster\n     * method would use a table)\n     * IN assertion: 1 <= len <= 15\n     */\n\n\n    var bi_reverse = function bi_reverse(code, len) {\n      var res = 0;\n\n      do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n      } while (--len > 0);\n\n      return res >>> 1;\n    };\n    /* ===========================================================================\n     * Flush the bit buffer, keeping at most 7 bits in it.\n     */\n\n\n    var bi_flush = function bi_flush(s) {\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n      }\n    };\n    /* ===========================================================================\n     * Compute the optimal bit lengths for a tree and update the total bit length\n     * for the current block.\n     * IN assertion: the fields freq and dad are set, heap[heap_max] and\n     *    above are the tree nodes sorted by increasing frequency.\n     * OUT assertions: the field len is set to the optimal bit length, the\n     *     array bl_count contains the frequencies for each bit length.\n     *     The length opt_len is updated; static_len is also updated if stree is\n     *     not null.\n     */\n\n\n    var gen_bitlen = function gen_bitlen(s, desc //    deflate_state *s; //    tree_desc *desc;    /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree;\n      var max_code = desc.max_code;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var extra = desc.stat_desc.extra_bits;\n      var base = desc.stat_desc.extra_base;\n      var max_length = desc.stat_desc.max_length;\n      var h;\n      /* heap index */\n\n      var n;\n      var m;\n      /* iterate over the tree elements */\n\n      var bits;\n      /* bit length */\n\n      var xbits;\n      /* extra bits */\n\n      var f;\n      /* frequency */\n\n      var overflow = 0;\n      /* number of elements with bit length too large */\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0;\n      }\n      /* In a first pass, compute the optimal bit lengths (which may\n       * overflow in the case of the bit length tree).\n       */\n\n\n      tree[s.heap[s.heap_max] * 2 + 1] =\n      /* .Len */\n      0;\n      /* root of the heap */\n\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] *\n        /* .Dad */\n        2 + 1] +\n        /* .Len */\n        1;\n\n        if (bits > max_length) {\n          bits = max_length;\n          overflow++;\n        }\n\n        tree[n * 2 + 1] =\n        /* .Len */\n        bits;\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n > max_code) {\n          continue;\n        }\n        /* not a leaf node */\n\n\n        s.bl_count[bits]++;\n        xbits = 0;\n\n        if (n >= base) {\n          xbits = extra[n - base];\n        }\n\n        f = tree[n * 2];\n        /* .Freq */\n\n        s.opt_len += f * (bits + xbits);\n\n        if (has_stree) {\n          s.static_len += f * (stree[n * 2 + 1] +\n          /* .Len */\n          xbits);\n        }\n      }\n\n      if (overflow === 0) {\n        return;\n      } // Trace((stderr,\"\\nbit length overflow\\n\"));\n\n      /* This happens for example on obj2 and pic of the Calgary corpus */\n\n      /* Find the first bit length which could increase: */\n\n\n      do {\n        bits = max_length - 1;\n\n        while (s.bl_count[bits] === 0) {\n          bits--;\n        }\n\n        s.bl_count[bits]--;\n        /* move one leaf down the tree */\n\n        s.bl_count[bits + 1] += 2;\n        /* move one overflow item as its brother */\n\n        s.bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n\n        overflow -= 2;\n      } while (overflow > 0);\n      /* Now recompute all bit lengths, scanning in increasing frequency.\n       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n       * lengths instead of fixing only the wrong ones. This idea is taken\n       * from 'ar' written by Haruhiko Okumura.)\n       */\n\n\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits];\n\n        while (n !== 0) {\n          m = s.heap[--h];\n\n          if (m > max_code) {\n            continue;\n          }\n\n          if (tree[m * 2 + 1] !==\n          /* .Len */\n          bits) {\n            // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n            s.opt_len += (bits - tree[m * 2 + 1]) *\n            /* .Len */\n            tree[m * 2];\n            /* .Freq */\n\n            tree[m * 2 + 1] =\n            /* .Len */\n            bits;\n          }\n\n          n--;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Generate the codes for a given tree and bit counts (which need not be\n     * optimal).\n     * IN assertion: the array bl_count contains the bit length statistics for\n     * the given tree and the field len is set for all tree elements.\n     * OUT assertion: the field code is set for all tree elements of non\n     *     zero code length.\n     */\n\n\n    var gen_codes = function gen_codes(tree, max_code, bl_count //    ct_data *tree;             /* the tree to decorate */ //    int max_code;              /* largest code with non zero frequency */ //    ushf *bl_count;            /* number of codes at each bit length */\n    ) {\n      var next_code = new Array(MAX_BITS + 1);\n      /* next code value for each bit length */\n\n      var code = 0;\n      /* running code value */\n\n      var bits;\n      /* bit index */\n\n      var n;\n      /* code index */\n\n      /* The distribution counts are first used to generate the code values\n       * without bit reversal.\n       */\n\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n      }\n      /* Check that the bit counts in bl_count are consistent. The last code\n       * must be all ones.\n       */\n      // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n      //        \"inconsistent bit counts\");\n      // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\n      for (n = 0; n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        /* .Len */\n\n        if (len === 0) {\n          continue;\n        }\n        /* Now reverse the bits */\n\n\n        tree[n * 2] =\n        /* .Code */\n        bi_reverse(next_code[len]++, len); // Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n      }\n    };\n    /* ===========================================================================\n     * Initialize the various 'constant' tables.\n     */\n\n\n    var tr_static_init = function tr_static_init() {\n      var n;\n      /* iterates over tree elements */\n\n      var bits;\n      /* bit counter */\n\n      var length;\n      /* length value */\n\n      var code;\n      /* code value */\n\n      var dist;\n      /* distance index */\n\n      var bl_count = new Array(MAX_BITS + 1);\n      /* number of codes at each bit length for an optimal tree */\n      // do check in _tr_init()\n      // if (static_init_done) return;\n\n      /* For some embedded targets, global variables are not initialized: */\n\n      /* #ifdef NO_INIT_GLOBAL_POINTERS\n      static_l_desc.static_tree = static_ltree;\n      static_l_desc.extra_bits = extra_lbits;\n      static_d_desc.static_tree = static_dtree;\n      static_d_desc.extra_bits = extra_dbits;\n      static_bl_desc.extra_bits = extra_blbits;\n      #endif */\n\n      /* Initialize the mapping length (0..255) -> length code (0..28) */\n\n      length = 0;\n\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n\n        for (n = 0; n < 1 << extra_lbits[code]; n++) {\n          _length_code[length++] = code;\n        }\n      } // Assert (length == 256, \"tr_static_init: length != 256\");\n\n      /* Note that the length 255 (match length 258) can be represented\n       * in two different ways: code 284 + 5 bits or code 285, so we\n       * overwrite length_code[255] to use the best encoding:\n       */\n\n\n      _length_code[length - 1] = code;\n      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\n      dist = 0;\n\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist;\n\n        for (n = 0; n < 1 << extra_dbits[code]; n++) {\n          _dist_code[dist++] = code;\n        }\n      } // Assert (dist == 256, \"tr_static_init: dist != 256\");\n\n\n      dist >>= 7;\n      /* from now on, all distances are divided by 128 */\n\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n\n        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n          _dist_code[256 + dist++] = code;\n        }\n      } // Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n      /* Construct the codes of the static literal tree */\n\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0;\n      }\n\n      n = 0;\n\n      while (n <= 143) {\n        static_ltree[n * 2 + 1] =\n        /* .Len */\n        8;\n        n++;\n        bl_count[8]++;\n      }\n\n      while (n <= 255) {\n        static_ltree[n * 2 + 1] =\n        /* .Len */\n        9;\n        n++;\n        bl_count[9]++;\n      }\n\n      while (n <= 279) {\n        static_ltree[n * 2 + 1] =\n        /* .Len */\n        7;\n        n++;\n        bl_count[7]++;\n      }\n\n      while (n <= 287) {\n        static_ltree[n * 2 + 1] =\n        /* .Len */\n        8;\n        n++;\n        bl_count[8]++;\n      }\n      /* Codes 286 and 287 do not exist, but we must include them in the\n       * tree construction to get a canonical Huffman tree (longest code\n       * all ones)\n       */\n\n\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      /* The static distance tree is trivial: */\n\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1] =\n        /* .Len */\n        5;\n        static_dtree[n * 2] =\n        /* .Code */\n        bi_reverse(n, 5);\n      } // Now data ready and we can init static trees\n\n\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); // static_init_done = true;\n    };\n    /* ===========================================================================\n     * Initialize a new block.\n     */\n\n\n    var init_block = function init_block(s) {\n      var n;\n      /* iterates over tree elements */\n\n      /* Initialize the trees. */\n\n      for (n = 0; n < L_CODES; n++) {\n        s.dyn_ltree[n * 2] =\n        /* .Freq */\n        0;\n      }\n\n      for (n = 0; n < D_CODES; n++) {\n        s.dyn_dtree[n * 2] =\n        /* .Freq */\n        0;\n      }\n\n      for (n = 0; n < BL_CODES; n++) {\n        s.bl_tree[n * 2] =\n        /* .Freq */\n        0;\n      }\n\n      s.dyn_ltree[END_BLOCK * 2] =\n      /* .Freq */\n      1;\n      s.opt_len = s.static_len = 0;\n      s.last_lit = s.matches = 0;\n    };\n    /* ===========================================================================\n     * Flush the bit buffer and align the output on a byte boundary\n     */\n\n\n    var bi_windup = function bi_windup(s) {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n      } else if (s.bi_valid > 0) {\n        // put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf;\n      }\n\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n    };\n    /* ===========================================================================\n     * Copy a stored block, storing first the length and its\n     * one's complement if requested.\n     */\n\n\n    var copy_block = function copy_block(s, buf, len, header // DeflateState *s; //charf    *buf;    /* the input data */ //unsigned len;     /* its length */ //int      header;  /* true if block header must be written */\n    ) {\n      bi_windup(s);\n      /* align on byte boundary */\n\n      if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n      } //  while (len--) {\n      //    put_byte(s, *buf++);\n      //  }\n\n\n      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n      s.pending += len;\n    };\n    /* ===========================================================================\n     * Compares to subtrees, using the tree depth as tie breaker when\n     * the subtrees have equal frequency. This minimizes the worst case length.\n     */\n\n\n    var smaller = function smaller(tree, n, m, depth) {\n      var _n2 = n * 2;\n\n      var _m2 = m * 2;\n\n      return tree[_n2] <\n      /* .Freq */\n      tree[_m2] ||\n      /* .Freq */\n      tree[_n2] ===\n      /* .Freq */\n      tree[_m2] &&\n      /* .Freq */\n      depth[n] <= depth[m];\n    };\n    /* ===========================================================================\n     * Restore the heap property by moving down the tree starting at node k,\n     * exchanging a node with the smallest of its two sons if necessary, stopping\n     * when the heap property is re-established (each father smaller than its\n     * two sons).\n     */\n\n\n    var pqdownheap = function pqdownheap(s, tree, k //    deflate_state *s; //    ct_data *tree;  /* the tree to restore */ //    int k;               /* node to move down */\n    ) {\n      var v = s.heap[k];\n      var j = k << 1;\n      /* left son of k */\n\n      while (j <= s.heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++;\n        }\n        /* Exit if v is smaller than both sons */\n\n\n        if (smaller(tree, v, s.heap[j], s.depth)) {\n          break;\n        }\n        /* Exchange v with the smallest son */\n\n\n        s.heap[k] = s.heap[j];\n        k = j;\n        /* And continue down the tree, setting j to the left son of k */\n\n        j <<= 1;\n      }\n\n      s.heap[k] = v;\n    }; // inlined manually\n    // const SMALLEST = 1;\n\n    /* ===========================================================================\n     * Send the block data compressed using the given Huffman trees\n     */\n\n\n    var compress_block = function compress_block(s, ltree, dtree //    deflate_state *s; //    const ct_data *ltree; /* literal tree */ //    const ct_data *dtree; /* distance tree */\n    ) {\n      var dist;\n      /* distance of matched string */\n\n      var lc;\n      /* match length or unmatched char (if dist == 0) */\n\n      var lx = 0;\n      /* running index in l_buf */\n\n      var code;\n      /* the code to send */\n\n      var extra;\n      /* number of extra bits to send */\n\n      if (s.last_lit !== 0) {\n        do {\n          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n          lc = s.pending_buf[s.l_buf + lx];\n          lx++;\n\n          if (dist === 0) {\n            send_code(s, lc, ltree);\n            /* send a literal byte */\n            // Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n          } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree);\n            /* send the length code */\n\n            extra = extra_lbits[code];\n\n            if (extra !== 0) {\n              lc -= base_length[code];\n              send_bits(s, lc, extra);\n              /* send the extra length bits */\n            }\n\n            dist--;\n            /* dist is now the match distance - 1 */\n\n            code = d_code(dist); // Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);\n            /* send the distance code */\n\n            extra = extra_dbits[code];\n\n            if (extra !== 0) {\n              dist -= base_dist[code];\n              send_bits(s, dist, extra);\n              /* send the extra distance bits */\n            }\n          }\n          /* literal or match pair ? */\n\n          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n          // Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n          //       \"pendingBuf overflow\");\n\n        } while (lx < s.last_lit);\n      }\n\n      send_code(s, END_BLOCK, ltree);\n    };\n    /* ===========================================================================\n     * Construct one Huffman tree and assigns the code bit strings and lengths.\n     * Update the total bit length for the current block.\n     * IN assertion: the field freq is set for all tree elements.\n     * OUT assertions: the fields len and code are set to the optimal bit length\n     *     and corresponding code. The length opt_len is updated; static_len is\n     *     also updated if stree is not null. The field max_code is set.\n     */\n\n\n    var build_tree = function build_tree(s, desc //    deflate_state *s; //    tree_desc *desc; /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var elems = desc.stat_desc.elems;\n      var n;\n      var m;\n      /* iterate over heap elements */\n\n      var max_code = -1;\n      /* largest code with non zero frequency */\n\n      var node;\n      /* new node being created */\n\n      /* Construct the initial heap, with least frequent element in\n       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n       * heap[0] is not used.\n       */\n\n      s.heap_len = 0;\n      s.heap_max = HEAP_SIZE;\n\n      for (n = 0; n < elems; n++) {\n        if (tree[n * 2] !==\n        /* .Freq */\n        0) {\n          s.heap[++s.heap_len] = max_code = n;\n          s.depth[n] = 0;\n        } else {\n          tree[n * 2 + 1] =\n          /* .Len */\n          0;\n        }\n      }\n      /* The pkzip format requires that at least one distance code exists,\n       * and that at least one bit should be sent even if there is only one\n       * possible code. So to avoid special checks later on we force at least\n       * two codes of non zero frequency.\n       */\n\n\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] =\n        /* .Freq */\n        1;\n        s.depth[node] = 0;\n        s.opt_len--;\n\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1];\n          /* .Len */\n        }\n        /* node is 0 or 1 so it does not have extra bits */\n\n      }\n\n      desc.max_code = max_code;\n      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n       * establish sub-heaps of increasing lengths:\n       */\n\n      for (n = s.heap_len >> 1;\n      /* int /2 */\n      n >= 1; n--) {\n        pqdownheap(s, tree, n);\n      }\n      /* Construct the Huffman tree by repeatedly combining the least two\n       * frequent nodes.\n       */\n\n\n      node = elems;\n      /* next internal node of the tree */\n\n      do {\n        // pqremove(s, tree, n);  /* n = node of least frequency */\n\n        /** * pqremove ** */\n        n = s.heap[1];\n        /* SMALLEST */\n\n        s.heap[1] = s.heap[s.heap_len--];\n        /* SMALLEST */\n\n        pqdownheap(s, tree, 1\n        /* SMALLEST */\n        );\n        /***/\n\n        m = s.heap[1];\n        /* SMALLEST */\n\n        /* m = node of next least frequency */\n\n        s.heap[--s.heap_max] = n;\n        /* keep the nodes sorted by frequency */\n\n        s.heap[--s.heap_max] = m;\n        /* Create a new node father of n and m */\n\n        tree[node * 2] =\n        /* .Freq */\n        tree[n * 2] +\n        /* .Freq */\n        tree[m * 2];\n        /* .Freq */\n\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] =\n        /* .Dad */\n        tree[m * 2 + 1] =\n        /* .Dad */\n        node;\n        /* and insert the new node in the heap */\n\n        s.heap[1] = node++;\n        /* SMALLEST */\n\n        pqdownheap(s, tree, 1\n        /* SMALLEST */\n        );\n      } while (s.heap_len >= 2);\n\n      s.heap[--s.heap_max] = s.heap[1];\n      /* SMALLEST */\n\n      /* At this point, the fields freq and dad are set. We can now\n       * generate the bit lengths.\n       */\n\n      gen_bitlen(s, desc);\n      /* The field len is now set, we can generate the bit codes */\n\n      gen_codes(tree, max_code, s.bl_count);\n    };\n    /* ===========================================================================\n     * Scan a literal or distance tree to determine the frequencies of the codes\n     * in the bit length tree.\n     */\n\n\n    var scan_tree = function scan_tree(s, tree, max_code //    deflate_state *s; //    ct_data *tree;   /* the tree to be scanned */ //    int max_code;    /* and its largest code of non zero frequency */\n    ) {\n      var n;\n      /* iterates over all tree elements */\n\n      var prevlen = -1;\n      /* last emitted length */\n\n      var curlen;\n      /* length of current code */\n\n      var nextlen = tree[0 * 2 + 1];\n      /* .Len */\n\n      /* length of next code */\n\n      var count = 0;\n      /* repeat count of the current code */\n\n      var max_count = 7;\n      /* max repeat count */\n\n      var min_count = 4;\n      /* min repeat count */\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n\n      tree[(max_code + 1) * 2 + 1] =\n      /* .Len */\n      0xffff;\n      /* guard */\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        /* .Len */\n\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2] +=\n          /* .Freq */\n          count;\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            s.bl_tree[curlen * 2] /* .Freq */++;\n          }\n\n          s.bl_tree[REP_3_6 * 2] /* .Freq */++;\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2] /* .Freq */++;\n        } else {\n          s.bl_tree[REPZ_11_138 * 2] /* .Freq */++;\n        }\n\n        count = 0;\n        prevlen = curlen;\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Send a literal or distance tree in compressed form, using the codes in\n     * bl_tree.\n     */\n\n\n    var send_tree = function send_tree(s, tree, max_code //    deflate_state *s; //    ct_data *tree; /* the tree to be scanned */ //    int max_code;       /* and its largest code of non zero frequency */\n    ) {\n      var n;\n      /* iterates over all tree elements */\n\n      var prevlen = -1;\n      /* last emitted length */\n\n      var curlen;\n      /* length of current code */\n\n      var nextlen = tree[0 * 2 + 1];\n      /* .Len */\n\n      /* length of next code */\n\n      var count = 0;\n      /* repeat count of the current code */\n\n      var max_count = 7;\n      /* max repeat count */\n\n      var min_count = 4;\n      /* min repeat count */\n\n      /* tree[max_code+1].Len = -1; */\n\n      /* guard already set */\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        /* .Len */\n\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          do {\n            send_code(s, curlen, s.bl_tree);\n          } while (--count !== 0);\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree);\n            count--;\n          } // Assert(count >= 3 && count <= 6, \" 3_6?\");\n\n\n          send_code(s, REP_3_6, s.bl_tree);\n          send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree);\n          send_bits(s, count - 3, 3);\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree);\n          send_bits(s, count - 11, 7);\n        }\n\n        count = 0;\n        prevlen = curlen;\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    };\n    /* ===========================================================================\n     * Construct the Huffman tree for the bit lengths and return the index in\n     * bl_order of the last bit length code to send.\n     */\n\n\n    var build_bl_tree = function build_bl_tree(s) {\n      var max_blindex;\n      /* index of last bit length code of non zero freq */\n\n      /* Determine the bit length frequencies for literal and distance trees */\n\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n      /* Build the bit length tree: */\n\n      build_tree(s, s.bl_desc);\n      /* opt_len now includes the length of the tree representations, except\n       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n       */\n\n      /* Determine the number of bit length codes to send. The pkzip format\n       * requires that at least 4 bit length codes be sent. (appnote.txt says\n       * 3 but the actual value used is 4.)\n       */\n\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !==\n        /* .Len */\n        0) {\n          break;\n        }\n      }\n      /* Update opt_len to include the bit length tree and counts */\n\n\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; // Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n      //        s->opt_len, s->static_len));\n\n      return max_blindex;\n    };\n    /* ===========================================================================\n     * Send the header for a block using dynamic Huffman trees: the counts, the\n     * lengths of the bit length codes, the literal tree and the distance tree.\n     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n     */\n\n\n    var send_all_trees = function send_all_trees(s, lcodes, dcodes, blcodes //    deflate_state *s; //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n    ) {\n      var rank;\n      /* index in bl_order */\n      // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n      // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n      //        \"too many codes\");\n      // Tracev((stderr, \"\\nbl counts: \"));\n\n      send_bits(s, lcodes - 257, 5);\n      /* not +255 as stated in appnote.txt */\n\n      send_bits(s, dcodes - 1, 5);\n      send_bits(s, blcodes - 4, 4);\n      /* not -3 as stated in appnote.txt */\n\n      for (rank = 0; rank < blcodes; rank++) {\n        // Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1],\n        /* .Len */\n        3);\n      } // Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n\n      send_tree(s, s.dyn_ltree, lcodes - 1);\n      /* literal tree */\n      // Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n      send_tree(s, s.dyn_dtree, dcodes - 1);\n      /* distance tree */\n      // Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n    };\n    /* ===========================================================================\n     * Check if the data type is TEXT or BINARY, using the following algorithm:\n     * - TEXT if the two conditions below are satisfied:\n     *    a) There are no non-portable control characters belonging to the\n     *       \"black list\" (0..6, 14..25, 28..31).\n     *    b) There is at least one printable character belonging to the\n     *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n     * - BINARY otherwise.\n     * - The following partially-portable control characters form a\n     *   \"gray list\" that is ignored in this detection algorithm:\n     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n     * IN assertion: the fields Freq of dyn_ltree are set.\n     */\n\n\n    var detect_data_type = function detect_data_type(s) {\n      /* black_mask is the bit mask of black-listed bytes\n       * set bits 0..6, 14..25, and 28..31\n       * 0xf3ffc07f = binary 11110011111111111100000001111111\n       */\n      var black_mask = 0xf3ffc07f;\n      var n;\n      /* Check for non-textual (\"black-listed\") bytes. */\n\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !==\n        /* .Freq */\n        0) {\n          return Z_BINARY;\n        }\n      }\n      /* Check for textual (\"white-listed\") bytes. */\n\n\n      if (s.dyn_ltree[9 * 2] !==\n      /* .Freq */\n      0 || s.dyn_ltree[10 * 2] !==\n      /* .Freq */\n      0 || s.dyn_ltree[13 * 2] !==\n      /* .Freq */\n      0) {\n        return Z_TEXT;\n      }\n\n      for (n = 32; n < LITERALS; n++) {\n        if (s.dyn_ltree[n * 2] !==\n        /* .Freq */\n        0) {\n          return Z_TEXT;\n        }\n      }\n      /* There are no \"black-listed\" or \"white-listed\" bytes:\n       * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n       */\n\n\n      return Z_BINARY;\n    };\n\n    var static_init_done = false;\n    /* ===========================================================================\n     * Initialize the tree data structures for a new zlib stream.\n     */\n\n    var _tr_init = function _tr_init(s) {\n      if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n      }\n\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n      /* Initialize the first block of the first file: */\n\n      init_block(s);\n    };\n    /* ===========================================================================\n     * Send a stored block\n     */\n\n\n    var _tr_stored_block = function _tr_stored_block(s, buf, stored_len, last // DeflateState *s; //charf *buf;       /* input block */ //ulg stored_len;   /* length of input block */ //int last;         /* one if this is the last block for a file */\n    ) {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n      /* send block type */\n\n      copy_block(s, buf, stored_len, true);\n      /* with header */\n    };\n    /* ===========================================================================\n     * Send one empty static block to give enough lookahead for inflate.\n     * This takes 10 bits, of which 7 may remain in the bit buffer.\n     */\n\n\n    var _tr_align = function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3);\n      send_code(s, END_BLOCK, static_ltree);\n      bi_flush(s);\n    };\n    /* ===========================================================================\n     * Determine the best encoding for the current block: dynamic trees, static\n     * trees or store, and output the encoded block to the zip file.\n     */\n\n\n    var _tr_flush_block = function _tr_flush_block(s, buf, stored_len, last // DeflateState *s; //charf *buf;       /* input block, or NULL if too old */ //ulg stored_len;   /* length of input block */ //int last;         /* one if this is the last block for a file */\n    ) {\n      var opt_lenb;\n      var static_lenb;\n      /* opt_len and static_len in bytes */\n\n      var max_blindex = 0;\n      /* index of last bit length code of non zero freq */\n\n      /* Build the Huffman trees unless a stored block is forced */\n\n      if (s.level > 0) {\n        /* Check if the file is binary or text */\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s);\n        }\n        /* Construct the literal and distance trees */\n\n\n        build_tree(s, s.l_desc); // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        build_tree(s, s.d_desc); // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n\n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n\n        max_blindex = build_bl_tree(s);\n        /* Determine the best encoding. Compute the block lengths in bytes. */\n\n        opt_lenb = s.opt_len + 3 + 7 >>> 3;\n        static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n\n        if (static_lenb <= opt_lenb) {\n          opt_lenb = static_lenb;\n        }\n      } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5;\n        /* force a stored block */\n      }\n\n      if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */\n\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, last);\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\n      /* The above check is made mod 2^32, for files larger than 512 MB\n       * and uLong implemented on 32 bits.\n       */\n\n\n      init_block(s);\n\n      if (last) {\n        bi_windup(s);\n      } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n      //       s->compressed_len-7*last));\n\n    };\n    /* ===========================================================================\n     * Save the match info and tally the frequency counts. Return true if\n     * the current block must be flushed.\n     */\n\n\n    var _tr_tally = function _tr_tally(s, dist, lc //    deflate_state *s; //    unsigned dist;  /* distance of matched string */ //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n    ) {\n      // let out_length, in_length, dcode;\n      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n      s.last_lit++;\n\n      if (dist === 0) {\n        /* lc is the unmatched char */\n        s.dyn_ltree[lc * 2] /* .Freq */++;\n      } else {\n        s.matches++;\n        /* Here, lc is the match length - MIN_MATCH */\n\n        dist--;\n        /* dist = match distance - 1 */\n        // Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /* .Freq */++;\n        s.dyn_dtree[d_code(dist) * 2] /* .Freq */++;\n      } // (!) This block is disabled in zlib defaults,\n      // don't enable it for binary compatibility\n      // #ifdef TRUNCATE_BLOCK\n      //  /* Try to guess if it is profitable to stop the current block here */\n      //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n      //    /* Compute an upper bound for the compressed length */\n      //    out_length = s.last_lit*8;\n      //    in_length = s.strstart - s.block_start;\n      //\n      //    for (dcode = 0; dcode < D_CODES; dcode++) {\n      //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n      //    }\n      //    out_length >>>= 3;\n      //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n      //    //       s->last_lit, in_length, out_length,\n      //    //       100L - out_length*100L/in_length));\n      //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n      //      return true;\n      //    }\n      //  }\n      // #endif\n\n\n      return s.last_lit === s.lit_bufsize - 1;\n      /* We avoid equality with lit_bufsize because of wraparound at 64K\n       * on 16 bit machines and because stored blocks are restricted to\n       * 64K-1 bytes.\n       */\n    };\n\n    var _tr_init_1 = _tr_init;\n    var _tr_stored_block_1 = _tr_stored_block;\n    var _tr_flush_block_1 = _tr_flush_block;\n    var _tr_tally_1 = _tr_tally;\n    var _tr_align_1 = _tr_align;\n    var trees = {\n      _tr_init: _tr_init_1,\n      _tr_stored_block: _tr_stored_block_1,\n      _tr_flush_block: _tr_flush_block_1,\n      _tr_tally: _tr_tally_1,\n      _tr_align: _tr_align_1\n    }; // It isn't worth it to make additional optimizations as in original.\n    // Small size is preferable.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var adler32 = function adler32(adler, buf, len, pos) {\n      var s1 = adler & 0xffff | 0;\n      var s2 = adler >>> 16 & 0xffff | 0;\n      var n = 0;\n\n      while (len !== 0) {\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len;\n        len -= n;\n\n        do {\n          s1 = s1 + buf[pos++] | 0;\n          s2 = s2 + s1 | 0;\n        } while (--n);\n\n        s1 %= 65521;\n        s2 %= 65521;\n      }\n\n      return s1 | s2 << 16 | 0;\n    };\n\n    var adler32_1 = adler32; // So write code to minimize size - no pregenerated tables\n    // and array tools dependencies.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    // Use ordinary array, since untyped makes no boost here\n\n    var makeTable = function makeTable() {\n      var c;\n      var table = [];\n\n      for (var n = 0; n < 256; n++) {\n        c = n;\n\n        for (var k = 0; k < 8; k++) {\n          c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n        }\n\n        table[n] = c;\n      }\n\n      return table;\n    }; // Create table on load. Just 255 signed longs. Not a problem.\n\n\n    var crcTable = new Uint32Array(makeTable());\n\n    var crc32 = function crc32(crc, buf, len, pos) {\n      var t = crcTable;\n      var end = pos + len;\n      crc ^= -1;\n\n      for (var i = pos; i < end; i++) {\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xff];\n      }\n\n      return crc ^ -1; // >>> 0;\n    };\n\n    var crc32_1 = crc32; // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var messages = {\n      2: 'need dictionary',\n\n      /* Z_NEED_DICT       2  */\n      1: 'stream end',\n\n      /* Z_STREAM_END      1  */\n      0: '',\n\n      /* Z_OK              0  */\n      '-1': 'file error',\n\n      /* Z_ERRNO         (-1) */\n      '-2': 'stream error',\n\n      /* Z_STREAM_ERROR  (-2) */\n      '-3': 'data error',\n\n      /* Z_DATA_ERROR    (-3) */\n      '-4': 'insufficient memory',\n\n      /* Z_MEM_ERROR     (-4) */\n      '-5': 'buffer error',\n\n      /* Z_BUF_ERROR     (-5) */\n      '-6': 'incompatible version'\n    }; // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var constants = {\n      /* Allowed flush values; see deflate() and inflate() below for details */\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n\n      /* Return codes for the compression/decompression functions. Negative values\n       * are errors, positive values are used for special but normal events.\n       */\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_MEM_ERROR: -4,\n      Z_BUF_ERROR: -5,\n      // Z_VERSION_ERROR: -6,\n\n      /* compression levels */\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n\n      /* Possible values of the data_type field (though see inflate()) */\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      // Z_ASCII:                1, // = Z_TEXT (deprecated)\n      Z_UNKNOWN: 2,\n\n      /* The deflate compression method */\n      Z_DEFLATED: 8\n    }; // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var _tr_init$1 = trees._tr_init;\n    var _tr_stored_block$1 = trees._tr_stored_block;\n    var _tr_flush_block$1 = trees._tr_flush_block;\n    var _tr_tally$1 = trees._tr_tally;\n    var _tr_align$1 = trees._tr_align;\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n\n    var Z_NO_FLUSH = constants.Z_NO_FLUSH;\n    var Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH;\n    var Z_FULL_FLUSH = constants.Z_FULL_FLUSH;\n    var Z_FINISH = constants.Z_FINISH;\n    var Z_BLOCK = constants.Z_BLOCK;\n    var Z_OK = constants.Z_OK;\n    var Z_STREAM_END = constants.Z_STREAM_END;\n    var Z_STREAM_ERROR = constants.Z_STREAM_ERROR;\n    var Z_DATA_ERROR = constants.Z_DATA_ERROR;\n    var Z_BUF_ERROR = constants.Z_BUF_ERROR;\n    var Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION;\n    var Z_FILTERED = constants.Z_FILTERED;\n    var Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY;\n    var Z_RLE = constants.Z_RLE;\n    var Z_FIXED$1 = constants.Z_FIXED;\n    var Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY;\n    var Z_UNKNOWN$1 = constants.Z_UNKNOWN;\n    var Z_DEFLATED = constants.Z_DEFLATED;\n    /* ============================================================================ */\n\n    var MAX_MEM_LEVEL = 9;\n    /* Maximum value for memLevel in deflateInit2 */\n\n    var MAX_WBITS = 15;\n    /* 32K LZ77 window */\n\n    var DEF_MEM_LEVEL = 8;\n    var LENGTH_CODES$1 = 29;\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    var LITERALS$1 = 256;\n    /* number of literal bytes 0..255 */\n\n    var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    var D_CODES$1 = 30;\n    /* number of distance codes */\n\n    var BL_CODES$1 = 19;\n    /* number of codes used to transfer the bit lengths */\n\n    var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;\n    /* maximum heap size */\n\n    var MAX_BITS$1 = 15;\n    /* All codes must not exceed MAX_BITS bits */\n\n    var MIN_MATCH$1 = 3;\n    var MAX_MATCH$1 = 258;\n    var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;\n    var PRESET_DICT = 0x20;\n    var INIT_STATE = 42;\n    var EXTRA_STATE = 69;\n    var NAME_STATE = 73;\n    var COMMENT_STATE = 91;\n    var HCRC_STATE = 103;\n    var BUSY_STATE = 113;\n    var FINISH_STATE = 666;\n    var BS_NEED_MORE = 1;\n    /* block not completed, need more input or more output */\n\n    var BS_BLOCK_DONE = 2;\n    /* block flush performed */\n\n    var BS_FINISH_STARTED = 3;\n    /* finish started, need only more output at next deflate */\n\n    var BS_FINISH_DONE = 4;\n    /* finish done, accept no more input or output */\n\n    var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n    var err = function err(strm, errorCode) {\n      strm.msg = messages[errorCode];\n      return errorCode;\n    };\n\n    var rank = function rank(f) {\n      return (f << 1) - (f > 4 ? 9 : 0);\n    };\n\n    var zero$1 = function zero(buf) {\n      var len = buf.length;\n\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    };\n    /* eslint-disable new-cap */\n\n\n    var HASH_ZLIB = function HASH_ZLIB(s, prev, data) {\n      return (prev << s.hash_shift ^ data) & s.hash_mask;\n    }; // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n    // But breaks binary compatibility\n    // let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n\n\n    var HASH = HASH_ZLIB;\n    /* =========================================================================\n     * Flush as much pending output as possible. All deflate() output goes\n     * through this function so some applications may wish to modify it\n     * to avoid allocating a large strm->output buffer and copying into it.\n     * (See also read_buf()).\n     */\n\n    var flush_pending = function flush_pending(strm) {\n      var s = strm.state; // _tr_flush_bits(s);\n\n      var len = s.pending;\n\n      if (len > strm.avail_out) {\n        len = strm.avail_out;\n      }\n\n      if (len === 0) {\n        return;\n      }\n\n      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n      strm.next_out += len;\n      s.pending_out += len;\n      strm.total_out += len;\n      strm.avail_out -= len;\n      s.pending -= len;\n\n      if (s.pending === 0) {\n        s.pending_out = 0;\n      }\n    };\n\n    var flush_block_only = function flush_block_only(s, last) {\n      _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n\n      s.block_start = s.strstart;\n      flush_pending(s.strm);\n    };\n\n    var put_byte = function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    };\n    /* =========================================================================\n     * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n     * IN assertion: the stream state is correct and there is enough room in\n     * pending_buf.\n     */\n\n\n    var putShortMSB = function putShortMSB(s, b) {\n      //  put_byte(s, (Byte)(b >> 8));\n      //  put_byte(s, (Byte)(b & 0xff));\n      s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n      s.pending_buf[s.pending++] = b & 0xff;\n    };\n    /* ===========================================================================\n     * Read a new buffer from the current input stream, update the adler32\n     * and total number of bytes read.  All deflate() input goes through\n     * this function so some applications may wish to modify it to avoid\n     * allocating a large strm->input buffer and copying from it.\n     * (See also flush_pending()).\n     */\n\n\n    var read_buf = function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n\n      if (len > size) {\n        len = size;\n      }\n\n      if (len === 0) {\n        return 0;\n      }\n\n      strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);\n\n      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32_1(strm.adler, buf, len, start);\n      } else if (strm.state.wrap === 2) {\n        strm.adler = crc32_1(strm.adler, buf, len, start);\n      }\n\n      strm.next_in += len;\n      strm.total_in += len;\n      return len;\n    };\n    /* ===========================================================================\n     * Set match_start to the longest match starting at the given string and\n     * return its length. Matches shorter or equal to prev_length are discarded,\n     * in which case the result is equal to prev_length and match_start is\n     * garbage.\n     * IN assertions: cur_match is the head of the hash chain for the current\n     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n     * OUT assertion: the match length is not greater than s->lookahead.\n     */\n\n\n    var longest_match = function longest_match(s, cur_match) {\n      var chain_length = s.max_chain_length;\n      /* max hash chain length */\n\n      var scan = s.strstart;\n      /* current string */\n\n      var match;\n      /* matched string */\n\n      var len;\n      /* length of current match */\n\n      var best_len = s.prev_length;\n      /* best match length so far */\n\n      var nice_match = s.nice_match;\n      /* stop if match long enough */\n\n      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n      /* NIL */\n\n      var _win = s.window; // shortcut\n\n      var wmask = s.w_mask;\n      var prev = s.prev;\n      /* Stop when cur_match becomes <= limit. To simplify the code,\n       * we prevent matches with the string of window index 0.\n       */\n\n      var strend = s.strstart + MAX_MATCH$1;\n      var scan_end1 = _win[scan + best_len - 1];\n      var scan_end = _win[scan + best_len];\n      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n       * It is easy to get rid of this optimization if necessary.\n       */\n      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n      /* Do not waste too much time if we already have a good match: */\n\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n      }\n      /* Do not look for matches beyond the end of the input. This is necessary\n       * to make deflate deterministic.\n       */\n\n\n      if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n      } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n\n      do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match;\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         */\n\n        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n          continue;\n        }\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n\n\n        scan += 2;\n        match++; // Assert(*scan == *match, \"match[2]?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n\n        do {\n          /* jshint noempty:false */\n        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n\n        len = MAX_MATCH$1 - (strend - scan);\n        scan = strend - MAX_MATCH$1;\n\n        if (len > best_len) {\n          s.match_start = cur_match;\n          best_len = len;\n\n          if (len >= nice_match) {\n            break;\n          }\n\n          scan_end1 = _win[scan + best_len - 1];\n          scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n      if (best_len <= s.lookahead) {\n        return best_len;\n      }\n\n      return s.lookahead;\n    };\n    /* ===========================================================================\n     * Fill the window when the lookahead becomes insufficient.\n     * Updates strstart and lookahead.\n     *\n     * IN assertion: lookahead < MIN_LOOKAHEAD\n     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n     *    At least one byte has been read, or avail_in == 0; reads are\n     *    performed for at least two bytes (required for the zip translate_eol\n     *    option -- not supported here).\n     */\n\n\n    var fill_window = function fill_window(s) {\n      var _w_size = s.w_size;\n      var p;\n      var n;\n      var m;\n      var more;\n      var str; // Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n      do {\n        more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed\n\n        /* Deal with !@#$% 64K limit: */\n        // if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        // }\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n          s.match_start -= _w_size;\n          s.strstart -= _w_size;\n          /* we now have strstart >= MAX_DIST */\n\n          s.block_start -= _w_size;\n          /* Slide the hash table (could be avoided with 32 bit values\n          at the expense of memory usage). We slide even when level == 0\n          to keep the hash table consistent if we switch back to level > 0\n          later. (Using level 0 permanently is not an optimal usage of\n          zlib, so we don't care about this pathological case.)\n          */\n\n          n = s.hash_size;\n          p = n;\n\n          do {\n            m = s.head[--p];\n            s.head[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n\n          n = _w_size;\n          p = n;\n\n          do {\n            m = s.prev[--p];\n            s.prev[p] = m >= _w_size ? m - _w_size : 0;\n            /* If n is not on any hash chain, prev[n] is garbage but\n             * its value will never be used.\n             */\n          } while (--n);\n\n          more += _w_size;\n        }\n\n        if (s.strm.avail_in === 0) {\n          break;\n        }\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        // Assert(more >= 2, \"more < 2\");\n\n\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        /* Initialize the hash value now that we have some input: */\n\n        if (s.lookahead + s.insert >= MIN_MATCH$1) {\n          str = s.strstart - s.insert;\n          s.ins_h = s.window[str];\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\n          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); // #if MIN_MATCH != 3\n          //        Call update_hash() MIN_MATCH-3 more times\n          // #endif\n\n          while (s.insert) {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n            s.insert--;\n\n            if (s.lookahead + s.insert < MIN_MATCH$1) {\n              break;\n            }\n          }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n      /* If the WIN_INIT bytes after the end of the current data have never been\n       * written, then zero those bytes in order to avoid memory check reports of\n       * the use of uninitialized (or uninitialised as Julian writes) bytes by\n       * the longest match routines.  Update the high water mark for the next\n       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n       */\n      //  if (s.high_water < s.window_size) {\n      //    const curr = s.strstart + s.lookahead;\n      //    let init = 0;\n      //\n      //    if (s.high_water < curr) {\n      //      /* Previous high water mark below current data -- zero WIN_INIT\n      //       * bytes or up to end of window, whichever is less.\n      //       */\n      //      init = s.window_size - curr;\n      //      if (init > WIN_INIT)\n      //        init = WIN_INIT;\n      //      zmemzero(s->window + curr, (unsigned)init);\n      //      s->high_water = curr + init;\n      //    }\n      //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n      //      /* High water mark at or above current data, but below current data\n      //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n      //       * to end of window, whichever is less.\n      //       */\n      //      init = (ulg)curr + WIN_INIT - s->high_water;\n      //      if (init > s->window_size - s->high_water)\n      //        init = s->window_size - s->high_water;\n      //      zmemzero(s->window + s->high_water, (unsigned)init);\n      //      s->high_water += init;\n      //    }\n      //  }\n      //\n      //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n      //    \"not enough room for search\");\n\n    };\n    /* ===========================================================================\n     * Copy without compression as much as possible from the input stream, return\n     * the current block state.\n     * This function does not insert new strings in the dictionary since\n     * uncompressible data is probably not useful. This function is used\n     * only for the level=0 compression option.\n     * NOTE: this function should be optimized to avoid extra copying from\n     * window to pending_buf.\n     */\n\n\n    var deflate_stored = function deflate_stored(s, flush) {\n      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n       * to pending_buf_size, and each stored block has a 5 byte header:\n       */\n      var max_block_size = 0xffff;\n\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n      }\n      /* Copy as much as possible from input to output: */\n\n\n      for (;;) {\n        /* Fill the window as much as possible: */\n        if (s.lookahead <= 1) {\n          // Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n          //  s->block_start >= (long)s->w_size, \"slide too late\");\n          //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n          //        s.block_start >= s.w_size)) {\n          //        throw  new Error(\"slide too late\");\n          //      }\n          fill_window(s);\n\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n\n        } // Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        /* Emit a stored block if pending_buf will be full: */\n\n        var max_start = s.block_start + max_block_size;\n\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          /* strstart == 0 is possible when wraparound on 16-bit machine */\n          s.lookahead = s.strstart - max_start;\n          s.strstart = max_start;\n          /** * FLUSH_BLOCK(s, 0); ** */\n\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n        /* Flush if we may have to slide, otherwise block_start may become\n         * negative and the data will be gone:\n         */\n\n\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n      }\n\n      s.insert = 0;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.strstart > s.block_start) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_NEED_MORE;\n    };\n    /* ===========================================================================\n     * Compress as much as possible from the input stream, return the current\n     * block state.\n     * This function does not perform lazy evaluation of matches and inserts\n     * new strings in the dictionary only for unmatched strings or for short\n     * matches. It is used only for the fast compression options.\n     */\n\n\n    var deflate_fast = function deflate_fast(s, flush) {\n      var hash_head;\n      /* head of the hash chain */\n\n      var bflush;\n      /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n            /* flush the current block */\n          }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n\n        hash_head = 0;\n        /* NIL */\n\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n\n\n        if (hash_head !== 0 &&\n        /* NIL */\n        s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head);\n          /* longest_match() sets match_start */\n        }\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n          /** * _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);\n          s.lookahead -= s.match_length;\n          /* Insert new strings in the hash table only if the match length\n           * is not too large. This saves time but degrades compression.\n           */\n\n          if (s.match_length <= s.max_lazy_match &&\n          /* max_insert_length */\n          s.lookahead >= MIN_MATCH$1) {\n            s.match_length--;\n            /* string at strstart already in table */\n\n            do {\n              s.strstart++;\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n              /***/\n\n              /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n               * always MIN_MATCH bytes ahead.\n               */\n            } while (--s.match_length !== 0);\n\n            s.strstart++;\n          } else {\n            s.strstart += s.match_length;\n            s.match_length = 0;\n            s.ins_h = s.window[s.strstart];\n            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]); // #if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            // #endif\n\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n             * matter since it will be recomputed at next deflate call.\n             */\n          }\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * Same as above, but achieves better compression. We use a lazy\n     * evaluation for matches: a match is finally adopted only if there is\n     * no better match at the next window position.\n     */\n\n\n    var deflate_slow = function deflate_slow(s, flush) {\n      var hash_head;\n      /* head of hash chain */\n\n      var bflush;\n      /* set if current block must be flushed */\n\n      var max_insert;\n      /* Process the input block. */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n\n        hash_head = 0;\n        /* NIL */\n\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         */\n\n\n        s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH$1 - 1;\n\n        if (hash_head !== 0 &&\n        /* NIL */\n        s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n        /* MAX_DIST(s) */\n        ) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head);\n          /* longest_match() sets match_start */\n\n          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096)\n          /* TOO_FAR */\n          ) {\n            /* If prev_match is also MIN_MATCH, match_start is garbage\n             * but we will ignore the current match anyway.\n             */\n            s.match_length = MIN_MATCH$1 - 1;\n          }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n\n\n        if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH$1;\n          /* Do not insert strings in hash table beyond this. */\n          // check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n          /** *_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);** */\n\n          bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);\n          /* Insert in hash table all strings up to the end of the match.\n           * strstart-1 and strstart are already inserted. If there is not\n           * enough lookahead, the last two strings are not inserted in\n           * the hash table.\n           */\n\n          s.lookahead -= s.prev_length - 1;\n          s.prev_length -= 2;\n\n          do {\n            if (++s.strstart <= max_insert) {\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n              /***/\n            }\n          } while (--s.prev_length !== 0);\n\n          s.match_available = 0;\n          s.match_length = MIN_MATCH$1 - 1;\n          s.strstart++;\n\n          if (bflush) {\n            /** * FLUSH_BLOCK(s, 0); ** */\n            flush_block_only(s, false);\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n\n          }\n        } else if (s.match_available) {\n          /* If there was no match at the previous position, output a\n           * single literal. If there was a match but the current match\n           * is longer, truncate the previous match to a single literal.\n           */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n\n          if (bflush) {\n            /** * FLUSH_BLOCK_ONLY(s, 0) ** */\n            flush_block_only(s, false);\n            /***/\n          }\n\n          s.strstart++;\n          s.lookahead--;\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        } else {\n          /* There is no previous match to compare with, wait for\n           * the next step to decide.\n           */\n          s.match_available = 1;\n          s.strstart++;\n          s.lookahead--;\n        }\n      } // Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\n\n      if (s.match_available) {\n        // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n        /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n     * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n     * deflate switches away from Z_RLE.)\n     */\n\n\n    var deflate_rle = function deflate_rle(s, flush) {\n      var bflush;\n      /* set if current block must be flushed */\n\n      var prev;\n      /* byte at distance one to match */\n\n      var scan;\n      var strend;\n      /* scan goes up to strend for length of run */\n\n      var _win = s.window;\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s.lookahead <= MAX_MATCH$1) {\n          fill_window(s);\n\n          if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n\n        }\n        /* See how many times the previous byte repeats */\n\n\n        s.match_length = 0;\n\n        if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {\n          scan = s.strstart - 1;\n          prev = _win[scan];\n\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH$1;\n\n            do {\n              /* jshint noempty:false */\n            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n\n            s.match_length = MAX_MATCH$1 - (strend - scan);\n\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead;\n            }\n          } // Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n          /** * _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);\n          s.lookahead -= s.match_length;\n          s.strstart += s.match_length;\n          s.match_length = 0;\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n      }\n\n      s.insert = 0;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* ===========================================================================\n     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n     * (It will be regenerated if this run of deflate switches away from Huffman.)\n     */\n\n\n    var deflate_huff = function deflate_huff(s, flush) {\n      var bflush;\n      /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s.lookahead === 0) {\n          fill_window(s);\n\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n\n            break;\n            /* flush the current block */\n          }\n        }\n        /* Output a literal byte */\n\n\n        s.match_length = 0; // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n        /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n      }\n\n      s.insert = 0;\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true);\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n\n\n        return BS_FINISH_DONE;\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n\n      return BS_BLOCK_DONE;\n    };\n    /* Values for max_lazy_match, good_match and max_chain_length, depending on\n     * the desired pack level (0..9). The values given below have been tuned to\n     * exclude worst case performance for pathological files. Better values may be\n     * found for specific files.\n     */\n\n\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length;\n      this.max_lazy = max_lazy;\n      this.nice_length = nice_length;\n      this.max_chain = max_chain;\n      this.func = func;\n    }\n\n    var configuration_table = [\n    /*      good lazy nice chain */\n    new Config(0, 0, 0, 0, deflate_stored),\n    /* 0 store only */\n    new Config(4, 4, 8, 4, deflate_fast),\n    /* 1 max speed, no lazy matches */\n    new Config(4, 5, 16, 8, deflate_fast),\n    /* 2 */\n    new Config(4, 6, 32, 32, deflate_fast),\n    /* 3 */\n    new Config(4, 4, 16, 16, deflate_slow),\n    /* 4 lazy matches */\n    new Config(8, 16, 32, 32, deflate_slow),\n    /* 5 */\n    new Config(8, 16, 128, 128, deflate_slow),\n    /* 6 */\n    new Config(8, 32, 128, 256, deflate_slow),\n    /* 7 */\n    new Config(32, 128, 258, 1024, deflate_slow),\n    /* 8 */\n    new Config(32, 258, 258, 4096, deflate_slow)];\n    /* ===========================================================================\n     * Initialize the \"longest match\" routines for a new zlib stream\n     */\n\n    var lm_init = function lm_init(s) {\n      s.window_size = 2 * s.w_size;\n      /** * CLEAR_HASH(s); ** */\n\n      zero$1(s.head); // Fill with NIL (= 0);\n\n      /* Set the default configuration parameters:\n       */\n\n      s.max_lazy_match = configuration_table[s.level].max_lazy;\n      s.good_match = configuration_table[s.level].good_length;\n      s.nice_match = configuration_table[s.level].nice_length;\n      s.max_chain_length = configuration_table[s.level].max_chain;\n      s.strstart = 0;\n      s.block_start = 0;\n      s.lookahead = 0;\n      s.insert = 0;\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n      s.match_available = 0;\n      s.ins_h = 0;\n    };\n\n    function DeflateState() {\n      this.strm = null;\n      /* pointer back to this zlib stream */\n\n      this.status = 0;\n      /* as the name implies */\n\n      this.pending_buf = null;\n      /* output still pending */\n\n      this.pending_buf_size = 0;\n      /* size of pending_buf */\n\n      this.pending_out = 0;\n      /* next pending byte to output to the stream */\n\n      this.pending = 0;\n      /* nb of bytes in the pending buffer */\n\n      this.wrap = 0;\n      /* bit 0 true for zlib, bit 1 true for gzip */\n\n      this.gzhead = null;\n      /* gzip header information to write */\n\n      this.gzindex = 0;\n      /* where in extra, name, or comment */\n\n      this.method = Z_DEFLATED;\n      /* can only be DEFLATED */\n\n      this.last_flush = -1;\n      /* value of flush param for previous deflate call */\n\n      this.w_size = 0;\n      /* LZ77 window size (32K by default) */\n\n      this.w_bits = 0;\n      /* log2(w_size)  (8..16) */\n\n      this.w_mask = 0;\n      /* w_size - 1 */\n\n      this.window = null;\n      /* Sliding window. Input bytes are read into the second half of the window,\n       * and move to the first half later to keep a dictionary of at least wSize\n       * bytes. With this organization, matches are limited to a distance of\n       * wSize-MAX_MATCH bytes, but this ensures that IO is always\n       * performed with a length multiple of the block size.\n       */\n\n      this.window_size = 0;\n      /* Actual size of window: 2*wSize, except when the user input buffer\n       * is directly used as sliding window.\n       */\n\n      this.prev = null;\n      /* Link to older string with same hash index. To limit the size of this\n       * array to 64K, this link is maintained only for the last 32K strings.\n       * An index in this array is thus a window index modulo 32K.\n       */\n\n      this.head = null;\n      /* Heads of the hash chains or NIL. */\n\n      this.ins_h = 0;\n      /* hash index of string to be inserted */\n\n      this.hash_size = 0;\n      /* number of elements in hash table */\n\n      this.hash_bits = 0;\n      /* log2(hash_size) */\n\n      this.hash_mask = 0;\n      /* hash_size-1 */\n\n      this.hash_shift = 0;\n      /* Number of bits by which ins_h must be shifted at each input\n       * step. It must be such that after MIN_MATCH steps, the oldest\n       * byte no longer takes part in the hash key, that is:\n       *   hash_shift * MIN_MATCH >= hash_bits\n       */\n\n      this.block_start = 0;\n      /* Window position at the beginning of the current output block. Gets\n       * negative when the window is moved backwards.\n       */\n\n      this.match_length = 0;\n      /* length of best match */\n\n      this.prev_match = 0;\n      /* previous match */\n\n      this.match_available = 0;\n      /* set if previous match exists */\n\n      this.strstart = 0;\n      /* start of string to insert */\n\n      this.match_start = 0;\n      /* start of matching string */\n\n      this.lookahead = 0;\n      /* number of valid bytes ahead in window */\n\n      this.prev_length = 0;\n      /* Length of the best match at previous step. Matches not greater than this\n       * are discarded. This is used in the lazy match evaluation.\n       */\n\n      this.max_chain_length = 0;\n      /* To speed up deflation, hash chains are never searched beyond this\n       * length.  A higher limit improves compression ratio but degrades the\n       * speed.\n       */\n\n      this.max_lazy_match = 0;\n      /* Attempt to find a better match only when the current match is strictly\n       * smaller than this value. This mechanism is used only for compression\n       * levels >= 4.\n       */\n      // That's alias to max_lazy_match, don't use directly\n      // this.max_insert_length = 0;\n\n      /* Insert new strings in the hash table only if the match length is not\n       * greater than this length. This saves time but degrades compression.\n       * max_insert_length is used only for compression levels <= 3.\n       */\n\n      this.level = 0;\n      /* compression level (1..9) */\n\n      this.strategy = 0;\n      /* favor or force Huffman coding */\n\n      this.good_match = 0;\n      /* Use a faster search when the previous match is longer than this */\n\n      this.nice_match = 0;\n      /* Stop searching when current match exceeds this */\n\n      /* used by trees.c: */\n\n      /* Didn't use ct_data typedef below to suppress compiler warning */\n      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n      // Use flat array of DOUBLE size, with interleaved fata,\n      // because JS does not support effective\n\n      this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2);\n      this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2);\n      this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2);\n      zero$1(this.dyn_ltree);\n      zero$1(this.dyn_dtree);\n      zero$1(this.bl_tree);\n      this.l_desc = null;\n      /* desc. for literal tree */\n\n      this.d_desc = null;\n      /* desc. for distance tree */\n\n      this.bl_desc = null;\n      /* desc. for bit length tree */\n      // ush bl_count[MAX_BITS+1];\n\n      this.bl_count = new Uint16Array(MAX_BITS$1 + 1);\n      /* number of codes at each bit length for an optimal tree */\n      // int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\n      this.heap = new Uint16Array(2 * L_CODES$1 + 1);\n      /* heap used to build the Huffman trees */\n\n      zero$1(this.heap);\n      this.heap_len = 0;\n      /* number of elements in the heap */\n\n      this.heap_max = 0;\n      /* element of largest frequency */\n\n      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n       * The same heap array is used to build all trees.\n       */\n\n      this.depth = new Uint16Array(2 * L_CODES$1 + 1); // uch depth[2*L_CODES+1];\n\n      zero$1(this.depth);\n      /* Depth of each subtree used as tie breaker for trees of equal frequency\n       */\n\n      this.l_buf = 0;\n      /* buffer index for literals or lengths */\n\n      this.lit_bufsize = 0;\n      /* Size of match buffer for literals/lengths.  There are 4 reasons for\n       * limiting lit_bufsize to 64K:\n       *   - frequencies can be kept in 16 bit counters\n       *   - if compression is not successful for the first block, all input\n       *     data is still in the window so we can still emit a stored block even\n       *     when input comes from standard input.  (This can also be done for\n       *     all blocks if lit_bufsize is not greater than 32K.)\n       *   - if compression is not successful for a file smaller than 64K, we can\n       *     even emit a stored file instead of a stored block (saving 5 bytes).\n       *     This is applicable only for zip (not gzip or zlib).\n       *   - creating new Huffman trees less frequently may not provide fast\n       *     adaptation to changes in the input data statistics. (Take for\n       *     example a binary file with poorly compressible code followed by\n       *     a highly compressible string table.) Smaller buffer sizes give\n       *     fast adaptation but have of course the overhead of transmitting\n       *     trees more frequently.\n       *   - I can't count above 4\n       */\n\n      this.last_lit = 0;\n      /* running index in l_buf */\n\n      this.d_buf = 0;\n      /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n       * the same number of elements. To use different lengths, an extra flag\n       * array would be necessary.\n       */\n\n      this.opt_len = 0;\n      /* bit length of current block with optimal trees */\n\n      this.static_len = 0;\n      /* bit length of current block with static trees */\n\n      this.matches = 0;\n      /* number of string matches in current block */\n\n      this.insert = 0;\n      /* bytes at end of window left to insert */\n\n      this.bi_buf = 0;\n      /* Output buffer. bits are inserted starting at the bottom (least\n       * significant bits).\n       */\n\n      this.bi_valid = 0;\n      /* Number of valid bits in bi_buf.  All bits above the last valid bit\n       * are always zero.\n       */\n      // Used for window memory init. We safely ignore it for JS. That makes\n      // sense only for pointers and memory check tools.\n      // this.high_water = 0;\n\n      /* High water mark offset in window for initialized bytes -- bytes above\n       * this are set to zero in order to avoid memory check warnings when\n       * longest match routines access bytes past the input.  This is then\n       * updated to the new high water mark.\n       */\n    }\n\n    var deflateResetKeep = function deflateResetKeep(strm) {\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n      strm.total_in = strm.total_out = 0;\n      strm.data_type = Z_UNKNOWN$1;\n      var s = strm.state;\n      s.pending = 0;\n      s.pending_out = 0;\n\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n        /* was made negative by deflate(..., Z_FINISH); */\n      }\n\n      s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n      strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n      : 1; // adler32(0, Z_NULL, 0)\n\n      s.last_flush = Z_NO_FLUSH;\n\n      _tr_init$1(s);\n\n      return Z_OK;\n    };\n\n    var deflateReset = function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n\n      if (ret === Z_OK) {\n        lm_init(strm.state);\n      }\n\n      return ret;\n    };\n\n    var deflateSetHeader = function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n\n      if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n      }\n\n      strm.state.gzhead = head;\n      return Z_OK;\n    };\n\n    var deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm) {\n        // === Z_NULL\n        return Z_STREAM_ERROR;\n      }\n\n      var wrap = 1;\n\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n      }\n\n      if (windowBits < 0) {\n        /* suppress zlib wrapper */\n        wrap = 0;\n        windowBits = -windowBits;\n      } else if (windowBits > 15) {\n        wrap = 2;\n        /* write gzip wrapper instead */\n\n        windowBits -= 16;\n      }\n\n      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$1) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n      if (windowBits === 8) {\n        windowBits = 9;\n      }\n      /* until 256-byte window bug fixed */\n\n\n      var s = new DeflateState();\n      strm.state = s;\n      s.strm = strm;\n      s.wrap = wrap;\n      s.gzhead = null;\n      s.w_bits = windowBits;\n      s.w_size = 1 << s.w_bits;\n      s.w_mask = s.w_size - 1;\n      s.hash_bits = memLevel + 7;\n      s.hash_size = 1 << s.hash_bits;\n      s.hash_mask = s.hash_size - 1;\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);\n      s.window = new Uint8Array(s.w_size * 2);\n      s.head = new Uint16Array(s.hash_size);\n      s.prev = new Uint16Array(s.w_size); // Don't need mem init magic for JS.\n      // s.high_water = 0;  /* nothing written to s->window yet */\n\n      s.lit_bufsize = 1 << memLevel + 6;\n      /* 16K elements by default */\n\n      s.pending_buf_size = s.lit_bufsize * 4; // overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n      // s->pending_buf = (uchf *) overlay;\n\n      s.pending_buf = new Uint8Array(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n      // s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\n      s.d_buf = 1 * s.lit_bufsize; // s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n      s.l_buf = (1 + 2) * s.lit_bufsize;\n      s.level = level;\n      s.strategy = strategy;\n      s.method = method;\n      return deflateReset(strm);\n    };\n\n    var deflateInit = function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    };\n\n    var deflate = function deflate(strm, flush) {\n      var beg;\n      var val; // for gzip header write only\n\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      }\n\n      var s = strm.state;\n\n      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n      }\n\n      s.strm = strm;\n      /* just in case */\n\n      var old_flush = s.last_flush;\n      s.last_flush = flush;\n      /* Write the header */\n\n      if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n          // GZIP header\n          strm.adler = 0; // crc32(0L, Z_NULL, 0);\n\n          put_byte(s, 31);\n          put_byte(s, 139);\n          put_byte(s, 8);\n\n          if (!s.gzhead) {\n            // s->gzhead == Z_NULL\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, OS_CODE);\n            s.status = BUSY_STATE;\n          } else {\n            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n            put_byte(s, s.gzhead.time & 0xff);\n            put_byte(s, s.gzhead.time >> 8 & 0xff);\n            put_byte(s, s.gzhead.time >> 16 & 0xff);\n            put_byte(s, s.gzhead.time >> 24 & 0xff);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, s.gzhead.os & 0xff);\n\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 0xff);\n              put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n            }\n\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n            }\n\n            s.gzindex = 0;\n            s.status = EXTRA_STATE;\n          }\n        } // DEFLATE header\n        else {\n          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n          var level_flags = -1;\n\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0;\n          } else if (s.level < 6) {\n            level_flags = 1;\n          } else if (s.level === 6) {\n            level_flags = 2;\n          } else {\n            level_flags = 3;\n          }\n\n          header |= level_flags << 6;\n\n          if (s.strstart !== 0) {\n            header |= PRESET_DICT;\n          }\n\n          header += 31 - header % 31;\n          s.status = BUSY_STATE;\n          putShortMSB(s, header);\n          /* Save the adler32 of the preset dictionary: */\n\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16);\n            putShortMSB(s, strm.adler & 0xffff);\n          }\n\n          strm.adler = 1; // adler32(0L, Z_NULL, 0);\n        }\n      } // #ifdef GZIP\n\n\n      if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra\n        /* != Z_NULL */\n        ) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n\n          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              flush_pending(strm);\n              beg = s.pending;\n\n              if (s.pending === s.pending_buf_size) {\n                break;\n              }\n            }\n\n            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n            s.gzindex++;\n          }\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0;\n            s.status = NAME_STATE;\n          }\n        } else {\n          s.status = NAME_STATE;\n        }\n      }\n\n      if (s.status === NAME_STATE) {\n        if (s.gzhead.name\n        /* != Z_NULL */\n        ) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n          // int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              flush_pending(strm);\n              beg = s.pending;\n\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n\n\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n            } else {\n              val = 0;\n            }\n\n            put_byte(s, val);\n          } while (val !== 0);\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          if (val === 0) {\n            s.gzindex = 0;\n            s.status = COMMENT_STATE;\n          }\n        } else {\n          s.status = COMMENT_STATE;\n        }\n      }\n\n      if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment\n        /* != Z_NULL */\n        ) {\n          beg = s.pending;\n          /* start of bytes to update crc */\n          // int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              flush_pending(strm);\n              beg = s.pending;\n\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n\n\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n            } else {\n              val = 0;\n            }\n\n            put_byte(s, val);\n          } while (val !== 0);\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          if (val === 0) {\n            s.status = HCRC_STATE;\n          }\n        } else {\n          s.status = HCRC_STATE;\n        }\n      }\n\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm);\n          }\n\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 0xff);\n            put_byte(s, strm.adler >> 8 & 0xff);\n            strm.adler = 0; // crc32(0L, Z_NULL, 0);\n\n            s.status = BUSY_STATE;\n          }\n        } else {\n          s.status = BUSY_STATE;\n        }\n      } // #endif\n\n      /* Flush as much pending output as possible */\n\n\n      if (s.pending !== 0) {\n        flush_pending(strm);\n\n        if (strm.avail_out === 0) {\n          /* Since avail_out is 0, deflate will be called again with\n           * more output space, but possibly with both pending and\n           * avail_in equal to zero. There won't be anything to do,\n           * but this is not an error situation so make sure we\n           * return OK instead of BUF_ERROR at next call of deflate:\n           */\n          s.last_flush = -1;\n          return Z_OK;\n        }\n        /* Make sure there is something to do and avoid duplicate consecutive\n         * flushes. For repeated and useless calls with Z_FINISH, we keep\n         * returning Z_STREAM_END instead of Z_BUF_ERROR.\n         */\n\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      /* User must not provide more input after the first FINISH: */\n\n\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      /* Start a new block or continue the current one.\n       */\n\n\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE;\n        }\n\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            /* avoid BUF_ERROR next call, see above */\n          }\n\n          return Z_OK;\n          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n           * of deflate should use the same flush parameter to make sure\n           * that the flush is complete. So we don't have to output an\n           * empty block here, this will be done at next call. This also\n           * ensures that for a very small output buffer, we emit at most\n           * one empty block.\n           */\n        }\n\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            _tr_align$1(s);\n          } else if (flush !== Z_BLOCK) {\n            /* FULL_FLUSH or SYNC_FLUSH */\n            _tr_stored_block$1(s, 0, 0, false);\n            /* For a full flush, this empty block will be recognized\n             * as a special marker by inflate_sync().\n             */\n\n\n            if (flush === Z_FULL_FLUSH) {\n              /** * CLEAR_HASH(s); ** */\n\n              /* forget history */\n              zero$1(s.head); // Fill with NIL (= 0);\n\n              if (s.lookahead === 0) {\n                s.strstart = 0;\n                s.block_start = 0;\n                s.insert = 0;\n              }\n            }\n          }\n\n          flush_pending(strm);\n\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            /* avoid BUF_ERROR at next call, see above */\n\n            return Z_OK;\n          }\n        }\n      } // Assert(strm->avail_out > 0, \"bug2\");\n      // if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n\n      if (flush !== Z_FINISH) {\n        return Z_OK;\n      }\n\n      if (s.wrap <= 0) {\n        return Z_STREAM_END;\n      }\n      /* Write the trailer */\n\n\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        put_byte(s, strm.adler >> 16 & 0xff);\n        put_byte(s, strm.adler >> 24 & 0xff);\n        put_byte(s, strm.total_in & 0xff);\n        put_byte(s, strm.total_in >> 8 & 0xff);\n        put_byte(s, strm.total_in >> 16 & 0xff);\n        put_byte(s, strm.total_in >> 24 & 0xff);\n      } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n\n      flush_pending(strm);\n      /* If avail_out is zero, the application will call deflate again\n       * to flush the rest.\n       */\n\n      if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n      }\n      /* write the trailer only once! */\n\n\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n    };\n\n    var deflateEnd = function deflateEnd(strm) {\n      if (!strm ||\n      /* == Z_NULL */\n      !strm.state\n      /* == Z_NULL */\n      ) {\n        return Z_STREAM_ERROR;\n      }\n\n      var status = strm.state.status;\n\n      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n      strm.state = null;\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n    };\n    /* =========================================================================\n     * Initializes the compression dictionary from the given byte\n     * sequence without producing any compressed output.\n     */\n\n\n    var deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n\n      if (!strm ||\n      /* == Z_NULL */\n      !strm.state\n      /* == Z_NULL */\n      ) {\n        return Z_STREAM_ERROR;\n      }\n\n      var s = strm.state;\n      var wrap = s.wrap;\n\n      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n        return Z_STREAM_ERROR;\n      }\n      /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\n\n      if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */\n        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n      }\n\n      s.wrap = 0;\n      /* avoid computing Adler-32 in read_buf */\n\n      /* if dictionary would fill window, just replace the history */\n\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n          /* already empty otherwise */\n\n          /** * CLEAR_HASH(s); ** */\n          zero$1(s.head); // Fill with NIL (= 0);\n\n          s.strstart = 0;\n          s.block_start = 0;\n          s.insert = 0;\n        }\n        /* use the tail */\n        // dictionary = dictionary.slice(dictLength - s.w_size);\n\n\n        var tmpDict = new Uint8Array(s.w_size);\n        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n      }\n      /* insert dictionary into window and hash */\n\n\n      var avail = strm.avail_in;\n      var next = strm.next_in;\n      var input = strm.input;\n      strm.avail_in = dictLength;\n      strm.next_in = 0;\n      strm.input = dictionary;\n      fill_window(s);\n\n      while (s.lookahead >= MIN_MATCH$1) {\n        var str = s.strstart;\n        var n = s.lookahead - (MIN_MATCH$1 - 1);\n\n        do {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n        } while (--n);\n\n        s.strstart = str;\n        s.lookahead = MIN_MATCH$1 - 1;\n        fill_window(s);\n      }\n\n      s.strstart += s.lookahead;\n      s.block_start = s.strstart;\n      s.insert = s.lookahead;\n      s.lookahead = 0;\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n      s.match_available = 0;\n      strm.next_in = next;\n      strm.input = input;\n      strm.avail_in = avail;\n      s.wrap = wrap;\n      return Z_OK;\n    };\n\n    var deflateInit_1 = deflateInit;\n    var deflateInit2_1 = deflateInit2;\n    var deflateReset_1 = deflateReset;\n    var deflateResetKeep_1 = deflateResetKeep;\n    var deflateSetHeader_1 = deflateSetHeader;\n    var deflate_2 = deflate;\n    var deflateEnd_1 = deflateEnd;\n    var deflateSetDictionary_1 = deflateSetDictionary;\n    var deflateInfo = 'pako deflate (from Nodeca project)';\n    /* Not implemented\n    module.exports.deflateBound = deflateBound;\n    module.exports.deflateCopy = deflateCopy;\n    module.exports.deflateParams = deflateParams;\n    module.exports.deflatePending = deflatePending;\n    module.exports.deflatePrime = deflatePrime;\n    module.exports.deflateTune = deflateTune;\n    */\n\n    var deflate_1 = {\n      deflateInit: deflateInit_1,\n      deflateInit2: deflateInit2_1,\n      deflateReset: deflateReset_1,\n      deflateResetKeep: deflateResetKeep_1,\n      deflateSetHeader: deflateSetHeader_1,\n      deflate: deflate_2,\n      deflateEnd: deflateEnd_1,\n      deflateSetDictionary: deflateSetDictionary_1,\n      deflateInfo: deflateInfo\n    };\n\n    function _typeof(obj) {\n      '@babel/helpers - typeof';\n\n      if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n        _typeof = function (obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function (obj) {\n          return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    var _has = function _has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    };\n\n    var assign = function assign(obj\n    /* from1, from2, from3, ... */\n    ) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n\n      while (sources.length) {\n        var source = sources.shift();\n\n        if (!source) {\n          continue;\n        }\n\n        if (_typeof(source) !== 'object') {\n          throw new TypeError(source + \"must be non-object\");\n        }\n\n        for (var p in source) {\n          if (_has(source, p)) {\n            obj[p] = source[p];\n          }\n        }\n      }\n\n      return obj;\n    }; // Join array of chunks to single array.\n\n\n    var flattenChunks = function flattenChunks(chunks) {\n      // calculate data length\n      var len = 0;\n\n      for (var i = 0, l = chunks.length; i < l; i++) {\n        len += chunks[i].length;\n      } // join chunks\n\n\n      var result = new Uint8Array(len);\n\n      for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {\n        var chunk = chunks[_i];\n        result.set(chunk, pos);\n        pos += chunk.length;\n      }\n\n      return result;\n    };\n\n    var common = {\n      assign: assign,\n      flattenChunks: flattenChunks\n    }; // String encode/decode helpers\n    //\n    // - apply(Array) can fail on Android 2.2\n    // - apply(Uint8Array) can fail on iOS 5.1 Safari\n    //\n\n    var STR_APPLY_UIA_OK = true;\n\n    try {\n      String.fromCharCode.apply(null, new Uint8Array(1));\n    } catch (__) {\n      STR_APPLY_UIA_OK = false;\n    } // Table with utf8 lengths (calculated by first byte of sequence)\n    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n    // because max possible codepoint is 0x10ffff\n\n\n    var _utf8len = new Uint8Array(256);\n\n    for (var q = 0; q < 256; q++) {\n      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n    }\n\n    _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n    // convert string to array (typed, when possible)\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    function ZStream() {\n      /* next input byte */\n      this.input = null; // JS specific, because we have no pointers\n\n      this.next_in = 0;\n      /* number of bytes available at input */\n\n      this.avail_in = 0;\n      /* total number of input bytes read so far */\n\n      this.total_in = 0;\n      /* next output byte should be put there */\n\n      this.output = null; // JS specific, because we have no pointers\n\n      this.next_out = 0;\n      /* remaining free space at output */\n\n      this.avail_out = 0;\n      /* total number of bytes output so far */\n\n      this.total_out = 0;\n      /* last error message, NULL if no error */\n\n      this.msg = '';\n      /* Z_NULL */\n\n      /* not visible by applications */\n\n      this.state = null;\n      /* best guess about the data type: binary or text */\n\n      this.data_type = 2;\n      /* Z_UNKNOWN */\n\n      /* adler32 value of the uncompressed data */\n\n      this.adler = 0;\n    }\n\n    var zstream = ZStream; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n    var toString = Object.prototype.toString;\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n\n    var Z_NO_FLUSH$1 = constants.Z_NO_FLUSH;\n    var Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH;\n    var Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH;\n    var Z_FINISH$1 = constants.Z_FINISH;\n    var Z_OK$1 = constants.Z_OK;\n    var Z_STREAM_END$1 = constants.Z_STREAM_END;\n    var Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION;\n    var Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY;\n    var Z_DEFLATED$1 = constants.Z_DEFLATED;\n    /* =========================================================================== */\n\n    /**\n     * class Deflate\n     *\n     * Generic JS-style wrapper for zlib calls. If you don't need\n     * streaming behaviour - use more simple functions: [[deflate]],\n     * [[deflateRaw]] and [[gzip]].\n     * */\n\n    /* internal\n     * Deflate.chunks -> Array\n     *\n     * Chunks of output data, if [[Deflate#onData]] not overridden.\n     * */\n\n    /**\n     * Deflate.result -> Uint8Array\n     *\n     * Compressed result, generated by default [[Deflate#onData]]\n     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n     * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n     * */\n\n    /**\n     * Deflate.err -> Number\n     *\n     * Error code after deflate finished. 0 (Z_OK) on success.\n     * You will not need it in real life, because deflate errors\n     * are possible only on wrong options or bad `onData` / `onEnd`\n     * custom handlers.\n     * */\n\n    /**\n     * Deflate.msg -> String\n     *\n     * Error message, if [[Deflate.err]] != 0\n     * */\n\n    /**\n     * new Deflate(options)\n     * - options (Object): zlib deflate options.\n     *\n     * Creates new deflator instance with specified params. Throws exception\n     * on bad params. Supported options:\n     *\n     * - `level`\n     * - `windowBits`\n     * - `memLevel`\n     * - `strategy`\n     * - `dictionary`\n     *\n     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n     * for more information on these.\n     *\n     * Additional options, for internal needs:\n     *\n     * - `chunkSize` - size of generated data chunks (16K by default)\n     * - `raw` (Boolean) - do raw deflate\n     * - `gzip` (Boolean) - create gzip wrapper\n     * - `header` (Object) - custom header for gzip\n     *   - `text` (Boolean) - true if compressed data believed to be text\n     *   - `time` (Number) - modification time, unix timestamp\n     *   - `os` (Number) - operation system code\n     *   - `extra` (Array) - array of bytes with extra data (max 65536)\n     *   - `name` (String) - file name (binary string)\n     *   - `comment` (String) - comment (binary string)\n     *   - `hcrc` (Boolean) - true if header crc should be added\n     *\n     * ##### Example:\n     *\n     * ```javascript\n     * const pako = require('pako')\n     *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n     *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n     *\n     * const deflate = new pako.Deflate({ level: 3});\n     *\n     * deflate.push(chunk1, false);\n     * deflate.push(chunk2, true);  // true -> last chunk\n     *\n     * if (deflate.err) { throw new Error(deflate.err); }\n     *\n     * console.log(deflate.result);\n     * ```\n     * */\n\n    function Deflate(options) {\n      this.options = common.assign({\n        level: Z_DEFAULT_COMPRESSION$1,\n        method: Z_DEFLATED$1,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY$1\n      }, options || {});\n      var opt = this.options;\n\n      if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits;\n      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16;\n      }\n\n      this.err = 0; // error code, if happens (0 = Z_OK)\n\n      this.msg = ''; // error message\n\n      this.ended = false; // used to avoid multiple onEnd() calls\n\n      this.chunks = []; // chunks of compressed data\n\n      this.strm = new zstream();\n      this.strm.avail_out = 0;\n      var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n\n      if (status !== Z_OK$1) {\n        throw new Error(messages[status]);\n      }\n\n      if (opt.header) {\n        deflate_1.deflateSetHeader(this.strm, opt.header);\n      }\n\n      if (opt.dictionary) {\n        var dict; // Convert data if needed\n\n        if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n          dict = new Uint8Array(opt.dictionary);\n        } else {\n          dict = opt.dictionary;\n        }\n\n        status = deflate_1.deflateSetDictionary(this.strm, dict);\n\n        if (status !== Z_OK$1) {\n          throw new Error(messages[status]);\n        }\n\n        this._dict_set = true;\n      }\n    }\n    /**\n     * Deflate#push(data[, flush_mode]) -> Boolean\n     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n     *   converted to utf8 byte sequence.\n     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n     *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n     *\n     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n     * new compressed chunks. Returns `true` on success. The last data block must\n     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n     * buffers and call [[Deflate#onEnd]].\n     *\n     * On fail call [[Deflate#onEnd]] with error code and return false.\n     *\n     * ##### Example\n     *\n     * ```javascript\n     * push(chunk, false); // push one of data chunks\n     * ...\n     * push(chunk, true);  // push last chunk\n     * ```\n     * */\n\n\n    Deflate.prototype.push = function (data, flush_mode) {\n      var strm = this.strm;\n      var chunkSize = this.options.chunkSize;\n      var status;\n\n      var _flush_mode;\n\n      if (this.ended) {\n        return false;\n      }\n\n      if (flush_mode === ~~flush_mode) {\n        _flush_mode = flush_mode;\n      } else {\n        _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;\n      } // Convert data if needed\n\n\n      if (toString.call(data) === '[object ArrayBuffer]') {\n        strm.input = new Uint8Array(data);\n      } else {\n        strm.input = data;\n      }\n\n      strm.next_in = 0;\n      strm.avail_in = strm.input.length;\n\n      for (;;) {\n        if (strm.avail_out === 0) {\n          strm.output = new Uint8Array(chunkSize);\n          strm.next_out = 0;\n          strm.avail_out = chunkSize;\n        } // Make sure avail_out > 6 to avoid repeating markers\n\n\n        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n          strm.avail_out = 0;\n          continue;\n        }\n\n        status = deflate_1.deflate(strm, _flush_mode); // Ended => flush and finish\n\n        if (status === Z_STREAM_END$1) {\n          if (strm.next_out > 0) {\n            this.onData(strm.output.subarray(0, strm.next_out));\n          }\n\n          status = deflate_1.deflateEnd(this.strm);\n          this.onEnd(status);\n          this.ended = true;\n          return status === Z_OK$1;\n        } // Flush if out buffer full\n\n\n        if (strm.avail_out === 0) {\n          this.onData(strm.output);\n          continue;\n        } // Flush if requested and has data\n\n\n        if (_flush_mode > 0 && strm.next_out > 0) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n          strm.avail_out = 0;\n          continue;\n        }\n\n        if (strm.avail_in === 0) {\n          break;\n        }\n      }\n\n      return true;\n    };\n    /**\n     * Deflate#onData(chunk) -> Void\n     * - chunk (Uint8Array): output data.\n     *\n     * By default, stores data blocks in `chunks[]` property and glue\n     * those in `onEnd`. Override this handler, if you need another behaviour.\n     * */\n\n\n    Deflate.prototype.onData = function (chunk) {\n      this.chunks.push(chunk);\n    };\n    /**\n     * Deflate#onEnd(status) -> Void\n     * - status (Number): deflate status. 0 (Z_OK) on success,\n     *   other if not.\n     *\n     * Called once after you tell deflate that the input stream is\n     * complete (Z_FINISH). By default - join collected chunks,\n     * free memory and fill `results` / `err` properties.\n     * */\n\n\n    Deflate.prototype.onEnd = function (status) {\n      // On success - join\n      if (status === Z_OK$1) {\n        this.result = common.flattenChunks(this.chunks);\n      }\n\n      this.chunks = [];\n      this.err = status;\n      this.msg = this.strm.msg;\n    };\n    /**\n     * deflate(data[, options]) -> Uint8Array\n     * - data (Uint8Array|String): input data to compress.\n     * - options (Object): zlib deflate options.\n     *\n     * Compress `data` with deflate algorithm and `options`.\n     *\n     * Supported options are:\n     *\n     * - level\n     * - windowBits\n     * - memLevel\n     * - strategy\n     * - dictionary\n     *\n     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n     * for more information on these.\n     *\n     * Sugar (options):\n     *\n     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n     *   negative windowBits implicitly.\n     *\n     * ##### Example:\n     *\n     * ```javascript\n     * const pako = require('pako')\n     * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n     *\n     * console.log(pako.deflate(data));\n     * ```\n     * */\n\n\n    function deflate$1(input, options) {\n      var deflator = new Deflate(options);\n      deflator.push(input, true); // That will never happens, if you don't cheat with options :)\n\n      if (deflator.err) {\n        throw deflator.msg || messages[deflator.err];\n      }\n\n      return deflator.result;\n    }\n    /**\n     * deflateRaw(data[, options]) -> Uint8Array\n     * - data (Uint8Array|String): input data to compress.\n     * - options (Object): zlib deflate options.\n     *\n     * The same as [[deflate]], but creates raw data, without wrapper\n     * (header and adler32 crc).\n     * */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    function deflateRaw(input, options) {\n      options = options || {};\n      options.raw = true;\n      return deflate$1(input, options);\n    }\n    /**\n     * gzip(data[, options]) -> Uint8Array\n     * - data (Uint8Array|String): input data to compress.\n     * - options (Object): zlib deflate options.\n     *\n     * The same as [[deflate]], but create gzip wrapper instead of\n     * deflate one.\n     * */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    function gzip(input, options) {\n      options = options || {};\n      options.gzip = true;\n      return deflate$1(input, options);\n    }\n\n    return {\n      Deflate: Deflate,\n      constants: constants\n    };\n  }\n}","map":{"version":3,"sources":["../../../src/domain/segmentCollection/deflateWorker.js"],"names":[],"mappings":"AAAA;AACA,IAAI,SAAJ;AAEA,OAAM,SAAU,mBAAV,GAA6B;AACjC;AACA,MAAI,CAAC,SAAL,EAAgB;AACd,IAAA,SAAS,GAAG,GAAG,CAAC,eAAJ,CAAoB,IAAI,IAAJ,CAAS,CAAC,MAAI,YAAJ,GAAgB,SAAjB,CAAT,CAApB,CAAZ;AACD;;AACD,SAAO,IAAI,MAAJ,CAAW,SAAX,CAAP;AACD;;AAED,SAAS,YAAT,GAAqB;AACnB,EAAA,OAAO,CAAC,YAAA;AACA,QAAA,EAAA,GAAyB,eAAe,EAAxC;AAAA,QAAE,OAAO,GAAA,EAAA,CAAA,OAAT;AAAA,QAAW,SAAS,GAAA,EAAA,CAAA,SAApB;;AAEN,QAAI,OAAO,GAAG,IAAI,OAAJ,EAAd;AACA,QAAI,OAAO,GAAG,CAAd;AACA,IAAA,IAAI,CAAC,gBAAL,CACE,SADF,EAEE,OAAO,CAAC,UAAC,KAAD,EAAM;AACZ,UAAM,IAAI,GAAG,KAAK,CAAC,IAAnB;;AACA,cAAQ,IAAI,CAAC,MAAb;AACE,aAAK,OAAL;AACE,cAAM,iBAAiB,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAN,CAAlC;AACA,UAAA,IAAI,CAAC,WAAL,CAAiB;AACf,YAAA,EAAE,EAAE,IAAI,CAAC,EADM;AAEf,YAAA,cAAc,EAAE,OAAO,CAAC,MAAR,CAAe,MAAf,CAAsB,UAAC,KAAD,EAAQ,KAAR,EAAa;AAAK,qBAAA,KAAK,GAAG,KAAK,CAAb,MAAA;AAAoB,aAA5D,EAA8D,CAA9D,CAFD;AAGf,YAAA,iBAAiB,EAAA;AAHF,WAAjB;AAKA;;AACF,aAAK,OAAL;AACE,cAAM,iBAAiB,GAAG,IAAI,CAAC,IAAL,GAAY,QAAQ,CAAC,IAAI,CAAC,IAAN,CAApB,GAAkC,CAA5D;AACA,UAAA,OAAO,CAAC,IAAR,CAAa,EAAb,EAAiB,SAAS,CAAC,QAA3B;AACA,UAAA,IAAI,CAAC,WAAL,CAAiB;AACf,YAAA,EAAE,EAAE,IAAI,CAAC,EADM;AAEf,YAAA,MAAM,EAAE,OAAO,CAAC,MAFD;AAGf,YAAA,iBAAiB,EAAA,iBAHF;AAIf,YAAA,OAAO,EAAA;AAJQ,WAAjB;AAMA,UAAA,OAAO,GAAG,IAAI,OAAJ,EAAV;AACA,UAAA,OAAO,GAAG,CAAV;AACA;AApBJ;AAsBD,KAxBM,CAFT;;AA6BA,aAAS,QAAT,CAAkB,IAAlB,EAAsB;AACpB,UAAM,UAAU,GAAG,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,IAAzB,CAAnB;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,UAAb,EAAyB,SAAS,CAAC,YAAnC;AACA,MAAA,OAAO,IAAI,UAAU,CAAC,MAAtB;AACA,aAAO,UAAU,CAAC,MAAlB;AACD;AACF,GAxCM,CAAP;;AA0CA,WAAS,OAAT,CAAiB,EAAjB,EAAmB;AACjB,WAAO,YAAA;AACL,UAAI;AACF,eAAO,EAAE,CAAC,KAAH,CAAS,IAAT,EAAe,SAAf,CAAP;AACD,OAFD,CAEE,OAAO,CAAP,EAAU;AACV,YAAI;AACF,UAAA,IAAI,CAAC,WAAL,CAAiB;AAAE,YAAA,KAAK,EAAE;AAAT,WAAjB;AACD,SAFD,CAEE,OAAO,CAAP,EAAU;AACV;AACA,UAAA,IAAI,CAAC,WAAL,CAAiB;AAAE,YAAA,KAAK,EAAE,KAAK;AAAd,WAAjB;AACD;AACF;AACF,KAXD;AAYD,GAxDkB,CA0DnB;;;AACA,WAAS,eAAT,GAAwB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA,QAAI,OAAO,GAAG,CAAd,CA5BsB,CA4BN;;AAEhB;;AAEA,QAAI,QAAQ,GAAG,CAAf;AACA,QAAI,MAAM,GAAG,CAAb,CAjCsB,CAiCP;;AAEf,QAAI,SAAS,GAAG,CAAhB;AACA;;AAEA,aAAS,IAAT,CAAc,GAAd,EAAiB;AACf,UAAI,GAAG,GAAG,GAAG,CAAC,MAAd;;AAEA,aAAO,EAAE,GAAF,IAAS,CAAhB,EAAmB;AACjB,QAAA,GAAG,CAAC,GAAD,CAAH,GAAW,CAAX;AACD;AACF,KA5CqB,CA4CpB;;;AAEF,QAAI,YAAY,GAAG,CAAnB;AACA,QAAI,YAAY,GAAG,CAAnB;AACA,QAAI,SAAS,GAAG,CAAhB;AACA;;AAEA,QAAI,SAAS,GAAG,CAAhB;AACA,QAAI,SAAS,GAAG,GAAhB;AACA;AACA;;AAEA;;AAEG;;AAEH,QAAI,YAAY,GAAG,EAAnB;AACA;;AAEA,QAAI,QAAQ,GAAG,GAAf;AACA;;AAEA,QAAI,OAAO,GAAG,QAAQ,GAAG,CAAX,GAAe,YAA7B;AACA;;AAEA,QAAI,OAAO,GAAG,EAAd;AACA;;AAEA,QAAI,QAAQ,GAAG,EAAf;AACA;;AAEA,QAAI,SAAS,GAAG,IAAI,OAAJ,GAAc,CAA9B;AACA;;AAEA,QAAI,QAAQ,GAAG,EAAf;AACA;;AAEA,QAAI,QAAQ,GAAG,EAAf;AACA;;AAEA;;AAEG;;AAEH,QAAI,WAAW,GAAG,CAAlB;AACA;;AAEA,QAAI,SAAS,GAAG,GAAhB;AACA;;AAEA,QAAI,OAAO,GAAG,EAAd;AACA;;AAEA,QAAI,SAAS,GAAG,EAAhB;AACA;;AAEA,QAAI,WAAW,GAAG,EAAlB;AACA;;AAEA;;AAEA,QAAI,WAAW;AACb;AACA,QAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,EAAuD,CAAvD,EAA0D,CAA1D,EAA6D,CAA7D,EAAgE,CAAhE,EAAmE,CAAnE,EAAsE,CAAtE,EAAyE,CAAzE,EAA4E,CAA5E,EAA+E,CAA/E,EAAkF,CAAlF,EAAqF,CAArF,CAAf,CAFF;AAGA,QAAI,WAAW;AACb;AACA,QAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,EAAuD,CAAvD,EAA0D,CAA1D,EAA6D,CAA7D,EAAgE,CAAhE,EAAmE,EAAnE,EAAuE,EAAvE,EAA2E,EAA3E,EAA+E,EAA/E,EAAmF,EAAnF,EAAuF,EAAvF,EAA2F,EAA3F,EAA+F,EAA/F,CAAf,CAFF;AAGA,QAAI,YAAY;AACd;AACA,QAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,EAAuD,CAAvD,CAAf,CAFF;AAGA,QAAI,QAAQ,GAAG,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,EAA5B,EAAgC,CAAhC,EAAmC,EAAnC,EAAuC,CAAvC,EAA0C,EAA1C,EAA8C,CAA9C,EAAiD,EAAjD,EAAqD,CAArD,EAAwD,EAAxD,EAA4D,CAA5D,EAA+D,EAA/D,CAAf,CAAf;AACA;;AAEA;;AAEG;;AAEH;;AAEG;AACH;;AAEA,QAAI,aAAa,GAAG,GAApB;AACA;AACA;;AAEA,QAAI,YAAY,GAAG,IAAI,KAAJ,CAAU,CAAC,OAAO,GAAG,CAAX,IAAgB,CAA1B,CAAnB;AACA,IAAA,IAAI,CAAC,YAAD,CAAJ;AACA;;;;AAIG;;AAEH,QAAI,YAAY,GAAG,IAAI,KAAJ,CAAU,OAAO,GAAG,CAApB,CAAnB;AACA,IAAA,IAAI,CAAC,YAAD,CAAJ;AACA;;AAEG;;AAEH,QAAI,UAAU,GAAG,IAAI,KAAJ,CAAU,aAAV,CAAjB;;AAEA,IAAA,IAAI,CAAC,UAAD,CAAJ;AACA;;;AAGG;;AAEH,QAAI,YAAY,GAAG,IAAI,KAAJ,CAAU,SAAS,GAAG,SAAZ,GAAwB,CAAlC,CAAnB;;AAEA,IAAA,IAAI,CAAC,YAAD,CAAJ;AACA;;AAEA,QAAI,WAAW,GAAG,IAAI,KAAJ,CAAU,YAAV,CAAlB;AACA,IAAA,IAAI,CAAC,WAAD,CAAJ;AACA;;AAEA,QAAI,SAAS,GAAG,IAAI,KAAJ,CAAU,OAAV,CAAhB;AACA,IAAA,IAAI,CAAC,SAAD,CAAJ;AACA;;AAEA,aAAS,cAAT,CAAwB,WAAxB,EAAqC,UAArC,EAAiD,UAAjD,EAA6D,KAA7D,EAAoE,UAApE,EAA8E;AAC5E,WAAK,WAAL,GAAmB,WAAnB;AACA;;AAEA,WAAK,UAAL,GAAkB,UAAlB;AACA;;AAEA,WAAK,UAAL,GAAkB,UAAlB;AACA;;AAEA,WAAK,KAAL,GAAa,KAAb;AACA;;AAEA,WAAK,UAAL,GAAkB,UAAlB;AACA;AACA;;AAEA,WAAK,SAAL,GAAiB,WAAW,IAAI,WAAW,CAAC,MAA5C;AACD;;AAED,QAAI,aAAJ;AACA,QAAI,aAAJ;AACA,QAAI,cAAJ;;AAEA,aAAS,QAAT,CAAkB,QAAlB,EAA4B,SAA5B,EAAqC;AACnC,WAAK,QAAL,GAAgB,QAAhB;AACA;;AAEA,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA,WAAK,SAAL,GAAiB,SAAjB;AACA;AACD;;AAED,QAAI,MAAM,GAAG,SAAS,MAAT,CAAgB,IAAhB,EAAoB;AAC/B,aAAO,IAAI,GAAG,GAAP,GAAa,UAAU,CAAC,IAAD,CAAvB,GAAgC,UAAU,CAAC,OAAO,IAAI,KAAK,CAAhB,CAAD,CAAjD;AACD,KAFD;AAGA;;;AAGG;;;AAEH,QAAI,SAAS,GAAG,SAAS,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,EAAuB;AACrC;AACA;AACA,MAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,OAAF,EAAd,IAA6B,CAAC,GAAG,IAAjC;AACA,MAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,OAAF,EAAd,IAA8B,CAAC,KAAK,CAAP,GAAY,IAAzC;AACD,KALD;AAMA;;;AAGG;;;AAEH,QAAI,SAAS,GAAG,SAAS,SAAT,CAAmB,CAAnB,EAAsB,KAAtB,EAA6B,MAA7B,EAAmC;AACjD,UAAI,CAAC,CAAC,QAAF,GAAa,QAAQ,GAAG,MAA5B,EAAoC;AAClC,QAAA,CAAC,CAAC,MAAF,IAAa,KAAK,IAAI,CAAC,CAAC,QAAZ,GAAwB,MAApC;AACA,QAAA,SAAS,CAAC,CAAD,EAAI,CAAC,CAAC,MAAN,CAAT;AACA,QAAA,CAAC,CAAC,MAAF,GAAW,KAAK,IAAK,QAAQ,GAAG,CAAC,CAAC,QAAlC;AACA,QAAA,CAAC,CAAC,QAAF,IAAc,MAAM,GAAG,QAAvB;AACD,OALD,MAKO;AACL,QAAA,CAAC,CAAC,MAAF,IAAa,KAAK,IAAI,CAAC,CAAC,QAAZ,GAAwB,MAApC;AACA,QAAA,CAAC,CAAC,QAAF,IAAc,MAAd;AACD;AACF,KAVD;;AAYA,QAAI,SAAS,GAAG,SAAS,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,IAAzB,EAA6B;AAC3C,MAAA,SAAS,CACP,CADO,EAEP,IAAI,CAAC,CAAC,GAAG,CAAL,CAFG;AAGP;AACA,MAAA,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT;AACJ;AALO,OAAT;AAOD,KARD;AASA;;;;AAIG;;;AAEH,QAAI,UAAU,GAAG,SAAS,UAAT,CAAoB,IAApB,EAA0B,GAA1B,EAA6B;AAC5C,UAAI,GAAG,GAAG,CAAV;;AAEA,SAAG;AACD,QAAA,GAAG,IAAI,IAAI,GAAG,CAAd;AACA,QAAA,IAAI,MAAM,CAAV;AACA,QAAA,GAAG,KAAK,CAAR;AACD,OAJD,QAIS,EAAE,GAAF,GAAQ,CAJjB;;AAMA,aAAO,GAAG,KAAK,CAAf;AACD,KAVD;AAWA;;AAEG;;;AAEH,QAAI,QAAQ,GAAG,SAAS,QAAT,CAAkB,CAAlB,EAAmB;AAChC,UAAI,CAAC,CAAC,QAAF,KAAe,EAAnB,EAAuB;AACrB,QAAA,SAAS,CAAC,CAAD,EAAI,CAAC,CAAC,MAAN,CAAT;AACA,QAAA,CAAC,CAAC,MAAF,GAAW,CAAX;AACA,QAAA,CAAC,CAAC,QAAF,GAAa,CAAb;AACD,OAJD,MAIO,IAAI,CAAC,CAAC,QAAF,IAAc,CAAlB,EAAqB;AAC1B,QAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,OAAF,EAAd,IAA6B,CAAC,CAAC,MAAF,GAAW,IAAxC;AACA,QAAA,CAAC,CAAC,MAAF,KAAa,CAAb;AACA,QAAA,CAAC,CAAC,QAAF,IAAc,CAAd;AACD;AACF,KAVD;AAWA;;;;;;;;;AASG;;;AAEH,QAAI,UAAU,GAAG,SAAS,UAAT,CACf,CADe,EAEf,IAFe,CAEV;AAFU,M;AAIf,UAAI,IAAI,GAAG,IAAI,CAAC,QAAhB;AACA,UAAI,QAAQ,GAAG,IAAI,CAAC,QAApB;AACA,UAAI,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,WAA3B;AACA,UAAI,SAAS,GAAG,IAAI,CAAC,SAAL,CAAe,SAA/B;AACA,UAAI,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,UAA3B;AACA,UAAI,IAAI,GAAG,IAAI,CAAC,SAAL,CAAe,UAA1B;AACA,UAAI,UAAU,GAAG,IAAI,CAAC,SAAL,CAAe,UAAhC;AACA,UAAI,CAAJ;AACA;;AAEA,UAAI,CAAJ;AACA,UAAI,CAAJ;AACA;;AAEA,UAAI,IAAJ;AACA;;AAEA,UAAI,KAAJ;AACA;;AAEA,UAAI,CAAJ;AACA;;AAEA,UAAI,QAAQ,GAAG,CAAf;AACA;;AAEA,WAAK,IAAI,GAAG,CAAZ,EAAe,IAAI,IAAI,QAAvB,EAAiC,IAAI,EAArC,EAAyC;AACvC,QAAA,CAAC,CAAC,QAAF,CAAW,IAAX,IAAmB,CAAnB;AACD;AACD;;AAEG;;;AAEH,MAAA,IAAI,CAAC,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,QAAT,IAAqB,CAArB,GAAyB,CAA1B,CAAJ;AACE;AACA,OAFF;AAGA;;AAEA,WAAK,CAAC,GAAG,CAAC,CAAC,QAAF,GAAa,CAAtB,EAAyB,CAAC,GAAG,SAA7B,EAAwC,CAAC,EAAzC,EAA6C;AAC3C,QAAA,CAAC,GAAG,CAAC,CAAC,IAAF,CAAO,CAAP,CAAJ;AACA,QAAA,IAAI,GACF,IAAI,CACF,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAJ;AACE;AACA,SAFF,GAGE,CAJA,CAAJ;AAMA;AACA,SARF;;AAUA,YAAI,IAAI,GAAG,UAAX,EAAuB;AACrB,UAAA,IAAI,GAAG,UAAP;AACA,UAAA,QAAQ;AACT;;AAED,QAAA,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAJ;AACE;AACA,QAAA,IAFF;AAGA;;AAEA,YAAI,CAAC,GAAG,QAAR,EAAkB;AAChB;AACD;AACD;;;AAEA,QAAA,CAAC,CAAC,QAAF,CAAW,IAAX;AACA,QAAA,KAAK,GAAG,CAAR;;AAEA,YAAI,CAAC,IAAI,IAAT,EAAe;AACb,UAAA,KAAK,GAAG,KAAK,CAAC,CAAC,GAAG,IAAL,CAAb;AACD;;AAED,QAAA,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAL,CAAR;AACA;;AACA,QAAA,CAAC,CAAC,OAAF,IAAa,CAAC,IAAI,IAAI,GAAG,KAAX,CAAd;;AAEA,YAAI,SAAJ,EAAe;AACb,UAAA,CAAC,CAAC,UAAF,IACE,CAAC,IACA,KAAK,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAL;AACC;AACA,UAAA,KAHD,CADH;AAKD;AACF;;AAED,UAAI,QAAQ,KAAK,CAAjB,EAAoB;AAClB;AACD,O,CAAC;;AAEF;;AAEA;;;AAEA,SAAG;AACD,QAAA,IAAI,GAAG,UAAU,GAAG,CAApB;;AAEA,eAAO,CAAC,CAAC,QAAF,CAAW,IAAX,MAAqB,CAA5B,EAA+B;AAC7B,UAAA,IAAI;AACL;;AAED,QAAA,CAAC,CAAC,QAAF,CAAW,IAAX;AACA;;AAEA,QAAA,CAAC,CAAC,QAAF,CAAW,IAAI,GAAG,CAAlB,KAAwB,CAAxB;AACA;;AAEA,QAAA,CAAC,CAAC,QAAF,CAAW,UAAX;AACA;;AAEG;;AAEH,QAAA,QAAQ,IAAI,CAAZ;AACD,OAnBD,QAmBS,QAAQ,GAAG,CAnBpB;AAoBA;;;;AAIG;;;AAEH,WAAK,IAAI,GAAG,UAAZ,EAAwB,IAAI,KAAK,CAAjC,EAAoC,IAAI,EAAxC,EAA4C;AAC1C,QAAA,CAAC,GAAG,CAAC,CAAC,QAAF,CAAW,IAAX,CAAJ;;AAEA,eAAO,CAAC,KAAK,CAAb,EAAgB;AACd,UAAA,CAAC,GAAG,CAAC,CAAC,IAAF,CAAO,EAAE,CAAT,CAAJ;;AAEA,cAAI,CAAC,GAAG,QAAR,EAAkB;AAChB;AACD;;AAED,cACE,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAJ;AACA;AACA,UAAA,IAHF,EAIE;AACA;AACA,YAAA,CAAC,CAAC,OAAF,IACE,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAZ;AACA;AACA,YAAA,IAAI,CAAC,CAAC,GAAG,CAAL,CAHN;AAIA;;AACA,YAAA,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAJ;AACE;AACA,YAAA,IAFF;AAGD;;AAED,UAAA,CAAC;AACF;AACF;AACF,KAxJD;AAyJA;;;;;;;AAOG;;;AAEH,QAAI,SAAS,GAAG,SAAS,SAAT,CACd,IADc,EAEd,QAFc,EAGd,QAHc,CAGL;AAHK,M;AAKd,UAAI,SAAS,GAAG,IAAI,KAAJ,CAAU,QAAQ,GAAG,CAArB,CAAhB;AACA;;AAEA,UAAI,IAAI,GAAG,CAAX;AACA;;AAEA,UAAI,IAAJ;AACA;;AAEA,UAAI,CAAJ;AACA;;AAEA;;AAEG;;AAEH,WAAK,IAAI,GAAG,CAAZ,EAAe,IAAI,IAAI,QAAvB,EAAiC,IAAI,EAArC,EAAyC;AACvC,QAAA,SAAS,CAAC,IAAD,CAAT,GAAkB,IAAI,GAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,GAAG,CAAR,CAAhB,IAA+B,CAAxD;AACD;AACD;;AAEG;AACH;AACA;AACA;;;AAEA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,IAAI,QAAjB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,YAAI,GAAG,GAAG,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAd;AACA;;AACA,YAAI,GAAG,KAAK,CAAZ,EAAe;AACb;AACD;AACD;;;AAEA,QAAA,IAAI,CAAC,CAAC,GAAG,CAAL,CAAJ;AACE;AACA,QAAA,UAAU,CAAC,SAAS,CAAC,GAAD,CAAT,EAAD,EAAmB,GAAnB,CAFZ,CAR8B,CAUM;AACpC;AACD;AACF,KA5CD;AA6CA;;AAEG;;;AAEH,QAAI,cAAc,GAAG,SAAS,cAAT,GAAuB;AAC1C,UAAI,CAAJ;AACA;;AAEA,UAAI,IAAJ;AACA;;AAEA,UAAI,MAAJ;AACA;;AAEA,UAAI,IAAJ;AACA;;AAEA,UAAI,IAAJ;AACA;;AAEA,UAAI,QAAQ,GAAG,IAAI,KAAJ,CAAU,QAAQ,GAAG,CAArB,CAAf;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;AAMO;;AAEP;;AAEA,MAAA,MAAM,GAAG,CAAT;;AAEA,WAAK,IAAI,GAAG,CAAZ,EAAe,IAAI,GAAG,YAAY,GAAG,CAArC,EAAwC,IAAI,EAA5C,EAAgD;AAC9C,QAAA,WAAW,CAAC,IAAD,CAAX,GAAoB,MAApB;;AAEA,aAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,KAAK,WAAW,CAAC,IAAD,CAAhC,EAAwC,CAAC,EAAzC,EAA6C;AAC3C,UAAA,YAAY,CAAC,MAAM,EAAP,CAAZ,GAAyB,IAAzB;AACD;AACF,OAzCyC,CAyCxC;;AAEF;;;AAGG;;;AAEH,MAAA,YAAY,CAAC,MAAM,GAAG,CAAV,CAAZ,GAA2B,IAA3B;AACA;;AAEA,MAAA,IAAI,GAAG,CAAP;;AAEA,WAAK,IAAI,GAAG,CAAZ,EAAe,IAAI,GAAG,EAAtB,EAA0B,IAAI,EAA9B,EAAkC;AAChC,QAAA,SAAS,CAAC,IAAD,CAAT,GAAkB,IAAlB;;AAEA,aAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,KAAK,WAAW,CAAC,IAAD,CAAhC,EAAwC,CAAC,EAAzC,EAA6C;AAC3C,UAAA,UAAU,CAAC,IAAI,EAAL,CAAV,GAAqB,IAArB;AACD;AACF,OA3DyC,CA2DxC;;;AAEF,MAAA,IAAI,KAAK,CAAT;AACA;;AAEA,aAAO,IAAI,GAAG,OAAd,EAAuB,IAAI,EAA3B,EAA+B;AAC7B,QAAA,SAAS,CAAC,IAAD,CAAT,GAAkB,IAAI,IAAI,CAA1B;;AAEA,aAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,KAAM,WAAW,CAAC,IAAD,CAAX,GAAoB,CAA1C,EAA8C,CAAC,EAA/C,EAAmD;AACjD,UAAA,UAAU,CAAC,MAAM,IAAI,EAAX,CAAV,GAA2B,IAA3B;AACD;AACF,OAtEyC,CAsExC;;AAEF;;;AAEA,WAAK,IAAI,GAAG,CAAZ,EAAe,IAAI,IAAI,QAAvB,EAAiC,IAAI,EAArC,EAAyC;AACvC,QAAA,QAAQ,CAAC,IAAD,CAAR,GAAiB,CAAjB;AACD;;AAED,MAAA,CAAC,GAAG,CAAJ;;AAEA,aAAO,CAAC,IAAI,GAAZ,EAAiB;AACf,QAAA,YAAY,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAZ;AACE;AACA,SAFF;AAGA,QAAA,CAAC;AACD,QAAA,QAAQ,CAAC,CAAD,CAAR;AACD;;AAED,aAAO,CAAC,IAAI,GAAZ,EAAiB;AACf,QAAA,YAAY,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAZ;AACE;AACA,SAFF;AAGA,QAAA,CAAC;AACD,QAAA,QAAQ,CAAC,CAAD,CAAR;AACD;;AAED,aAAO,CAAC,IAAI,GAAZ,EAAiB;AACf,QAAA,YAAY,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAZ;AACE;AACA,SAFF;AAGA,QAAA,CAAC;AACD,QAAA,QAAQ,CAAC,CAAD,CAAR;AACD;;AAED,aAAO,CAAC,IAAI,GAAZ,EAAiB;AACf,QAAA,YAAY,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAZ;AACE;AACA,SAFF;AAGA,QAAA,CAAC;AACD,QAAA,QAAQ,CAAC,CAAD,CAAR;AACD;AACD;;;AAGG;;;AAEH,MAAA,SAAS,CAAC,YAAD,EAAe,OAAO,GAAG,CAAzB,EAA4B,QAA5B,CAAT;AACA;;AAEA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,OAAhB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,QAAA,YAAY,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAZ;AACE;AACA,SAFF;AAGA,QAAA,YAAY,CAAC,CAAC,GAAG,CAAL,CAAZ;AACE;AACA,QAAA,UAAU,CAAC,CAAD,EAAI,CAAJ,CAFZ;AAGD,OA9HyC,CA8HxC;;;AAEF,MAAA,aAAa,GAAG,IAAI,cAAJ,CAAmB,YAAnB,EAAiC,WAAjC,EAA8C,QAAQ,GAAG,CAAzD,EAA4D,OAA5D,EAAqE,QAArE,CAAhB;AACA,MAAA,aAAa,GAAG,IAAI,cAAJ,CAAmB,YAAnB,EAAiC,WAAjC,EAA8C,CAA9C,EAAiD,OAAjD,EAA0D,QAA1D,CAAhB;AACA,MAAA,cAAc,GAAG,IAAI,cAAJ,CAAmB,IAAI,KAAJ,CAAU,CAAV,CAAnB,EAAiC,YAAjC,EAA+C,CAA/C,EAAkD,QAAlD,EAA4D,WAA5D,CAAjB,CAlI0C,CAkIgD;AAC3F,KAnID;AAoIA;;AAEG;;;AAEH,QAAI,UAAU,GAAG,SAAS,UAAT,CAAoB,CAApB,EAAqB;AACpC,UAAI,CAAJ;AACA;;AAEA;;AAEA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,OAAhB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,QAAA,CAAC,CAAC,SAAF,CAAY,CAAC,GAAG,CAAhB;AACE;AACA,SAFF;AAGD;;AAED,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,OAAhB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,QAAA,CAAC,CAAC,SAAF,CAAY,CAAC,GAAG,CAAhB;AACE;AACA,SAFF;AAGD;;AAED,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,QAAhB,EAA0B,CAAC,EAA3B,EAA+B;AAC7B,QAAA,CAAC,CAAC,OAAF,CAAU,CAAC,GAAG,CAAd;AACE;AACA,SAFF;AAGD;;AAED,MAAA,CAAC,CAAC,SAAF,CAAY,SAAS,GAAG,CAAxB;AACE;AACA,OAFF;AAGA,MAAA,CAAC,CAAC,OAAF,GAAY,CAAC,CAAC,UAAF,GAAe,CAA3B;AACA,MAAA,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,OAAF,GAAY,CAAzB;AACD,KA7BD;AA8BA;;AAEG;;;AAEH,QAAI,SAAS,GAAG,SAAS,SAAT,CAAmB,CAAnB,EAAoB;AAClC,UAAI,CAAC,CAAC,QAAF,GAAa,CAAjB,EAAoB;AAClB,QAAA,SAAS,CAAC,CAAD,EAAI,CAAC,CAAC,MAAN,CAAT;AACD,OAFD,MAEO,IAAI,CAAC,CAAC,QAAF,GAAa,CAAjB,EAAoB;AACzB;AACA,QAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,OAAF,EAAd,IAA6B,CAAC,CAAC,MAA/B;AACD;;AAED,MAAA,CAAC,CAAC,MAAF,GAAW,CAAX;AACA,MAAA,CAAC,CAAC,QAAF,GAAa,CAAb;AACD,KAVD;AAWA;;;AAGG;;;AAEH,QAAI,UAAU,GAAG,SAAS,UAAT,CACf,CADe,EAEf,GAFe,EAGf,GAHe,EAIf,MAJe,CAIR;AAJQ,M;AAMf,MAAA,SAAS,CAAC,CAAD,CAAT;AACA;;AAEA,UAAI,MAAJ,EAAY;AACV,QAAA,SAAS,CAAC,CAAD,EAAI,GAAJ,CAAT;AACA,QAAA,SAAS,CAAC,CAAD,EAAI,CAAC,GAAL,CAAT;AACD,O,CAAC;AACF;AACA;;;AAEA,MAAA,CAAC,CAAC,WAAF,CAAc,GAAd,CAAkB,CAAC,CAAC,MAAF,CAAS,QAAT,CAAkB,GAAlB,EAAuB,GAAG,GAAG,GAA7B,CAAlB,EAAqD,CAAC,CAAC,OAAvD;AACA,MAAA,CAAC,CAAC,OAAF,IAAa,GAAb;AACD,KAlBD;AAmBA;;;AAGG;;;AAEH,QAAI,OAAO,GAAG,SAAS,OAAT,CAAiB,IAAjB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,KAA7B,EAAkC;AAC9C,UAAI,GAAG,GAAG,CAAC,GAAG,CAAd;;AAEA,UAAI,GAAG,GAAG,CAAC,GAAG,CAAd;;AAEA,aACE,IAAI,CAAC,GAAD,CAAJ;AACE;AACA,MAAA,IAAI,CAAC,GAAD,CAFN;AAGA;AACC,MAAA,IAAI,CAAC,GAAD,CAAJ;AACC;AACA,MAAA,IAAI,CAAC,GAAD,CAFL;AAGC;AACA,MAAA,KAAK,CAAC,CAAD,CAAL,IAAY,KAAK,CAAC,CAAD,CATrB;AAWD,KAhBD;AAiBA;;;;;AAKG;;;AAEH,QAAI,UAAU,GAAG,SAAS,UAAT,CACf,CADe,EAEf,IAFe,EAGf,CAHe,CAGb;AAHa,M;AAKf,UAAI,CAAC,GAAG,CAAC,CAAC,IAAF,CAAO,CAAP,CAAR;AACA,UAAI,CAAC,GAAG,CAAC,IAAI,CAAb;AACA;;AAEA,aAAO,CAAC,IAAI,CAAC,CAAC,QAAd,EAAwB;AACtB;AACA,YAAI,CAAC,GAAG,CAAC,CAAC,QAAN,IAAkB,OAAO,CAAC,IAAD,EAAO,CAAC,CAAC,IAAF,CAAO,CAAC,GAAG,CAAX,CAAP,EAAsB,CAAC,CAAC,IAAF,CAAO,CAAP,CAAtB,EAAiC,CAAC,CAAC,KAAnC,CAA7B,EAAwE;AACtE,UAAA,CAAC;AACF;AACD;;;AAEA,YAAI,OAAO,CAAC,IAAD,EAAO,CAAP,EAAU,CAAC,CAAC,IAAF,CAAO,CAAP,CAAV,EAAqB,CAAC,CAAC,KAAvB,CAAX,EAA0C;AACxC;AACD;AACD;;;AAEA,QAAA,CAAC,CAAC,IAAF,CAAO,CAAP,IAAY,CAAC,CAAC,IAAF,CAAO,CAAP,CAAZ;AACA,QAAA,CAAC,GAAG,CAAJ;AACA;;AAEA,QAAA,CAAC,KAAK,CAAN;AACD;;AAED,MAAA,CAAC,CAAC,IAAF,CAAO,CAAP,IAAY,CAAZ;AACD,KA7BD,CAxtBsB,CAqvBpB;AACF;;AAEA;;AAEG;;;AAEH,QAAI,cAAc,GAAG,SAAS,cAAT,CACnB,CADmB,EAEnB,KAFmB,EAGnB,KAHmB,CAGb;AAHa,M;AAKnB,UAAI,IAAJ;AACA;;AAEA,UAAI,EAAJ;AACA;;AAEA,UAAI,EAAE,GAAG,CAAT;AACA;;AAEA,UAAI,IAAJ;AACA;;AAEA,UAAI,KAAJ;AACA;;AAEA,UAAI,CAAC,CAAC,QAAF,KAAe,CAAnB,EAAsB;AACpB,WAAG;AACD,UAAA,IAAI,GAAI,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,KAAF,GAAU,EAAE,GAAG,CAA7B,KAAmC,CAApC,GAAyC,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,KAAF,GAAU,EAAE,GAAG,CAAf,GAAmB,CAAjC,CAAhD;AACA,UAAA,EAAE,GAAG,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,KAAF,GAAU,EAAxB,CAAL;AACA,UAAA,EAAE;;AAEF,cAAI,IAAI,KAAK,CAAb,EAAgB;AACd,YAAA,SAAS,CAAC,CAAD,EAAI,EAAJ,EAAQ,KAAR,CAAT;AACA;AACA;AACD,WAJD,MAIO;AACL;AACA,YAAA,IAAI,GAAG,YAAY,CAAC,EAAD,CAAnB;AACA,YAAA,SAAS,CAAC,CAAD,EAAI,IAAI,GAAG,QAAP,GAAkB,CAAtB,EAAyB,KAAzB,CAAT;AACA;;AAEA,YAAA,KAAK,GAAG,WAAW,CAAC,IAAD,CAAnB;;AAEA,gBAAI,KAAK,KAAK,CAAd,EAAiB;AACf,cAAA,EAAE,IAAI,WAAW,CAAC,IAAD,CAAjB;AACA,cAAA,SAAS,CAAC,CAAD,EAAI,EAAJ,EAAQ,KAAR,CAAT;AACA;AACD;;AAED,YAAA,IAAI;AACJ;;AAEA,YAAA,IAAI,GAAG,MAAM,CAAC,IAAD,CAAb,CAjBK,CAiBe;;AAEpB,YAAA,SAAS,CAAC,CAAD,EAAI,IAAJ,EAAU,KAAV,CAAT;AACA;;AAEA,YAAA,KAAK,GAAG,WAAW,CAAC,IAAD,CAAnB;;AAEA,gBAAI,KAAK,KAAK,CAAd,EAAiB;AACf,cAAA,IAAI,IAAI,SAAS,CAAC,IAAD,CAAjB;AACA,cAAA,SAAS,CAAC,CAAD,EAAI,IAAJ,EAAU,KAAV,CAAT;AACA;AACD;AACF;AACD;;AAEA;AACA;AACA;;AACD,SA5CD,QA4CS,EAAE,GAAG,CAAC,CAAC,QA5ChB;AA6CD;;AAED,MAAA,SAAS,CAAC,CAAD,EAAI,SAAJ,EAAe,KAAf,CAAT;AACD,KArED;AAsEA;;;;;;;AAOG;;;AAEH,QAAI,UAAU,GAAG,SAAS,UAAT,CACf,CADe,EAEf,IAFe,CAEV;AAFU,M;AAIf,UAAI,IAAI,GAAG,IAAI,CAAC,QAAhB;AACA,UAAI,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,WAA3B;AACA,UAAI,SAAS,GAAG,IAAI,CAAC,SAAL,CAAe,SAA/B;AACA,UAAI,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,KAA3B;AACA,UAAI,CAAJ;AACA,UAAI,CAAJ;AACA;;AAEA,UAAI,QAAQ,GAAG,CAAC,CAAhB;AACA;;AAEA,UAAI,IAAJ;AACA;;AAEA;;;AAGG;;AAEH,MAAA,CAAC,CAAC,QAAF,GAAa,CAAb;AACA,MAAA,CAAC,CAAC,QAAF,GAAa,SAAb;;AAEA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,KAAhB,EAAuB,CAAC,EAAxB,EAA4B;AAC1B,YACE,IAAI,CAAC,CAAC,GAAG,CAAL,CAAJ;AACA;AACA,SAHF,EAIE;AACA,UAAA,CAAC,CAAC,IAAF,CAAO,EAAE,CAAC,CAAC,QAAX,IAAuB,QAAQ,GAAG,CAAlC;AACA,UAAA,CAAC,CAAC,KAAF,CAAQ,CAAR,IAAa,CAAb;AACD,SAPD,MAOO;AACL,UAAA,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAJ;AACE;AACA,WAFF;AAGD;AACF;AACD;;;;AAIG;;;AAEH,aAAO,CAAC,CAAC,QAAF,GAAa,CAApB,EAAuB;AACrB,QAAA,IAAI,GAAG,CAAC,CAAC,IAAF,CAAO,EAAE,CAAC,CAAC,QAAX,IAAuB,QAAQ,GAAG,CAAX,GAAe,EAAE,QAAjB,GAA4B,CAA1D;AACA,QAAA,IAAI,CAAC,IAAI,GAAG,CAAR,CAAJ;AACE;AACA,SAFF;AAGA,QAAA,CAAC,CAAC,KAAF,CAAQ,IAAR,IAAgB,CAAhB;AACA,QAAA,CAAC,CAAC,OAAF;;AAEA,YAAI,SAAJ,EAAe;AACb,UAAA,CAAC,CAAC,UAAF,IAAgB,KAAK,CAAC,IAAI,GAAG,CAAP,GAAW,CAAZ,CAArB;AACA;AACD;AACD;;AACD;;AAED,MAAA,IAAI,CAAC,QAAL,GAAgB,QAAhB;AACA;;AAEG;;AAEH,WACE,CAAC,GAAG,CAAC,CAAC,QAAF,IAAc,CADpB;AAEE;AACA,MAAA,CAAC,IAAI,CAHP,EAIE,CAAC,EAJH,EAKE;AACA,QAAA,UAAU,CAAC,CAAD,EAAI,IAAJ,EAAU,CAAV,CAAV;AACD;AACD;;AAEG;;;AAEH,MAAA,IAAI,GAAG,KAAP;AACA;;AAEA,SAAG;AACD;;AAEA;AACA,QAAA,CAAC,GAAG,CAAC,CAAC,IAAF,CAAO,CAAP,CAAJ;AACA;;AACA,QAAA,CAAC,CAAC,IAAF,CAAO,CAAP,IAAY,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,QAAF,EAAP,CAAZ;AACA;;AACA,QAAA,UAAU,CACR,CADQ,EAER,IAFQ,EAGR;AACA;AAJQ,SAAV;AAMA;;AAEA,QAAA,CAAC,GAAG,CAAC,CAAC,IAAF,CAAO,CAAP,CAAJ;AACA;;AACA;;AAEA,QAAA,CAAC,CAAC,IAAF,CAAO,EAAE,CAAC,CAAC,QAAX,IAAuB,CAAvB;AACA;;AAEA,QAAA,CAAC,CAAC,IAAF,CAAO,EAAE,CAAC,CAAC,QAAX,IAAuB,CAAvB;AACA;;AAEA,QAAA,IAAI,CAAC,IAAI,GAAG,CAAR,CAAJ;AACE;AACA,QAAA,IAAI,CAAC,CAAC,GAAG,CAAL,CAAJ;AACA;AACA,QAAA,IAAI,CAAC,CAAC,GAAG,CAAL,CAJN;AAKA;;AACA,QAAA,CAAC,CAAC,KAAF,CAAQ,IAAR,IAAgB,CAAC,CAAC,CAAC,KAAF,CAAQ,CAAR,KAAc,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAd,GAA2B,CAAC,CAAC,KAAF,CAAQ,CAAR,CAA3B,GAAwC,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAzC,IAAuD,CAAvE;AACA,QAAA,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAJ;AACE;AACA,QAAA,IAAI,CAAC,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAJ;AACE;AACA,QAAA,IAJJ;AAKA;;AAEA,QAAA,CAAC,CAAC,IAAF,CAAO,CAAP,IAAY,IAAI,EAAhB;AACA;;AACA,QAAA,UAAU,CACR,CADQ,EAER,IAFQ,EAGR;AACA;AAJQ,SAAV;AAMD,OAhDD,QAgDS,CAAC,CAAC,QAAF,IAAc,CAhDvB;;AAkDA,MAAA,CAAC,CAAC,IAAF,CAAO,EAAE,CAAC,CAAC,QAAX,IAAuB,CAAC,CAAC,IAAF,CAAO,CAAP,CAAvB;AACA;;AACA;;AAEG;;AAEH,MAAA,UAAU,CAAC,CAAD,EAAI,IAAJ,CAAV;AACA;;AAEA,MAAA,SAAS,CAAC,IAAD,EAAO,QAAP,EAAiB,CAAC,CAAC,QAAnB,CAAT;AACD,KA7ID;AA8IA;;;AAGG;;;AAEH,QAAI,SAAS,GAAG,SAAS,SAAT,CACd,CADc,EAEd,IAFc,EAGd,QAHc,CAGL;AAHK,M;AAKd,UAAI,CAAJ;AACA;;AAEA,UAAI,OAAO,GAAG,CAAC,CAAf;AACA;;AAEA,UAAI,MAAJ;AACA;;AAEA,UAAI,OAAO,GAAG,IAAI,CAAC,IAAI,CAAJ,GAAQ,CAAT,CAAlB;AACA;;AACA;;AAEA,UAAI,KAAK,GAAG,CAAZ;AACA;;AAEA,UAAI,SAAS,GAAG,CAAhB;AACA;;AAEA,UAAI,SAAS,GAAG,CAAhB;AACA;;AAEA,UAAI,OAAO,KAAK,CAAhB,EAAmB;AACjB,QAAA,SAAS,GAAG,GAAZ;AACA,QAAA,SAAS,GAAG,CAAZ;AACD;;AAED,MAAA,IAAI,CAAC,CAAC,QAAQ,GAAG,CAAZ,IAAiB,CAAjB,GAAqB,CAAtB,CAAJ;AACE;AACA,YAFF;AAGA;;AAEA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,IAAI,QAAjB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,QAAA,MAAM,GAAG,OAAT;AACA,QAAA,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAL,IAAU,CAAV,GAAc,CAAf,CAAd;AACA;;AAEA,YAAI,EAAE,KAAF,GAAU,SAAV,IAAuB,MAAM,KAAK,OAAtC,EAA+C;AAC7C;AACD,SAFD,MAEO,IAAI,KAAK,GAAG,SAAZ,EAAuB;AAC5B,UAAA,CAAC,CAAC,OAAF,CAAU,MAAM,GAAG,CAAnB;AACE;AACA,UAAA,KAFF;AAGD,SAJM,MAIA,IAAI,MAAM,KAAK,CAAf,EAAkB;AACvB,cAAI,MAAM,KAAK,OAAf,EAAwB;AACtB,YAAA,CAAC,CAAC,OAAF,CAAU,MAAM,GAAG,CAAnB,EAAsB,WAAtB;AACD;;AAED,UAAA,CAAC,CAAC,OAAF,CAAU,OAAO,GAAG,CAApB,EAAuB,WAAvB;AACD,SANM,MAMA,IAAI,KAAK,IAAI,EAAb,EAAiB;AACtB,UAAA,CAAC,CAAC,OAAF,CAAU,SAAS,GAAG,CAAtB,EAAyB,WAAzB;AACD,SAFM,MAEA;AACL,UAAA,CAAC,CAAC,OAAF,CAAU,WAAW,GAAG,CAAxB,EAA2B,WAA3B;AACD;;AAED,QAAA,KAAK,GAAG,CAAR;AACA,QAAA,OAAO,GAAG,MAAV;;AAEA,YAAI,OAAO,KAAK,CAAhB,EAAmB;AACjB,UAAA,SAAS,GAAG,GAAZ;AACA,UAAA,SAAS,GAAG,CAAZ;AACD,SAHD,MAGO,IAAI,MAAM,KAAK,OAAf,EAAwB;AAC7B,UAAA,SAAS,GAAG,CAAZ;AACA,UAAA,SAAS,GAAG,CAAZ;AACD,SAHM,MAGA;AACL,UAAA,SAAS,GAAG,CAAZ;AACA,UAAA,SAAS,GAAG,CAAZ;AACD;AACF;AACF,KA1ED;AA2EA;;;AAGG;;;AAEH,QAAI,SAAS,GAAG,SAAS,SAAT,CACd,CADc,EAEd,IAFc,EAGd,QAHc,CAGL;AAHK,M;AAKd,UAAI,CAAJ;AACA;;AAEA,UAAI,OAAO,GAAG,CAAC,CAAf;AACA;;AAEA,UAAI,MAAJ;AACA;;AAEA,UAAI,OAAO,GAAG,IAAI,CAAC,IAAI,CAAJ,GAAQ,CAAT,CAAlB;AACA;;AACA;;AAEA,UAAI,KAAK,GAAG,CAAZ;AACA;;AAEA,UAAI,SAAS,GAAG,CAAhB;AACA;;AAEA,UAAI,SAAS,GAAG,CAAhB;AACA;;AAEA;;AAEA;;AAEA,UAAI,OAAO,KAAK,CAAhB,EAAmB;AACjB,QAAA,SAAS,GAAG,GAAZ;AACA,QAAA,SAAS,GAAG,CAAZ;AACD;;AAED,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,IAAI,QAAjB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,QAAA,MAAM,GAAG,OAAT;AACA,QAAA,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAL,IAAU,CAAV,GAAc,CAAf,CAAd;AACA;;AAEA,YAAI,EAAE,KAAF,GAAU,SAAV,IAAuB,MAAM,KAAK,OAAtC,EAA+C;AAC7C;AACD,SAFD,MAEO,IAAI,KAAK,GAAG,SAAZ,EAAuB;AAC5B,aAAG;AACD,YAAA,SAAS,CAAC,CAAD,EAAI,MAAJ,EAAY,CAAC,CAAC,OAAd,CAAT;AACD,WAFD,QAES,EAAE,KAAF,KAAY,CAFrB;AAGD,SAJM,MAIA,IAAI,MAAM,KAAK,CAAf,EAAkB;AACvB,cAAI,MAAM,KAAK,OAAf,EAAwB;AACtB,YAAA,SAAS,CAAC,CAAD,EAAI,MAAJ,EAAY,CAAC,CAAC,OAAd,CAAT;AACA,YAAA,KAAK;AACN,WAJsB,CAIrB;;;AAEF,UAAA,SAAS,CAAC,CAAD,EAAI,OAAJ,EAAa,CAAC,CAAC,OAAf,CAAT;AACA,UAAA,SAAS,CAAC,CAAD,EAAI,KAAK,GAAG,CAAZ,EAAe,CAAf,CAAT;AACD,SARM,MAQA,IAAI,KAAK,IAAI,EAAb,EAAiB;AACtB,UAAA,SAAS,CAAC,CAAD,EAAI,SAAJ,EAAe,CAAC,CAAC,OAAjB,CAAT;AACA,UAAA,SAAS,CAAC,CAAD,EAAI,KAAK,GAAG,CAAZ,EAAe,CAAf,CAAT;AACD,SAHM,MAGA;AACL,UAAA,SAAS,CAAC,CAAD,EAAI,WAAJ,EAAiB,CAAC,CAAC,OAAnB,CAAT;AACA,UAAA,SAAS,CAAC,CAAD,EAAI,KAAK,GAAG,EAAZ,EAAgB,CAAhB,CAAT;AACD;;AAED,QAAA,KAAK,GAAG,CAAR;AACA,QAAA,OAAO,GAAG,MAAV;;AAEA,YAAI,OAAO,KAAK,CAAhB,EAAmB;AACjB,UAAA,SAAS,GAAG,GAAZ;AACA,UAAA,SAAS,GAAG,CAAZ;AACD,SAHD,MAGO,IAAI,MAAM,KAAK,OAAf,EAAwB;AAC7B,UAAA,SAAS,GAAG,CAAZ;AACA,UAAA,SAAS,GAAG,CAAZ;AACD,SAHM,MAGA;AACL,UAAA,SAAS,GAAG,CAAZ;AACA,UAAA,SAAS,GAAG,CAAZ;AACD;AACF;AACF,KA7ED;AA8EA;;;AAGG;;;AAEH,QAAI,aAAa,GAAG,SAAS,aAAT,CAAuB,CAAvB,EAAwB;AAC1C,UAAI,WAAJ;AACA;;AAEA;;AAEA,MAAA,SAAS,CAAC,CAAD,EAAI,CAAC,CAAC,SAAN,EAAiB,CAAC,CAAC,MAAF,CAAS,QAA1B,CAAT;AACA,MAAA,SAAS,CAAC,CAAD,EAAI,CAAC,CAAC,SAAN,EAAiB,CAAC,CAAC,MAAF,CAAS,QAA1B,CAAT;AACA;;AAEA,MAAA,UAAU,CAAC,CAAD,EAAI,CAAC,CAAC,OAAN,CAAV;AACA;;AAEG;;AAEH;;;AAGG;;AAEH,WAAK,WAAW,GAAG,QAAQ,GAAG,CAA9B,EAAiC,WAAW,IAAI,CAAhD,EAAmD,WAAW,EAA9D,EAAkE;AAChE,YACE,CAAC,CAAC,OAAF,CAAU,QAAQ,CAAC,WAAD,CAAR,GAAwB,CAAxB,GAA4B,CAAtC;AACA;AACA,SAHF,EAIE;AACA;AACD;AACF;AACD;;;AAEA,MAAA,CAAC,CAAC,OAAF,IAAa,KAAK,WAAW,GAAG,CAAnB,IAAwB,CAAxB,GAA4B,CAA5B,GAAgC,CAA7C,CA/B0C,CA+BK;AAC/C;;AAEA,aAAO,WAAP;AACD,KAnCD;AAoCA;;;;AAIG;;;AAEH,QAAI,cAAc,GAAG,SAAS,cAAT,CACnB,CADmB,EAEnB,MAFmB,EAGnB,MAHmB,EAInB,OAJmB,CAIX;AAJW,M;AAMnB,UAAI,IAAJ;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAA,SAAS,CAAC,CAAD,EAAI,MAAM,GAAG,GAAb,EAAkB,CAAlB,CAAT;AACA;;AAEA,MAAA,SAAS,CAAC,CAAD,EAAI,MAAM,GAAG,CAAb,EAAgB,CAAhB,CAAT;AACA,MAAA,SAAS,CAAC,CAAD,EAAI,OAAO,GAAG,CAAd,EAAiB,CAAjB,CAAT;AACA;;AAEA,WAAK,IAAI,GAAG,CAAZ,EAAe,IAAI,GAAG,OAAtB,EAA+B,IAAI,EAAnC,EAAuC;AACrC;AACA,QAAA,SAAS,CACP,CADO,EAEP,CAAC,CAAC,OAAF,CAAU,QAAQ,CAAC,IAAD,CAAR,GAAiB,CAAjB,GAAqB,CAA/B,CAFO;AAGP;AACA,SAJO,CAAT;AAMD,O,CAAC;;;AAEF,MAAA,SAAS,CAAC,CAAD,EAAI,CAAC,CAAC,SAAN,EAAiB,MAAM,GAAG,CAA1B,CAAT;AACA;AACA;;AAEA,MAAA,SAAS,CAAC,CAAD,EAAI,CAAC,CAAC,SAAN,EAAiB,MAAM,GAAG,CAA1B,CAAT;AACA;AACA;AACD,KArCD;AAsCA;;;;;;;;;;;;AAYG;;;AAEH,QAAI,gBAAgB,GAAG,SAAS,gBAAT,CAA0B,CAA1B,EAA2B;AAChD;;;AAGG;AACH,UAAI,UAAU,GAAG,UAAjB;AACA,UAAI,CAAJ;AACA;;AAEA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,IAAI,EAAjB,EAAqB,CAAC,IAAI,UAAU,MAAM,CAA1C,EAA6C;AAC3C,YACE,UAAU,GAAG,CAAb,IACA,CAAC,CAAC,SAAF,CAAY,CAAC,GAAG,CAAhB;AACE;AACA,SAJJ,EAKE;AACA,iBAAO,QAAP;AACD;AACF;AACD;;;AAEA,UACE,CAAC,CAAC,SAAF,CAAY,IAAI,CAAhB;AACE;AACA,OAFF,IAGA,CAAC,CAAC,SAAF,CAAY,KAAK,CAAjB;AACE;AACA,OALF,IAMA,CAAC,CAAC,SAAF,CAAY,KAAK,CAAjB;AACE;AACA,OATJ,EAUE;AACA,eAAO,MAAP;AACD;;AAED,WAAK,CAAC,GAAG,EAAT,EAAa,CAAC,GAAG,QAAjB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,YACE,CAAC,CAAC,SAAF,CAAY,CAAC,GAAG,CAAhB;AACA;AACA,SAHF,EAIE;AACA,iBAAO,MAAP;AACD;AACF;AACD;;AAEG;;;AAEH,aAAO,QAAP;AACD,KAjDD;;AAmDA,QAAI,gBAAgB,GAAG,KAAvB;AACA;;AAEG;;AAEH,QAAI,QAAQ,GAAG,SAAS,QAAT,CAAkB,CAAlB,EAAmB;AAChC,UAAI,CAAC,gBAAL,EAAuB;AACrB,QAAA,cAAc;AACd,QAAA,gBAAgB,GAAG,IAAnB;AACD;;AAED,MAAA,CAAC,CAAC,MAAF,GAAW,IAAI,QAAJ,CAAa,CAAC,CAAC,SAAf,EAA0B,aAA1B,CAAX;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,IAAI,QAAJ,CAAa,CAAC,CAAC,SAAf,EAA0B,aAA1B,CAAX;AACA,MAAA,CAAC,CAAC,OAAF,GAAY,IAAI,QAAJ,CAAa,CAAC,CAAC,OAAf,EAAwB,cAAxB,CAAZ;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,CAAX;AACA,MAAA,CAAC,CAAC,QAAF,GAAa,CAAb;AACA;;AAEA,MAAA,UAAU,CAAC,CAAD,CAAV;AACD,KAdD;AAeA;;AAEG;;;AAEH,QAAI,gBAAgB,GAAG,SAAS,gBAAT,CACrB,CADqB,EAErB,GAFqB,EAGrB,UAHqB,EAIrB,IAJqB,CAIhB;AAJgB,M;AAMrB,MAAA,SAAS,CAAC,CAAD,EAAI,CAAC,YAAY,IAAI,CAAjB,KAAuB,IAAI,GAAG,CAAH,GAAO,CAAlC,CAAJ,EAA0C,CAA1C,CAAT;AACA;;AAEA,MAAA,UAAU,CAAC,CAAD,EAAI,GAAJ,EAAS,UAAT,EAAqB,IAArB,CAAV;AACA;AACD,KAXD;AAYA;;;AAGG;;;AAEH,QAAI,SAAS,GAAG,SAAS,SAAT,CAAmB,CAAnB,EAAoB;AAClC,MAAA,SAAS,CAAC,CAAD,EAAI,YAAY,IAAI,CAApB,EAAuB,CAAvB,CAAT;AACA,MAAA,SAAS,CAAC,CAAD,EAAI,SAAJ,EAAe,YAAf,CAAT;AACA,MAAA,QAAQ,CAAC,CAAD,CAAR;AACD,KAJD;AAKA;;;AAGG;;;AAEH,QAAI,eAAe,GAAG,SAAS,eAAT,CACpB,CADoB,EAEpB,GAFoB,EAGpB,UAHoB,EAIpB,IAJoB,CAIf;AAJe,M;AAMpB,UAAI,QAAJ;AACA,UAAI,WAAJ;AACA;;AAEA,UAAI,WAAW,GAAG,CAAlB;AACA;;AAEA;;AAEA,UAAI,CAAC,CAAC,KAAF,GAAU,CAAd,EAAiB;AACf;AACA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,SAAzB,EAAoC;AAClC,UAAA,CAAC,CAAC,IAAF,CAAO,SAAP,GAAmB,gBAAgB,CAAC,CAAD,CAAnC;AACD;AACD;;;AAEA,QAAA,UAAU,CAAC,CAAD,EAAI,CAAC,CAAC,MAAN,CAAV,CAPe,CAOS;AACxB;;AAEA,QAAA,UAAU,CAAC,CAAD,EAAI,CAAC,CAAC,MAAN,CAAV,CAVe,CAUS;AACxB;;AAEA;;AAEG;;AAEH;;AAEG;;AAEH,QAAA,WAAW,GAAG,aAAa,CAAC,CAAD,CAA3B;AACA;;AAEA,QAAA,QAAQ,GAAI,CAAC,CAAC,OAAF,GAAY,CAAZ,GAAgB,CAAjB,KAAwB,CAAnC;AACA,QAAA,WAAW,GAAI,CAAC,CAAC,UAAF,GAAe,CAAf,GAAmB,CAApB,KAA2B,CAAzC,CAzBe,CAyB4B;AAC3C;AACA;;AAEA,YAAI,WAAW,IAAI,QAAnB,EAA6B;AAC3B,UAAA,QAAQ,GAAG,WAAX;AACD;AACF,OAhCD,MAgCO;AACL;AACA,QAAA,QAAQ,GAAG,WAAW,GAAG,UAAU,GAAG,CAAtC;AACA;AACD;;AAED,UAAI,UAAU,GAAG,CAAb,IAAkB,QAAlB,IAA8B,GAAG,KAAK,CAAC,CAA3C,EAA8C;AAC5C;;AAEA;;;;;AAKG;AACH,QAAA,gBAAgB,CAAC,CAAD,EAAI,GAAJ,EAAS,UAAT,EAAqB,IAArB,CAAhB;AACD,OAVD,MAUO,IAAI,CAAC,CAAC,QAAF,KAAe,OAAf,IAA0B,WAAW,KAAK,QAA9C,EAAwD;AAC7D,QAAA,SAAS,CAAC,CAAD,EAAI,CAAC,YAAY,IAAI,CAAjB,KAAuB,IAAI,GAAG,CAAH,GAAO,CAAlC,CAAJ,EAA0C,CAA1C,CAAT;AACA,QAAA,cAAc,CAAC,CAAD,EAAI,YAAJ,EAAkB,YAAlB,CAAd;AACD,OAHM,MAGA;AACL,QAAA,SAAS,CAAC,CAAD,EAAI,CAAC,SAAS,IAAI,CAAd,KAAoB,IAAI,GAAG,CAAH,GAAO,CAA/B,CAAJ,EAAuC,CAAvC,CAAT;AACA,QAAA,cAAc,CAAC,CAAD,EAAI,CAAC,CAAC,MAAF,CAAS,QAAT,GAAoB,CAAxB,EAA2B,CAAC,CAAC,MAAF,CAAS,QAAT,GAAoB,CAA/C,EAAkD,WAAW,GAAG,CAAhE,CAAd;AACA,QAAA,cAAc,CAAC,CAAD,EAAI,CAAC,CAAC,SAAN,EAAiB,CAAC,CAAC,SAAnB,CAAd;AACD,O,CAAC;;AAEF;;AAEG;;;AAEH,MAAA,UAAU,CAAC,CAAD,CAAV;;AAEA,UAAI,IAAJ,EAAU;AACR,QAAA,SAAS,CAAC,CAAD,CAAT;AACD,O,CAAC;AACF;;AACD,KAlFD;AAmFA;;;AAGG;;;AAEH,QAAI,SAAS,GAAG,SAAS,SAAT,CACd,CADc,EAEd,IAFc,EAGd,EAHc,CAGX;AAHW,M;AAKd;AACA,MAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,KAAF,GAAU,CAAC,CAAC,QAAF,GAAa,CAArC,IAA2C,IAAI,KAAK,CAAV,GAAe,IAAzD;AACA,MAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,KAAF,GAAU,CAAC,CAAC,QAAF,GAAa,CAAvB,GAA2B,CAAzC,IAA8C,IAAI,GAAG,IAArD;AACA,MAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,KAAF,GAAU,CAAC,CAAC,QAA1B,IAAsC,EAAE,GAAG,IAA3C;AACA,MAAA,CAAC,CAAC,QAAF;;AAEA,UAAI,IAAI,KAAK,CAAb,EAAgB;AACd;AACA,QAAA,CAAC,CAAC,SAAF,CAAY,EAAE,GAAG,CAAjB,EAAoB,WAApB;AACD,OAHD,MAGO;AACL,QAAA,CAAC,CAAC,OAAF;AACA;;AAEA,QAAA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,QAAA,CAAC,CAAC,SAAF,CAAY,CAAC,YAAY,CAAC,EAAD,CAAZ,GAAmB,QAAnB,GAA8B,CAA/B,IAAoC,CAAhD,EAAmD,WAAnD;AACA,QAAA,CAAC,CAAC,SAAF,CAAY,MAAM,CAAC,IAAD,CAAN,GAAe,CAA3B,EAA8B,WAA9B;AACD,O,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,aAAO,CAAC,CAAC,QAAF,KAAe,CAAC,CAAC,WAAF,GAAgB,CAAtC;AACA;;;AAGG;AACJ,KArDD;;AAuDA,QAAI,UAAU,GAAG,QAAjB;AACA,QAAI,kBAAkB,GAAG,gBAAzB;AACA,QAAI,iBAAiB,GAAG,eAAxB;AACA,QAAI,WAAW,GAAG,SAAlB;AACA,QAAI,WAAW,GAAG,SAAlB;AACA,QAAI,KAAK,GAAG;AACV,MAAA,QAAQ,EAAE,UADA;AAEV,MAAA,gBAAgB,EAAE,kBAFR;AAGV,MAAA,eAAe,EAAE,iBAHP;AAIV,MAAA,SAAS,EAAE,WAJD;AAKV,MAAA,SAAS,EAAE;AALD,KAAZ,CAz9CsB,CAi+CtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAI,OAAO,GAAG,SAAS,OAAT,CAAiB,KAAjB,EAAwB,GAAxB,EAA6B,GAA7B,EAAkC,GAAlC,EAAqC;AACjD,UAAI,EAAE,GAAI,KAAK,GAAG,MAAT,GAAmB,CAA5B;AACA,UAAI,EAAE,GAAK,KAAK,KAAK,EAAX,GAAiB,MAAlB,GAA4B,CAArC;AACA,UAAI,CAAC,GAAG,CAAR;;AAEA,aAAO,GAAG,KAAK,CAAf,EAAkB;AAChB;AACA;AACA;AACA,QAAA,CAAC,GAAG,GAAG,GAAG,IAAN,GAAa,IAAb,GAAoB,GAAxB;AACA,QAAA,GAAG,IAAI,CAAP;;AAEA,WAAG;AACD,UAAA,EAAE,GAAI,EAAE,GAAG,GAAG,CAAC,GAAG,EAAJ,CAAT,GAAoB,CAAzB;AACA,UAAA,EAAE,GAAI,EAAE,GAAG,EAAN,GAAY,CAAjB;AACD,SAHD,QAGS,EAAE,CAHX;;AAKA,QAAA,EAAE,IAAI,KAAN;AACA,QAAA,EAAE,IAAI,KAAN;AACD;;AAED,aAAO,EAAE,GAAI,EAAE,IAAI,EAAZ,GAAkB,CAAzB;AACD,KAtBD;;AAwBA,QAAI,SAAS,GAAG,OAAhB,CA9gDsB,CAghDtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAI,SAAS,GAAG,SAAS,SAAT,GAAkB;AAChC,UAAI,CAAJ;AACA,UAAI,KAAK,GAAG,EAAZ;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,QAAA,CAAC,GAAG,CAAJ;;AAEA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AAC1B,UAAA,CAAC,GAAG,CAAC,GAAG,CAAJ,GAAQ,aAAc,CAAC,KAAK,CAA5B,GAAiC,CAAC,KAAK,CAA3C;AACD;;AAED,QAAA,KAAK,CAAC,CAAD,CAAL,GAAW,CAAX;AACD;;AAED,aAAO,KAAP;AACD,KAfD,CAtiDsB,CAqjDpB;;;AAEF,QAAI,QAAQ,GAAG,IAAI,WAAJ,CAAgB,SAAS,EAAzB,CAAf;;AAEA,QAAI,KAAK,GAAG,SAAS,KAAT,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,EAAiC;AAC3C,UAAI,CAAC,GAAG,QAAR;AACA,UAAI,GAAG,GAAG,GAAG,GAAG,GAAhB;AACA,MAAA,GAAG,IAAI,CAAC,CAAR;;AAEA,WAAK,IAAI,CAAC,GAAG,GAAb,EAAkB,CAAC,GAAG,GAAtB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,QAAA,GAAG,GAAI,GAAG,KAAK,CAAT,GAAc,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAD,CAAV,IAAiB,IAAlB,CAArB;AACD;;AAED,aAAO,GAAG,GAAG,CAAC,CAAd,CAT2C,CAS3B;AACjB,KAVD;;AAYA,QAAI,OAAO,GAAG,KAAd,CArkDsB,CAukDtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAI,QAAQ,GAAG;AACb,SAAG,iBADU;;AAGb;AACA,SAAG,YAJU;;AAMb;AACA,SAAG,EAPU;;AASb;AACA,YAAM,YAVO;;AAYb;AACA,YAAM,cAbO;;AAeb;AACA,YAAM,YAhBO;;AAkBb;AACA,YAAM,qBAnBO;;AAqBb;AACA,YAAM,cAtBO;;AAwBb;AACA,YAAM;AAzBO,KAAf,CAzlDsB,CAsnDtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAI,SAAS,GAAG;AACd;AACA,MAAA,UAAU,EAAE,CAFE;AAGd,MAAA,eAAe,EAAE,CAHH;AAId,MAAA,YAAY,EAAE,CAJA;AAKd,MAAA,YAAY,EAAE,CALA;AAMd,MAAA,QAAQ,EAAE,CANI;AAOd,MAAA,OAAO,EAAE,CAPK;AAQd,MAAA,OAAO,EAAE,CARK;;AAUd;;AAEG;AACH,MAAA,IAAI,EAAE,CAbQ;AAcd,MAAA,YAAY,EAAE,CAdA;AAed,MAAA,WAAW,EAAE,CAfC;AAgBd,MAAA,OAAO,EAAE,CAAC,CAhBI;AAiBd,MAAA,cAAc,EAAE,CAAC,CAjBH;AAkBd,MAAA,YAAY,EAAE,CAAC,CAlBD;AAmBd,MAAA,WAAW,EAAE,CAAC,CAnBA;AAoBd,MAAA,WAAW,EAAE,CAAC,CApBA;AAqBd;;AAEA;AACA,MAAA,gBAAgB,EAAE,CAxBJ;AAyBd,MAAA,YAAY,EAAE,CAzBA;AA0Bd,MAAA,kBAAkB,EAAE,CA1BN;AA2Bd,MAAA,qBAAqB,EAAE,CAAC,CA3BV;AA4Bd,MAAA,UAAU,EAAE,CA5BE;AA6Bd,MAAA,cAAc,EAAE,CA7BF;AA8Bd,MAAA,KAAK,EAAE,CA9BO;AA+Bd,MAAA,OAAO,EAAE,CA/BK;AAgCd,MAAA,kBAAkB,EAAE,CAhCN;;AAkCd;AACA,MAAA,QAAQ,EAAE,CAnCI;AAoCd,MAAA,MAAM,EAAE,CApCM;AAqCd;AACA,MAAA,SAAS,EAAE,CAtCG;;AAwCd;AACA,MAAA,UAAU,EAAE;AAzCE,KAAhB,CAxoDsB,CAorDtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAI,UAAU,GAAG,KAAK,CAAC,QAAvB;AACA,QAAI,kBAAkB,GAAG,KAAK,CAAC,gBAA/B;AACA,QAAI,iBAAiB,GAAG,KAAK,CAAC,eAA9B;AACA,QAAI,WAAW,GAAG,KAAK,CAAC,SAAxB;AACA,QAAI,WAAW,GAAG,KAAK,CAAC,SAAxB;AACA;;AAEA;;AAEA,QAAI,UAAU,GAAG,SAAS,CAAC,UAA3B;AACA,QAAI,eAAe,GAAG,SAAS,CAAC,eAAhC;AACA,QAAI,YAAY,GAAG,SAAS,CAAC,YAA7B;AACA,QAAI,QAAQ,GAAG,SAAS,CAAC,QAAzB;AACA,QAAI,OAAO,GAAG,SAAS,CAAC,OAAxB;AACA,QAAI,IAAI,GAAG,SAAS,CAAC,IAArB;AACA,QAAI,YAAY,GAAG,SAAS,CAAC,YAA7B;AACA,QAAI,cAAc,GAAG,SAAS,CAAC,cAA/B;AACA,QAAI,YAAY,GAAG,SAAS,CAAC,YAA7B;AACA,QAAI,WAAW,GAAG,SAAS,CAAC,WAA5B;AACA,QAAI,qBAAqB,GAAG,SAAS,CAAC,qBAAtC;AACA,QAAI,UAAU,GAAG,SAAS,CAAC,UAA3B;AACA,QAAI,cAAc,GAAG,SAAS,CAAC,cAA/B;AACA,QAAI,KAAK,GAAG,SAAS,CAAC,KAAtB;AACA,QAAI,SAAS,GAAG,SAAS,CAAC,OAA1B;AACA,QAAI,kBAAkB,GAAG,SAAS,CAAC,kBAAnC;AACA,QAAI,WAAW,GAAG,SAAS,CAAC,SAA5B;AACA,QAAI,UAAU,GAAG,SAAS,CAAC,UAA3B;AACA;;AAEA,QAAI,aAAa,GAAG,CAApB;AACA;;AAEA,QAAI,SAAS,GAAG,EAAhB;AACA;;AAEA,QAAI,aAAa,GAAG,CAApB;AACA,QAAI,cAAc,GAAG,EAArB;AACA;;AAEA,QAAI,UAAU,GAAG,GAAjB;AACA;;AAEA,QAAI,SAAS,GAAG,UAAU,GAAG,CAAb,GAAiB,cAAjC;AACA;;AAEA,QAAI,SAAS,GAAG,EAAhB;AACA;;AAEA,QAAI,UAAU,GAAG,EAAjB;AACA;;AAEA,QAAI,WAAW,GAAG,IAAI,SAAJ,GAAgB,CAAlC;AACA;;AAEA,QAAI,UAAU,GAAG,EAAjB;AACA;;AAEA,QAAI,WAAW,GAAG,CAAlB;AACA,QAAI,WAAW,GAAG,GAAlB;AACA,QAAI,aAAa,GAAG,WAAW,GAAG,WAAd,GAA4B,CAAhD;AACA,QAAI,WAAW,GAAG,IAAlB;AACA,QAAI,UAAU,GAAG,EAAjB;AACA,QAAI,WAAW,GAAG,EAAlB;AACA,QAAI,UAAU,GAAG,EAAjB;AACA,QAAI,aAAa,GAAG,EAApB;AACA,QAAI,UAAU,GAAG,GAAjB;AACA,QAAI,UAAU,GAAG,GAAjB;AACA,QAAI,YAAY,GAAG,GAAnB;AACA,QAAI,YAAY,GAAG,CAAnB;AACA;;AAEA,QAAI,aAAa,GAAG,CAApB;AACA;;AAEA,QAAI,iBAAiB,GAAG,CAAxB;AACA;;AAEA,QAAI,cAAc,GAAG,CAArB;AACA;;AAEA,QAAI,OAAO,GAAG,IAAd,CAtxDsB,CAsxDH;;AAEnB,QAAI,GAAG,GAAG,SAAS,GAAT,CAAa,IAAb,EAAmB,SAAnB,EAA4B;AACpC,MAAA,IAAI,CAAC,GAAL,GAAW,QAAQ,CAAC,SAAD,CAAnB;AACA,aAAO,SAAP;AACD,KAHD;;AAKA,QAAI,IAAI,GAAG,SAAS,IAAT,CAAc,CAAd,EAAe;AACxB,aAAO,CAAC,CAAC,IAAI,CAAN,KAAY,CAAC,GAAG,CAAJ,GAAQ,CAAR,GAAY,CAAxB,CAAP;AACD,KAFD;;AAIA,QAAI,MAAM,GAAG,SAAS,IAAT,CAAc,GAAd,EAAiB;AAC5B,UAAI,GAAG,GAAG,GAAG,CAAC,MAAd;;AAEA,aAAO,EAAE,GAAF,IAAS,CAAhB,EAAmB;AACjB,QAAA,GAAG,CAAC,GAAD,CAAH,GAAW,CAAX;AACD;AACF,KAND;AAOA;;;AAEA,QAAI,SAAS,GAAG,SAAS,SAAT,CAAmB,CAAnB,EAAsB,IAAtB,EAA4B,IAA5B,EAAgC;AAC9C,aAAO,CAAE,IAAI,IAAI,CAAC,CAAC,UAAX,GAAyB,IAA1B,IAAkC,CAAC,CAAC,SAA3C;AACD,KAFD,CA1yDsB,CA4yDpB;AACF;AACA;;;AAEA,QAAI,IAAI,GAAG,SAAX;AACA;;;;;AAKG;;AAEH,QAAI,aAAa,GAAG,SAAS,aAAT,CAAuB,IAAvB,EAA2B;AAC7C,UAAI,CAAC,GAAG,IAAI,CAAC,KAAb,CAD6C,CAC1B;;AAEnB,UAAI,GAAG,GAAG,CAAC,CAAC,OAAZ;;AAEA,UAAI,GAAG,GAAG,IAAI,CAAC,SAAf,EAA0B;AACxB,QAAA,GAAG,GAAG,IAAI,CAAC,SAAX;AACD;;AAED,UAAI,GAAG,KAAK,CAAZ,EAAe;AACb;AACD;;AAED,MAAA,IAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,CAAC,CAAC,WAAF,CAAc,QAAd,CAAuB,CAAC,CAAC,WAAzB,EAAsC,CAAC,CAAC,WAAF,GAAgB,GAAtD,CAAhB,EAA4E,IAAI,CAAC,QAAjF;AACA,MAAA,IAAI,CAAC,QAAL,IAAiB,GAAjB;AACA,MAAA,CAAC,CAAC,WAAF,IAAiB,GAAjB;AACA,MAAA,IAAI,CAAC,SAAL,IAAkB,GAAlB;AACA,MAAA,IAAI,CAAC,SAAL,IAAkB,GAAlB;AACA,MAAA,CAAC,CAAC,OAAF,IAAa,GAAb;;AAEA,UAAI,CAAC,CAAC,OAAF,KAAc,CAAlB,EAAqB;AACnB,QAAA,CAAC,CAAC,WAAF,GAAgB,CAAhB;AACD;AACF,KAvBD;;AAyBA,QAAI,gBAAgB,GAAG,SAAS,gBAAT,CAA0B,CAA1B,EAA6B,IAA7B,EAAiC;AACtD,MAAA,iBAAiB,CAAC,CAAD,EAAI,CAAC,CAAC,WAAF,IAAiB,CAAjB,GAAqB,CAAC,CAAC,WAAvB,GAAqC,CAAC,CAA1C,EAA6C,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,WAA5D,EAAyE,IAAzE,CAAjB;;AAEA,MAAA,CAAC,CAAC,WAAF,GAAgB,CAAC,CAAC,QAAlB;AACA,MAAA,aAAa,CAAC,CAAC,CAAC,IAAH,CAAb;AACD,KALD;;AAOA,QAAI,QAAQ,GAAG,SAAS,QAAT,CAAkB,CAAlB,EAAqB,CAArB,EAAsB;AACnC,MAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,OAAF,EAAd,IAA6B,CAA7B;AACD,KAFD;AAGA;;;;AAIG;;;AAEH,QAAI,WAAW,GAAG,SAAS,WAAT,CAAqB,CAArB,EAAwB,CAAxB,EAAyB;AACzC;AACA;AACA,MAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,OAAF,EAAd,IAA8B,CAAC,KAAK,CAAP,GAAY,IAAzC;AACA,MAAA,CAAC,CAAC,WAAF,CAAc,CAAC,CAAC,OAAF,EAAd,IAA6B,CAAC,GAAG,IAAjC;AACD,KALD;AAMA;;;;;;AAMG;;;AAEH,QAAI,QAAQ,GAAG,SAAS,QAAT,CAAkB,IAAlB,EAAwB,GAAxB,EAA6B,KAA7B,EAAoC,IAApC,EAAwC;AACrD,UAAI,GAAG,GAAG,IAAI,CAAC,QAAf;;AAEA,UAAI,GAAG,GAAG,IAAV,EAAgB;AACd,QAAA,GAAG,GAAG,IAAN;AACD;;AAED,UAAI,GAAG,KAAK,CAAZ,EAAe;AACb,eAAO,CAAP;AACD;;AAED,MAAA,IAAI,CAAC,QAAL,IAAiB,GAAjB,CAXqD,CAWhC;;AAErB,MAAA,GAAG,CAAC,GAAJ,CAAQ,IAAI,CAAC,KAAL,CAAW,QAAX,CAAoB,IAAI,CAAC,OAAzB,EAAkC,IAAI,CAAC,OAAL,GAAe,GAAjD,CAAR,EAA+D,KAA/D;;AAEA,UAAI,IAAI,CAAC,KAAL,CAAW,IAAX,KAAoB,CAAxB,EAA2B;AACzB,QAAA,IAAI,CAAC,KAAL,GAAa,SAAS,CAAC,IAAI,CAAC,KAAN,EAAa,GAAb,EAAkB,GAAlB,EAAuB,KAAvB,CAAtB;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,KAAL,CAAW,IAAX,KAAoB,CAAxB,EAA2B;AAChC,QAAA,IAAI,CAAC,KAAL,GAAa,OAAO,CAAC,IAAI,CAAC,KAAN,EAAa,GAAb,EAAkB,GAAlB,EAAuB,KAAvB,CAApB;AACD;;AAED,MAAA,IAAI,CAAC,OAAL,IAAgB,GAAhB;AACA,MAAA,IAAI,CAAC,QAAL,IAAiB,GAAjB;AACA,aAAO,GAAP;AACD,KAxBD;AAyBA;;;;;;;;AAQG;;;AAEH,QAAI,aAAa,GAAG,SAAS,aAAT,CAAuB,CAAvB,EAA0B,SAA1B,EAAmC;AACrD,UAAI,YAAY,GAAG,CAAC,CAAC,gBAArB;AACA;;AAEA,UAAI,IAAI,GAAG,CAAC,CAAC,QAAb;AACA;;AAEA,UAAI,KAAJ;AACA;;AAEA,UAAI,GAAJ;AACA;;AAEA,UAAI,QAAQ,GAAG,CAAC,CAAC,WAAjB;AACA;;AAEA,UAAI,UAAU,GAAG,CAAC,CAAC,UAAnB;AACA;;AAEA,UAAI,KAAK,GAAG,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,MAAF,GAAW,aAAxB,GAAwC,CAAC,CAAC,QAAF,IAAc,CAAC,CAAC,MAAF,GAAW,aAAzB,CAAxC,GAAkF,CAA9F;AACA;;AACA,UAAI,IAAI,GAAG,CAAC,CAAC,MAAb,CArBqD,CAqBjC;;AAEpB,UAAI,KAAK,GAAG,CAAC,CAAC,MAAd;AACA,UAAI,IAAI,GAAG,CAAC,CAAC,IAAb;AACA;;AAEG;;AAEH,UAAI,MAAM,GAAG,CAAC,CAAC,QAAF,GAAa,WAA1B;AACA,UAAI,SAAS,GAAG,IAAI,CAAC,IAAI,GAAG,QAAP,GAAkB,CAAnB,CAApB;AACA,UAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,GAAG,QAAR,CAAnB;AACA;;AAEG;AACH;;AAEA;;AAEA,UAAI,CAAC,CAAC,WAAF,IAAiB,CAAC,CAAC,UAAvB,EAAmC;AACjC,QAAA,YAAY,KAAK,CAAjB;AACD;AACD;;AAEG;;;AAEH,UAAI,UAAU,GAAG,CAAC,CAAC,SAAnB,EAA8B;AAC5B,QAAA,UAAU,GAAG,CAAC,CAAC,SAAf;AACD,OAhDoD,CAgDnD;;;AAEF,SAAG;AACD;AACA,QAAA,KAAK,GAAG,SAAR;AACA;;;;;;;AAOG;;AAEH,YACE,IAAI,CAAC,KAAK,GAAG,QAAT,CAAJ,KAA2B,QAA3B,IACA,IAAI,CAAC,KAAK,GAAG,QAAR,GAAmB,CAApB,CAAJ,KAA+B,SAD/B,IAEA,IAAI,CAAC,KAAD,CAAJ,KAAgB,IAAI,CAAC,IAAD,CAFpB,IAGA,IAAI,CAAC,EAAE,KAAH,CAAJ,KAAkB,IAAI,CAAC,IAAI,GAAG,CAAR,CAJxB,EAKE;AACA;AACD;AACD;;;;;AAKG;;;AAEH,QAAA,IAAI,IAAI,CAAR;AACA,QAAA,KAAK,GA5BJ,CA4BO;;AAER;;AAEG;;AAEH,WAAG;AACD;AACD,SAFD,QAGE,IAAI,CAAC,EAAE,IAAH,CAAJ,KAAiB,IAAI,CAAC,EAAE,KAAH,CAArB,IACA,IAAI,CAAC,EAAE,IAAH,CAAJ,KAAiB,IAAI,CAAC,EAAE,KAAH,CADrB,IAEA,IAAI,CAAC,EAAE,IAAH,CAAJ,KAAiB,IAAI,CAAC,EAAE,KAAH,CAFrB,IAGA,IAAI,CAAC,EAAE,IAAH,CAAJ,KAAiB,IAAI,CAAC,EAAE,KAAH,CAHrB,IAIA,IAAI,CAAC,EAAE,IAAH,CAAJ,KAAiB,IAAI,CAAC,EAAE,KAAH,CAJrB,IAKA,IAAI,CAAC,EAAE,IAAH,CAAJ,KAAiB,IAAI,CAAC,EAAE,KAAH,CALrB,IAMA,IAAI,CAAC,EAAE,IAAH,CAAJ,KAAiB,IAAI,CAAC,EAAE,KAAH,CANrB,IAOA,IAAI,CAAC,EAAE,IAAH,CAAJ,KAAiB,IAAI,CAAC,EAAE,KAAH,CAPrB,IAQA,IAAI,GAAG,MAXT,EAlCC,CA8CC;;;AAEF,QAAA,GAAG,GAAG,WAAW,IAAI,MAAM,GAAG,IAAb,CAAjB;AACA,QAAA,IAAI,GAAG,MAAM,GAAG,WAAhB;;AAEA,YAAI,GAAG,GAAG,QAAV,EAAoB;AAClB,UAAA,CAAC,CAAC,WAAF,GAAgB,SAAhB;AACA,UAAA,QAAQ,GAAG,GAAX;;AAEA,cAAI,GAAG,IAAI,UAAX,EAAuB;AACrB;AACD;;AAED,UAAA,SAAS,GAAG,IAAI,CAAC,IAAI,GAAG,QAAP,GAAkB,CAAnB,CAAhB;AACA,UAAA,QAAQ,GAAG,IAAI,CAAC,IAAI,GAAG,QAAR,CAAf;AACD;AACF,OA9DD,QA8DS,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,KAAb,CAAjB,IAAwC,KAAxC,IAAiD,EAAE,YAAF,KAAmB,CA9D7E;;AAgEA,UAAI,QAAQ,IAAI,CAAC,CAAC,SAAlB,EAA6B;AAC3B,eAAO,QAAP;AACD;;AAED,aAAO,CAAC,CAAC,SAAT;AACD,KAvHD;AAwHA;;;;;;;;;AASG;;;AAEH,QAAI,WAAW,GAAG,SAAS,WAAT,CAAqB,CAArB,EAAsB;AACtC,UAAI,OAAO,GAAG,CAAC,CAAC,MAAhB;AACA,UAAI,CAAJ;AACA,UAAI,CAAJ;AACA,UAAI,CAAJ;AACA,UAAI,IAAJ;AACA,UAAI,GAAJ,CANsC,CAM9B;;AAER,SAAG;AACD,QAAA,IAAI,GAAG,CAAC,CAAC,WAAF,GAAgB,CAAC,CAAC,SAAlB,GAA8B,CAAC,CAAC,QAAvC,CADC,CAC+C;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEG;;AAEH,YAAI,CAAC,CAAC,QAAF,IAAc,OAAO,IAAI,OAAO,GAAG,aAAd,CAAzB,EAAuD;AACrD,UAAA,CAAC,CAAC,MAAF,CAAS,GAAT,CAAa,CAAC,CAAC,MAAF,CAAS,QAAT,CAAkB,OAAlB,EAA2B,OAAO,GAAG,OAArC,CAAb,EAA4D,CAA5D;AACA,UAAA,CAAC,CAAC,WAAF,IAAiB,OAAjB;AACA,UAAA,CAAC,CAAC,QAAF,IAAc,OAAd;AACA;;AAEA,UAAA,CAAC,CAAC,WAAF,IAAiB,OAAjB;AACA;;;;;AAKC;;AAED,UAAA,CAAC,GAAG,CAAC,CAAC,SAAN;AACA,UAAA,CAAC,GAAG,CAAJ;;AAEA,aAAG;AACD,YAAA,CAAC,GAAG,CAAC,CAAC,IAAF,CAAO,EAAE,CAAT,CAAJ;AACA,YAAA,CAAC,CAAC,IAAF,CAAO,CAAP,IAAY,CAAC,IAAI,OAAL,GAAe,CAAC,GAAG,OAAnB,GAA6B,CAAzC;AACD,WAHD,QAGS,EAAE,CAHX;;AAKA,UAAA,CAAC,GAAG,OAAJ;AACA,UAAA,CAAC,GAAG,CAAJ;;AAEA,aAAG;AACD,YAAA,CAAC,GAAG,CAAC,CAAC,IAAF,CAAO,EAAE,CAAT,CAAJ;AACA,YAAA,CAAC,CAAC,IAAF,CAAO,CAAP,IAAY,CAAC,IAAI,OAAL,GAAe,CAAC,GAAG,OAAnB,GAA6B,CAAzC;AACA;;AAEG;AACJ,WAND,QAMS,EAAE,CANX;;AAQA,UAAA,IAAI,IAAI,OAAR;AACD;;AAED,YAAI,CAAC,CAAC,IAAF,CAAO,QAAP,KAAoB,CAAxB,EAA2B;AACzB;AACD;AACD;;;;;;;;;;AAUG;AACH;;;AAEA,QAAA,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAH,EAAS,CAAC,CAAC,MAAX,EAAmB,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,SAAlC,EAA6C,IAA7C,CAAZ;AACA,QAAA,CAAC,CAAC,SAAF,IAAe,CAAf;AACA;;AAEA,YAAI,CAAC,CAAC,SAAF,GAAc,CAAC,CAAC,MAAhB,IAA0B,WAA9B,EAA2C;AACzC,UAAA,GAAG,GAAG,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,MAArB;AACA,UAAA,CAAC,CAAC,KAAF,GAAU,CAAC,CAAC,MAAF,CAAS,GAAT,CAAV;AACA;;AAEA,UAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,EAAa,CAAC,CAAC,MAAF,CAAS,GAAG,GAAG,CAAf,CAAb,CAAd,CALyC,CAKK;AAC9C;AACA;;AAEA,iBAAO,CAAC,CAAC,MAAT,EAAiB;AACf;AACA,YAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,EAAa,CAAC,CAAC,MAAF,CAAS,GAAG,GAAG,WAAN,GAAoB,CAA7B,CAAb,CAAd;AACA,YAAA,CAAC,CAAC,IAAF,CAAO,GAAG,GAAG,CAAC,CAAC,MAAf,IAAyB,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,CAAzB;AACA,YAAA,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,IAAkB,GAAlB;AACA,YAAA,GAAG;AACH,YAAA,CAAC,CAAC,MAAF;;AAEA,gBAAI,CAAC,CAAC,SAAF,GAAc,CAAC,CAAC,MAAhB,GAAyB,WAA7B,EAA0C;AACxC;AACD;AACF;AACF;AACD;;AAEG;;AACJ,OArGD,QAqGS,CAAC,CAAC,SAAF,GAAc,aAAd,IAA+B,CAAC,CAAC,IAAF,CAAO,QAAP,KAAoB,CArG5D;AAsGA;;;;;;AAMG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACD,KAlJD;AAmJA;;;;;;;;AAQG;;;AAEH,QAAI,cAAc,GAAG,SAAS,cAAT,CAAwB,CAAxB,EAA2B,KAA3B,EAAgC;AACnD;;AAEG;AACH,UAAI,cAAc,GAAG,MAArB;;AAEA,UAAI,cAAc,GAAG,CAAC,CAAC,gBAAF,GAAqB,CAA1C,EAA6C;AAC3C,QAAA,cAAc,GAAG,CAAC,CAAC,gBAAF,GAAqB,CAAtC;AACD;AACD;;;AAEA,eAAS;AACP;AACA,YAAI,CAAC,CAAC,SAAF,IAAe,CAAnB,EAAsB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,UAAA,WAAW,CAAC,CAAD,CAAX;;AAEA,cAAI,CAAC,CAAC,SAAF,KAAgB,CAAhB,IAAqB,KAAK,KAAK,UAAnC,EAA+C;AAC7C,mBAAO,YAAP;AACD;;AAED,cAAI,CAAC,CAAC,SAAF,KAAgB,CAApB,EAAuB;AACrB;AACD;AACD;;AACD,SAnBM,CAmBL;AACF;;;AAEA,QAAA,CAAC,CAAC,QAAF,IAAc,CAAC,CAAC,SAAhB;AACA,QAAA,CAAC,CAAC,SAAF,GAAc,CAAd;AACA;;AAEA,YAAI,SAAS,GAAG,CAAC,CAAC,WAAF,GAAgB,cAAhC;;AAEA,YAAI,CAAC,CAAC,QAAF,KAAe,CAAf,IAAoB,CAAC,CAAC,QAAF,IAAc,SAAtC,EAAiD;AAC/C;AACA,UAAA,CAAC,CAAC,SAAF,GAAc,CAAC,CAAC,QAAF,GAAa,SAA3B;AACA,UAAA,CAAC,CAAC,QAAF,GAAa,SAAb;AACA;;AAEA,UAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,cAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,mBAAO,YAAP;AACD;AACD;;AACD;AACD;;AAEG;;;AAEH,YAAI,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,WAAf,IAA8B,CAAC,CAAC,MAAF,GAAW,aAA7C,EAA4D;AAC1D;AACA,UAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,cAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,mBAAO,YAAP;AACD;AACD;;AACD;AACF;;AAED,MAAA,CAAC,CAAC,MAAF,GAAW,CAAX;;AAEA,UAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,IAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,iBAAP;AACD;AACD;;;AAEA,eAAO,cAAP;AACD;;AAED,UAAI,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,WAAnB,EAAgC;AAC9B;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,YAAP;AACD;AACD;;AACD;;AAED,aAAO,YAAP;AACD,KA5FD;AA6FA;;;;;;AAMG;;;AAEH,QAAI,YAAY,GAAG,SAAS,YAAT,CAAsB,CAAtB,EAAyB,KAAzB,EAA8B;AAC/C,UAAI,SAAJ;AACA;;AAEA,UAAI,MAAJ;AACA;;AAEA,eAAS;AACP;;;;AAIG;AACH,YAAI,CAAC,CAAC,SAAF,GAAc,aAAlB,EAAiC;AAC/B,UAAA,WAAW,CAAC,CAAD,CAAX;;AAEA,cAAI,CAAC,CAAC,SAAF,GAAc,aAAd,IAA+B,KAAK,KAAK,UAA7C,EAAyD;AACvD,mBAAO,YAAP;AACD;;AAED,cAAI,CAAC,CAAC,SAAF,KAAgB,CAApB,EAAuB;AACrB;AACA;AACD;AACF;AACD;;AAEG;;;AAEH,QAAA,SAAS,GAAG,CAAZ;AACA;;AAEA,YAAI,CAAC,CAAC,SAAF,IAAe,WAAnB,EAAgC;AAC9B;AACA,UAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,EAAa,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAF,GAAa,WAAb,GAA2B,CAApC,CAAb,CAAd;AACA,UAAA,SAAS,GAAG,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,MAAtB,IAAgC,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,CAA5C;AACA,UAAA,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,IAAkB,CAAC,CAAC,QAApB;AACA;AACD;AACD;;AAEG;;;AAEH,YACE,SAAS,KAAK,CAAd;AACA;AACA,QAAA,CAAC,CAAC,QAAF,GAAa,SAAb,IAA0B,CAAC,CAAC,MAAF,GAAW,aAHvC,EAIE;AACA;;;AAGG;AACH,UAAA,CAAC,CAAC,YAAF,GAAiB,aAAa,CAAC,CAAD,EAAI,SAAJ,CAA9B;AACA;AACD;;AAED,YAAI,CAAC,CAAC,YAAF,IAAkB,WAAtB,EAAmC;AACjC;;AAEA;AACuD;AACvD,UAAA,MAAM,GAAG,WAAW,CAAC,CAAD,EAAI,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,WAAnB,EAAgC,CAAC,CAAC,YAAF,GAAiB,WAAjD,CAApB;AACA,UAAA,CAAC,CAAC,SAAF,IAAe,CAAC,CAAC,YAAjB;AACA;;AAEG;;AAEH,cACE,CAAC,CAAC,YAAF,IAAkB,CAAC,CAAC,cAApB;AACA;AACA,UAAA,CAAC,CAAC,SAAF,IAAe,WAHjB,EAIE;AACA,YAAA,CAAC,CAAC,YAAF;AACA;;AAEA,eAAG;AACD,cAAA,CAAC,CAAC,QAAF;AACA;;AAEA,cAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,EAAa,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAF,GAAa,WAAb,GAA2B,CAApC,CAAb,CAAd;AACA,cAAA,SAAS,GAAG,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,MAAtB,IAAgC,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,CAA5C;AACA,cAAA,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,IAAkB,CAAC,CAAC,QAApB;AACA;;AAEA;;AAEG;AACJ,aAZD,QAYS,EAAE,CAAC,CAAC,YAAJ,KAAqB,CAZ9B;;AAcA,YAAA,CAAC,CAAC,QAAF;AACD,WAvBD,MAuBO;AACL,YAAA,CAAC,CAAC,QAAF,IAAc,CAAC,CAAC,YAAhB;AACA,YAAA,CAAC,CAAC,YAAF,GAAiB,CAAjB;AACA,YAAA,CAAC,CAAC,KAAF,GAAU,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAX,CAAV;AACA;;AAEA,YAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,EAAa,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAF,GAAa,CAAtB,CAAb,CAAd,CANK,CAMgD;AACrD;AACA;;AAEA;;AAEG;AACJ;AACF,SAhDD,MAgDO;AACL;AACA;;AAEA;AACA,UAAA,MAAM,GAAG,WAAW,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAX,CAAP,CAApB;AACA,UAAA,CAAC,CAAC,SAAF;AACA,UAAA,CAAC,CAAC,QAAF;AACD;;AAED,YAAI,MAAJ,EAAY;AACV;AACA,UAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,cAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,mBAAO,YAAP;AACD;AACD;;AACD;AACF;;AAED,MAAA,CAAC,CAAC,MAAF,GAAW,CAAC,CAAC,QAAF,GAAa,WAAW,GAAG,CAA3B,GAA+B,CAAC,CAAC,QAAjC,GAA4C,WAAW,GAAG,CAArE;;AAEA,UAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,IAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,iBAAP;AACD;AACD;;;AAEA,eAAO,cAAP;AACD;;AAED,UAAI,CAAC,CAAC,QAAN,EAAgB;AACd;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,YAAP;AACD;AACD;;AACD;;AAED,aAAO,aAAP;AACD,KAtJD;AAuJA;;;;AAIG;;;AAEH,QAAI,YAAY,GAAG,SAAS,YAAT,CAAsB,CAAtB,EAAyB,KAAzB,EAA8B;AAC/C,UAAI,SAAJ;AACA;;AAEA,UAAI,MAAJ;AACA;;AAEA,UAAI,UAAJ;AACA;;AAEA,eAAS;AACP;;;;AAIG;AACH,YAAI,CAAC,CAAC,SAAF,GAAc,aAAlB,EAAiC;AAC/B,UAAA,WAAW,CAAC,CAAD,CAAX;;AAEA,cAAI,CAAC,CAAC,SAAF,GAAc,aAAd,IAA+B,KAAK,KAAK,UAA7C,EAAyD;AACvD,mBAAO,YAAP;AACD;;AAED,cAAI,CAAC,CAAC,SAAF,KAAgB,CAApB,EAAuB;AACrB;AACD;AACD;;AACD;AACD;;AAEG;;;AAEH,QAAA,SAAS,GAAG,CAAZ;AACA;;AAEA,YAAI,CAAC,CAAC,SAAF,IAAe,WAAnB,EAAgC;AAC9B;AACA,UAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,EAAa,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAF,GAAa,WAAb,GAA2B,CAApC,CAAb,CAAd;AACA,UAAA,SAAS,GAAG,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,MAAtB,IAAgC,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,CAA5C;AACA,UAAA,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,IAAkB,CAAC,CAAC,QAApB;AACA;AACD;AACD;AACG;;;AAEH,QAAA,CAAC,CAAC,WAAF,GAAgB,CAAC,CAAC,YAAlB;AACA,QAAA,CAAC,CAAC,UAAF,GAAe,CAAC,CAAC,WAAjB;AACA,QAAA,CAAC,CAAC,YAAF,GAAiB,WAAW,GAAG,CAA/B;;AAEA,YACE,SAAS,KAAK,CAAd;AACA;AACA,QAAA,CAAC,CAAC,WAAF,GAAgB,CAAC,CAAC,cAFlB,IAGA,CAAC,CAAC,QAAF,GAAa,SAAb,IAA0B,CAAC,CAAC,MAAF,GAAW;AACrC;AALF,UAME;AACA;;;AAGG;AACH,UAAA,CAAC,CAAC,YAAF,GAAiB,aAAa,CAAC,CAAD,EAAI,SAAJ,CAA9B;AACA;;AAEA,cACE,CAAC,CAAC,YAAF,IAAkB,CAAlB,KACC,CAAC,CAAC,QAAF,KAAe,UAAf,IAA8B,CAAC,CAAC,YAAF,KAAmB,WAAnB,IAAkC,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,WAAf,GAA6B,IAD9F;AAEA;AAHF,YAIE;AACA;;AAEG;AACH,YAAA,CAAC,CAAC,YAAF,GAAiB,WAAW,GAAG,CAA/B;AACD;AACF;AACD;;AAEG;;;AAEH,YAAI,CAAC,CAAC,WAAF,IAAiB,WAAjB,IAAgC,CAAC,CAAC,YAAF,IAAkB,CAAC,CAAC,WAAxD,EAAqE;AACnE,UAAA,UAAU,GAAG,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,SAAf,GAA2B,WAAxC;AACA;AACA;;AAEA;AACqD;;AAErD,UAAA,MAAM,GAAG,WAAW,CAAC,CAAD,EAAI,CAAC,CAAC,QAAF,GAAa,CAAb,GAAiB,CAAC,CAAC,UAAvB,EAAmC,CAAC,CAAC,WAAF,GAAgB,WAAnD,CAApB;AACA;;;;AAIG;;AAEH,UAAA,CAAC,CAAC,SAAF,IAAe,CAAC,CAAC,WAAF,GAAgB,CAA/B;AACA,UAAA,CAAC,CAAC,WAAF,IAAiB,CAAjB;;AAEA,aAAG;AACD,gBAAI,EAAE,CAAC,CAAC,QAAJ,IAAgB,UAApB,EAAgC;AAC9B;AACA,cAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,EAAa,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAF,GAAa,WAAb,GAA2B,CAApC,CAAb,CAAd;AACA,cAAA,SAAS,GAAG,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,MAAtB,IAAgC,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,CAA5C;AACA,cAAA,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,IAAkB,CAAC,CAAC,QAApB;AACA;AACD;AACF,WARD,QAQS,EAAE,CAAC,CAAC,WAAJ,KAAoB,CAR7B;;AAUA,UAAA,CAAC,CAAC,eAAF,GAAoB,CAApB;AACA,UAAA,CAAC,CAAC,YAAF,GAAiB,WAAW,GAAG,CAA/B;AACA,UAAA,CAAC,CAAC,QAAF;;AAEA,cAAI,MAAJ,EAAY;AACV;AACA,YAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,gBAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAO,YAAP;AACD;AACD;;AACD;AACF,SAzCD,MAyCO,IAAI,CAAC,CAAC,eAAN,EAAuB;AAC5B;;;AAGG;AACH;;AAEA;AACA,UAAA,MAAM,GAAG,WAAW,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAF,GAAa,CAAtB,CAAP,CAApB;;AAEA,cAAI,MAAJ,EAAY;AACV;AACA,YAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;AACA;AACD;;AAED,UAAA,CAAC,CAAC,QAAF;AACA,UAAA,CAAC,CAAC,SAAF;;AAEA,cAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,mBAAO,YAAP;AACD;AACF,SAtBM,MAsBA;AACL;;AAEG;AACH,UAAA,CAAC,CAAC,eAAF,GAAoB,CAApB;AACA,UAAA,CAAC,CAAC,QAAF;AACA,UAAA,CAAC,CAAC,SAAF;AACD;AACF,OArJ8C,CAqJ7C;;;AAEF,UAAI,CAAC,CAAC,eAAN,EAAuB;AACrB;;AAEA;AACA,QAAA,MAAM,GAAG,WAAW,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAF,GAAa,CAAtB,CAAP,CAApB;AACA,QAAA,CAAC,CAAC,eAAF,GAAoB,CAApB;AACD;;AAED,MAAA,CAAC,CAAC,MAAF,GAAW,CAAC,CAAC,QAAF,GAAa,WAAW,GAAG,CAA3B,GAA+B,CAAC,CAAC,QAAjC,GAA4C,WAAW,GAAG,CAArE;;AAEA,UAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,IAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,iBAAP;AACD;AACD;;;AAEA,eAAO,cAAP;AACD;;AAED,UAAI,CAAC,CAAC,QAAN,EAAgB;AACd;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,YAAP;AACD;AACD;;AACD;;AAED,aAAO,aAAP;AACD,KAxLD;AAyLA;;;;AAIG;;;AAEH,QAAI,WAAW,GAAG,SAAS,WAAT,CAAqB,CAArB,EAAwB,KAAxB,EAA6B;AAC7C,UAAI,MAAJ;AACA;;AAEA,UAAI,IAAJ;AACA;;AAEA,UAAI,IAAJ;AACA,UAAI,MAAJ;AACA;;AAEA,UAAI,IAAI,GAAG,CAAC,CAAC,MAAb;;AAEA,eAAS;AACP;;;AAGG;AACH,YAAI,CAAC,CAAC,SAAF,IAAe,WAAnB,EAAgC;AAC9B,UAAA,WAAW,CAAC,CAAD,CAAX;;AAEA,cAAI,CAAC,CAAC,SAAF,IAAe,WAAf,IAA8B,KAAK,KAAK,UAA5C,EAAwD;AACtD,mBAAO,YAAP;AACD;;AAED,cAAI,CAAC,CAAC,SAAF,KAAgB,CAApB,EAAuB;AACrB;AACD;AACD;;AACD;AACD;;;AAEA,QAAA,CAAC,CAAC,YAAF,GAAiB,CAAjB;;AAEA,YAAI,CAAC,CAAC,SAAF,IAAe,WAAf,IAA8B,CAAC,CAAC,QAAF,GAAa,CAA/C,EAAkD;AAChD,UAAA,IAAI,GAAG,CAAC,CAAC,QAAF,GAAa,CAApB;AACA,UAAA,IAAI,GAAG,IAAI,CAAC,IAAD,CAAX;;AAEA,cAAI,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CAAb,IAAyB,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CAAtC,IAAkD,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CAAnE,EAA6E;AAC3E,YAAA,MAAM,GAAG,CAAC,CAAC,QAAF,GAAa,WAAtB;;AAEA,eAAG;AACD;AACD,aAFD,QAGE,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CAAb,IACA,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CADb,IAEA,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CAFb,IAGA,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CAHb,IAIA,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CAJb,IAKA,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CALb,IAMA,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CANb,IAOA,IAAI,KAAK,IAAI,CAAC,EAAE,IAAH,CAPb,IAQA,IAAI,GAAG,MAXT;;AAcA,YAAA,CAAC,CAAC,YAAF,GAAiB,WAAW,IAAI,MAAM,GAAG,IAAb,CAA5B;;AAEA,gBAAI,CAAC,CAAC,YAAF,GAAiB,CAAC,CAAC,SAAvB,EAAkC;AAChC,cAAA,CAAC,CAAC,YAAF,GAAiB,CAAC,CAAC,SAAnB;AACD;AACF,WA1B+C,CA0B9C;;AACH;AACD;;;AAEA,YAAI,CAAC,CAAC,YAAF,IAAkB,WAAtB,EAAmC;AACjC;;AAEA;AACA,UAAA,MAAM,GAAG,WAAW,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAC,YAAF,GAAiB,WAAxB,CAApB;AACA,UAAA,CAAC,CAAC,SAAF,IAAe,CAAC,CAAC,YAAjB;AACA,UAAA,CAAC,CAAC,QAAF,IAAc,CAAC,CAAC,YAAhB;AACA,UAAA,CAAC,CAAC,YAAF,GAAiB,CAAjB;AACD,SARD,MAQO;AACL;AACA;;AAEA;AACA,UAAA,MAAM,GAAG,WAAW,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAX,CAAP,CAApB;AACA,UAAA,CAAC,CAAC,SAAF;AACA,UAAA,CAAC,CAAC,QAAF;AACD;;AAED,YAAI,MAAJ,EAAY;AACV;AACA,UAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,cAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,mBAAO,YAAP;AACD;AACD;;AACD;AACF;;AAED,MAAA,CAAC,CAAC,MAAF,GAAW,CAAX;;AAEA,UAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,IAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,iBAAP;AACD;AACD;;;AAEA,eAAO,cAAP;AACD;;AAED,UAAI,CAAC,CAAC,QAAN,EAAgB;AACd;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,YAAP;AACD;AACD;;AACD;;AAED,aAAO,aAAP;AACD,KAtHD;AAuHA;;;AAGG;;;AAEH,QAAI,YAAY,GAAG,SAAS,YAAT,CAAsB,CAAtB,EAAyB,KAAzB,EAA8B;AAC/C,UAAI,MAAJ;AACA;;AAEA,eAAS;AACP;AACA,YAAI,CAAC,CAAC,SAAF,KAAgB,CAApB,EAAuB;AACrB,UAAA,WAAW,CAAC,CAAD,CAAX;;AAEA,cAAI,CAAC,CAAC,SAAF,KAAgB,CAApB,EAAuB;AACrB,gBAAI,KAAK,KAAK,UAAd,EAA0B;AACxB,qBAAO,YAAP;AACD;;AAED;AACA;AACD;AACF;AACD;;;AAEA,QAAA,CAAC,CAAC,YAAF,GAAiB,CAAjB,CAhBO,CAgBY;;AAEnB;;AAEA,QAAA,MAAM,GAAG,WAAW,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAX,CAAP,CAApB;AACA,QAAA,CAAC,CAAC,SAAF;AACA,QAAA,CAAC,CAAC,QAAF;;AAEA,YAAI,MAAJ,EAAY;AACV;AACA,UAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,cAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,mBAAO,YAAP;AACD;AACD;;AACD;AACF;;AAED,MAAA,CAAC,CAAC,MAAF,GAAW,CAAX;;AAEA,UAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,IAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,iBAAP;AACD;AACD;;;AAEA,eAAO,cAAP;AACD;;AAED,UAAI,CAAC,CAAC,QAAN,EAAgB;AACd;AACA,QAAA,gBAAgB,CAAC,CAAD,EAAI,KAAJ,CAAhB;;AAEA,YAAI,CAAC,CAAC,IAAF,CAAO,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,YAAP;AACD;AACD;;AACD;;AAED,aAAO,aAAP;AACD,KAhED;AAiEA;;;;AAIG;;;AAEH,aAAS,MAAT,CAAgB,WAAhB,EAA6B,QAA7B,EAAuC,WAAvC,EAAoD,SAApD,EAA+D,IAA/D,EAAmE;AACjE,WAAK,WAAL,GAAmB,WAAnB;AACA,WAAK,QAAL,GAAgB,QAAhB;AACA,WAAK,WAAL,GAAmB,WAAnB;AACA,WAAK,SAAL,GAAiB,SAAjB;AACA,WAAK,IAAL,GAAY,IAAZ;AACD;;AAED,QAAI,mBAAmB,GAAG;AACxB;AACA,QAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,cAAvB,CAFwB;AAGxB;AACA,QAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,YAAvB,CAJwB;AAKxB;AACA,QAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,EAAjB,EAAqB,CAArB,EAAwB,YAAxB,CANwB;AAOxB;AACA,QAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,YAAzB,CARwB;AASxB;AACA,QAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,YAAzB,CAVwB;AAWxB;AACA,QAAI,MAAJ,CAAW,CAAX,EAAc,EAAd,EAAkB,EAAlB,EAAsB,EAAtB,EAA0B,YAA1B,CAZwB;AAaxB;AACA,QAAI,MAAJ,CAAW,CAAX,EAAc,EAAd,EAAkB,GAAlB,EAAuB,GAAvB,EAA4B,YAA5B,CAdwB;AAexB;AACA,QAAI,MAAJ,CAAW,CAAX,EAAc,EAAd,EAAkB,GAAlB,EAAuB,GAAvB,EAA4B,YAA5B,CAhBwB;AAiBxB;AACA,QAAI,MAAJ,CAAW,EAAX,EAAe,GAAf,EAAoB,GAApB,EAAyB,IAAzB,EAA+B,YAA/B,CAlBwB;AAmBxB;AACA,QAAI,MAAJ,CAAW,EAAX,EAAe,GAAf,EAAoB,GAApB,EAAyB,IAAzB,EAA+B,YAA/B,CApBwB,CAA1B;AAuBA;;AAEG;;AAEH,QAAI,OAAO,GAAG,SAAS,OAAT,CAAiB,CAAjB,EAAkB;AAC9B,MAAA,CAAC,CAAC,WAAF,GAAgB,IAAI,CAAC,CAAC,MAAtB;AACA;;AAEA,MAAA,MAAM,CAAC,CAAC,CAAC,IAAH,CAAN,CAJ8B,CAIf;;AAEf;AACG;;AAEH,MAAA,CAAC,CAAC,cAAF,GAAmB,mBAAmB,CAAC,CAAC,CAAC,KAAH,CAAnB,CAA6B,QAAhD;AACA,MAAA,CAAC,CAAC,UAAF,GAAe,mBAAmB,CAAC,CAAC,CAAC,KAAH,CAAnB,CAA6B,WAA5C;AACA,MAAA,CAAC,CAAC,UAAF,GAAe,mBAAmB,CAAC,CAAC,CAAC,KAAH,CAAnB,CAA6B,WAA5C;AACA,MAAA,CAAC,CAAC,gBAAF,GAAqB,mBAAmB,CAAC,CAAC,CAAC,KAAH,CAAnB,CAA6B,SAAlD;AACA,MAAA,CAAC,CAAC,QAAF,GAAa,CAAb;AACA,MAAA,CAAC,CAAC,WAAF,GAAgB,CAAhB;AACA,MAAA,CAAC,CAAC,SAAF,GAAc,CAAd;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,CAAX;AACA,MAAA,CAAC,CAAC,YAAF,GAAiB,CAAC,CAAC,WAAF,GAAgB,WAAW,GAAG,CAA/C;AACA,MAAA,CAAC,CAAC,eAAF,GAAoB,CAApB;AACA,MAAA,CAAC,CAAC,KAAF,GAAU,CAAV;AACD,KApBD;;AAsBA,aAAS,YAAT,GAAqB;AACnB,WAAK,IAAL,GAAY,IAAZ;AACA;;AAEA,WAAK,MAAL,GAAc,CAAd;AACA;;AAEA,WAAK,WAAL,GAAmB,IAAnB;AACA;;AAEA,WAAK,gBAAL,GAAwB,CAAxB;AACA;;AAEA,WAAK,WAAL,GAAmB,CAAnB;AACA;;AAEA,WAAK,OAAL,GAAe,CAAf;AACA;;AAEA,WAAK,IAAL,GAAY,CAAZ;AACA;;AAEA,WAAK,MAAL,GAAc,IAAd;AACA;;AAEA,WAAK,OAAL,GAAe,CAAf;AACA;;AAEA,WAAK,MAAL,GAAc,UAAd;AACA;;AAEA,WAAK,UAAL,GAAkB,CAAC,CAAnB;AACA;;AAEA,WAAK,MAAL,GAAc,CAAd;AACA;;AAEA,WAAK,MAAL,GAAc,CAAd;AACA;;AAEA,WAAK,MAAL,GAAc,CAAd;AACA;;AAEA,WAAK,MAAL,GAAc,IAAd;AACA;;;;;AAKG;;AAEH,WAAK,WAAL,GAAmB,CAAnB;AACA;;AAEG;;AAEH,WAAK,IAAL,GAAY,IAAZ;AACA;;;AAGG;;AAEH,WAAK,IAAL,GAAY,IAAZ;AACA;;AAEA,WAAK,KAAL,GAAa,CAAb;AACA;;AAEA,WAAK,SAAL,GAAiB,CAAjB;AACA;;AAEA,WAAK,SAAL,GAAiB,CAAjB;AACA;;AAEA,WAAK,SAAL,GAAiB,CAAjB;AACA;;AAEA,WAAK,UAAL,GAAkB,CAAlB;AACA;;;;AAIG;;AAEH,WAAK,WAAL,GAAmB,CAAnB;AACA;;AAEG;;AAEH,WAAK,YAAL,GAAoB,CAApB;AACA;;AAEA,WAAK,UAAL,GAAkB,CAAlB;AACA;;AAEA,WAAK,eAAL,GAAuB,CAAvB;AACA;;AAEA,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA,WAAK,WAAL,GAAmB,CAAnB;AACA;;AAEA,WAAK,SAAL,GAAiB,CAAjB;AACA;;AAEA,WAAK,WAAL,GAAmB,CAAnB;AACA;;AAEG;;AAEH,WAAK,gBAAL,GAAwB,CAAxB;AACA;;;AAGG;;AAEH,WAAK,cAAL,GAAsB,CAAtB;AACA;;;AAGG;AACH;AACA;;AAEA;;;AAGG;;AAEH,WAAK,KAAL,GAAa,CAAb;AACA;;AAEA,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA,WAAK,UAAL,GAAkB,CAAlB;AACA;;AAEA,WAAK,UAAL,GAAkB,CAAlB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAK,SAAL,GAAiB,IAAI,WAAJ,CAAgB,WAAW,GAAG,CAA9B,CAAjB;AACA,WAAK,SAAL,GAAiB,IAAI,WAAJ,CAAgB,CAAC,IAAI,SAAJ,GAAgB,CAAjB,IAAsB,CAAtC,CAAjB;AACA,WAAK,OAAL,GAAe,IAAI,WAAJ,CAAgB,CAAC,IAAI,UAAJ,GAAiB,CAAlB,IAAuB,CAAvC,CAAf;AACA,MAAA,MAAM,CAAC,KAAK,SAAN,CAAN;AACA,MAAA,MAAM,CAAC,KAAK,SAAN,CAAN;AACA,MAAA,MAAM,CAAC,KAAK,OAAN,CAAN;AACA,WAAK,MAAL,GAAc,IAAd;AACA;;AAEA,WAAK,MAAL,GAAc,IAAd;AACA;;AAEA,WAAK,OAAL,GAAe,IAAf;AACA;AACA;;AAEA,WAAK,QAAL,GAAgB,IAAI,WAAJ,CAAgB,UAAU,GAAG,CAA7B,CAAhB;AACA;AACA;;AAEA,WAAK,IAAL,GAAY,IAAI,WAAJ,CAAgB,IAAI,SAAJ,GAAgB,CAAhC,CAAZ;AACA;;AAEA,MAAA,MAAM,CAAC,KAAK,IAAN,CAAN;AACA,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA;;AAEG;;AAEH,WAAK,KAAL,GAAa,IAAI,WAAJ,CAAgB,IAAI,SAAJ,GAAgB,CAAhC,CAAb,CA1LmB,CA0L6B;;AAEhD,MAAA,MAAM,CAAC,KAAK,KAAN,CAAN;AACA;AACG;;AAEH,WAAK,KAAL,GAAa,CAAb;AACA;;AAEA,WAAK,WAAL,GAAmB,CAAnB;AACA;;;;;;;;;;;;;;;;;AAiBG;;AAEH,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA,WAAK,KAAL,GAAa,CAAb;AACA;;;AAGG;;AAEH,WAAK,OAAL,GAAe,CAAf;AACA;;AAEA,WAAK,UAAL,GAAkB,CAAlB;AACA;;AAEA,WAAK,OAAL,GAAe,CAAf;AACA;;AAEA,WAAK,MAAL,GAAc,CAAd;AACA;;AAEA,WAAK,MAAL,GAAc,CAAd;AACA;;AAEG;;AAEH,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEG;AACH;AACA;AACA;;AAEA;;;;AAIG;AACJ;;AAED,QAAI,gBAAgB,GAAG,SAAS,gBAAT,CAA0B,IAA1B,EAA8B;AACnD,UAAI,CAAC,IAAD,IAAS,CAAC,IAAI,CAAC,KAAnB,EAA0B;AACxB,eAAO,GAAG,CAAC,IAAD,EAAO,cAAP,CAAV;AACD;;AAED,MAAA,IAAI,CAAC,QAAL,GAAgB,IAAI,CAAC,SAAL,GAAiB,CAAjC;AACA,MAAA,IAAI,CAAC,SAAL,GAAiB,WAAjB;AACA,UAAI,CAAC,GAAG,IAAI,CAAC,KAAb;AACA,MAAA,CAAC,CAAC,OAAF,GAAY,CAAZ;AACA,MAAA,CAAC,CAAC,WAAF,GAAgB,CAAhB;;AAEA,UAAI,CAAC,CAAC,IAAF,GAAS,CAAb,EAAgB;AACd,QAAA,CAAC,CAAC,IAAF,GAAS,CAAC,CAAC,CAAC,IAAZ;AACA;AACD;;AAED,MAAA,CAAC,CAAC,MAAF,GAAW,CAAC,CAAC,IAAF,GAAS,UAAT,GAAsB,UAAjC;AACA,MAAA,IAAI,CAAC,KAAL,GACE,CAAC,CAAC,IAAF,KAAW,CAAX,GACI,CADJ,CACM;AADN,QAEI,CAHN,CAjBmD,CAoB3C;;AAER,MAAA,CAAC,CAAC,UAAF,GAAe,UAAf;;AAEA,MAAA,UAAU,CAAC,CAAD,CAAV;;AAEA,aAAO,IAAP;AACD,KA3BD;;AA6BA,QAAI,YAAY,GAAG,SAAS,YAAT,CAAsB,IAAtB,EAA0B;AAC3C,UAAI,GAAG,GAAG,gBAAgB,CAAC,IAAD,CAA1B;;AAEA,UAAI,GAAG,KAAK,IAAZ,EAAkB;AAChB,QAAA,OAAO,CAAC,IAAI,CAAC,KAAN,CAAP;AACD;;AAED,aAAO,GAAP;AACD,KARD;;AAUA,QAAI,gBAAgB,GAAG,SAAS,gBAAT,CAA0B,IAA1B,EAAgC,IAAhC,EAAoC;AACzD,UAAI,CAAC,IAAD,IAAS,CAAC,IAAI,CAAC,KAAnB,EAA0B;AACxB,eAAO,cAAP;AACD;;AAED,UAAI,IAAI,CAAC,KAAL,CAAW,IAAX,KAAoB,CAAxB,EAA2B;AACzB,eAAO,cAAP;AACD;;AAED,MAAA,IAAI,CAAC,KAAL,CAAW,MAAX,GAAoB,IAApB;AACA,aAAO,IAAP;AACD,KAXD;;AAaA,QAAI,YAAY,GAAG,SAAS,YAAT,CAAsB,IAAtB,EAA4B,KAA5B,EAAmC,MAAnC,EAA2C,UAA3C,EAAuD,QAAvD,EAAiE,QAAjE,EAAyE;AAC1F,UAAI,CAAC,IAAL,EAAW;AACT;AACA,eAAO,cAAP;AACD;;AAED,UAAI,IAAI,GAAG,CAAX;;AAEA,UAAI,KAAK,KAAK,qBAAd,EAAqC;AACnC,QAAA,KAAK,GAAG,CAAR;AACD;;AAED,UAAI,UAAU,GAAG,CAAjB,EAAoB;AAClB;AACA,QAAA,IAAI,GAAG,CAAP;AACA,QAAA,UAAU,GAAG,CAAC,UAAd;AACD,OAJD,MAIO,IAAI,UAAU,GAAG,EAAjB,EAAqB;AAC1B,QAAA,IAAI,GAAG,CAAP;AACA;;AAEA,QAAA,UAAU,IAAI,EAAd;AACD;;AAED,UACE,QAAQ,GAAG,CAAX,IACA,QAAQ,GAAG,aADX,IAEA,MAAM,KAAK,UAFX,IAGA,UAAU,GAAG,CAHb,IAIA,UAAU,GAAG,EAJb,IAKA,KAAK,GAAG,CALR,IAMA,KAAK,GAAG,CANR,IAOA,QAAQ,GAAG,CAPX,IAQA,QAAQ,GAAG,SATb,EAUE;AACA,eAAO,GAAG,CAAC,IAAD,EAAO,cAAP,CAAV;AACD;;AAED,UAAI,UAAU,KAAK,CAAnB,EAAsB;AACpB,QAAA,UAAU,GAAG,CAAb;AACD;AACD;;;AAEA,UAAI,CAAC,GAAG,IAAI,YAAJ,EAAR;AACA,MAAA,IAAI,CAAC,KAAL,GAAa,CAAb;AACA,MAAA,CAAC,CAAC,IAAF,GAAS,IAAT;AACA,MAAA,CAAC,CAAC,IAAF,GAAS,IAAT;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,IAAX;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,KAAK,CAAC,CAAC,MAAlB;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,CAAC,CAAC,MAAF,GAAW,CAAtB;AACA,MAAA,CAAC,CAAC,SAAF,GAAc,QAAQ,GAAG,CAAzB;AACA,MAAA,CAAC,CAAC,SAAF,GAAc,KAAK,CAAC,CAAC,SAArB;AACA,MAAA,CAAC,CAAC,SAAF,GAAc,CAAC,CAAC,SAAF,GAAc,CAA5B;AACA,MAAA,CAAC,CAAC,UAAF,GAAe,CAAC,EAAE,CAAC,CAAC,CAAC,SAAF,GAAc,WAAd,GAA4B,CAA7B,IAAkC,WAApC,CAAhB;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,IAAI,UAAJ,CAAe,CAAC,CAAC,MAAF,GAAW,CAA1B,CAAX;AACA,MAAA,CAAC,CAAC,IAAF,GAAS,IAAI,WAAJ,CAAgB,CAAC,CAAC,SAAlB,CAAT;AACA,MAAA,CAAC,CAAC,IAAF,GAAS,IAAI,WAAJ,CAAgB,CAAC,CAAC,MAAlB,CAAT,CAxD0F,CAwDvD;AACnC;;AAEA,MAAA,CAAC,CAAC,WAAF,GAAgB,KAAM,QAAQ,GAAG,CAAjC;AACA;;AAEA,MAAA,CAAC,CAAC,gBAAF,GAAqB,CAAC,CAAC,WAAF,GAAgB,CAArC,CA9D0F,CA8DnD;AACvC;;AAEA,MAAA,CAAC,CAAC,WAAF,GAAgB,IAAI,UAAJ,CAAe,CAAC,CAAC,gBAAjB,CAAhB,CAjE0F,CAiEvC;AACnD;;AAEA,MAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAC,WAAhB,CApE0F,CAoE9D;;AAE5B,MAAA,CAAC,CAAC,KAAF,GAAU,CAAC,IAAI,CAAL,IAAU,CAAC,CAAC,WAAtB;AACA,MAAA,CAAC,CAAC,KAAF,GAAU,KAAV;AACA,MAAA,CAAC,CAAC,QAAF,GAAa,QAAb;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,MAAX;AACA,aAAO,YAAY,CAAC,IAAD,CAAnB;AACD,KA3ED;;AA6EA,QAAI,WAAW,GAAG,SAAS,WAAT,CAAqB,IAArB,EAA2B,KAA3B,EAAgC;AAChD,aAAO,YAAY,CAAC,IAAD,EAAO,KAAP,EAAc,UAAd,EAA0B,SAA1B,EAAqC,aAArC,EAAoD,kBAApD,CAAnB;AACD,KAFD;;AAIA,QAAI,OAAO,GAAG,SAAS,OAAT,CAAiB,IAAjB,EAAuB,KAAvB,EAA4B;AACxC,UAAI,GAAJ;AACA,UAAI,GAAJ,CAFwC,CAEhC;;AAER,UAAI,CAAC,IAAD,IAAS,CAAC,IAAI,CAAC,KAAf,IAAwB,KAAK,GAAG,OAAhC,IAA2C,KAAK,GAAG,CAAvD,EAA0D;AACxD,eAAO,IAAI,GAAG,GAAG,CAAC,IAAD,EAAO,cAAP,CAAN,GAA+B,cAA1C;AACD;;AAED,UAAI,CAAC,GAAG,IAAI,CAAC,KAAb;;AAEA,UAAI,CAAC,IAAI,CAAC,MAAN,IAAiB,CAAC,IAAI,CAAC,KAAN,IAAe,IAAI,CAAC,QAAL,KAAkB,CAAlD,IAAyD,CAAC,CAAC,MAAF,KAAa,YAAb,IAA6B,KAAK,KAAK,QAApG,EAA+G;AAC7G,eAAO,GAAG,CAAC,IAAD,EAAO,IAAI,CAAC,SAAL,KAAmB,CAAnB,GAAuB,WAAvB,GAAqC,cAA5C,CAAV;AACD;;AAED,MAAA,CAAC,CAAC,IAAF,GAAS,IAAT;AACA;;AAEA,UAAI,SAAS,GAAG,CAAC,CAAC,UAAlB;AACA,MAAA,CAAC,CAAC,UAAF,GAAe,KAAf;AACA;;AAEA,UAAI,CAAC,CAAC,MAAF,KAAa,UAAjB,EAA6B;AAC3B,YAAI,CAAC,CAAC,IAAF,KAAW,CAAf,EAAkB;AAChB;AACA,UAAA,IAAI,CAAC,KAAL,GAAa,CAAb,CAFgB,CAED;;AAEf,UAAA,QAAQ,CAAC,CAAD,EAAI,EAAJ,CAAR;AACA,UAAA,QAAQ,CAAC,CAAD,EAAI,GAAJ,CAAR;AACA,UAAA,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAR;;AAEA,cAAI,CAAC,CAAC,CAAC,MAAP,EAAe;AACb;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAJ,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAC,CAAC,KAAF,KAAY,CAAZ,GAAgB,CAAhB,GAAoB,CAAC,CAAC,QAAF,IAAc,cAAd,IAAgC,CAAC,CAAC,KAAF,GAAU,CAA1C,GAA8C,CAA9C,GAAkD,CAA1E,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,OAAJ,CAAR;AACA,YAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACD,WAVD,MAUO;AACL,YAAA,QAAQ,CACN,CADM,EAEN,CAAC,CAAC,CAAC,MAAF,CAAS,IAAT,GAAgB,CAAhB,GAAoB,CAArB,KACG,CAAC,CAAC,MAAF,CAAS,IAAT,GAAgB,CAAhB,GAAoB,CADvB,KAEG,CAAC,CAAC,CAAC,MAAF,CAAS,KAAV,GAAkB,CAAlB,GAAsB,CAFzB,KAGG,CAAC,CAAC,CAAC,MAAF,CAAS,IAAV,GAAiB,CAAjB,GAAqB,CAHxB,KAIG,CAAC,CAAC,CAAC,MAAF,CAAS,OAAV,GAAoB,CAApB,GAAwB,EAJ3B,CAFM,CAAR;AAQA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAC,CAAC,MAAF,CAAS,IAAT,GAAgB,IAApB,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAK,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,CAAlB,GAAuB,IAA3B,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAK,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,EAAlB,GAAwB,IAA5B,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAK,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,EAAlB,GAAwB,IAA5B,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAC,CAAC,KAAF,KAAY,CAAZ,GAAgB,CAAhB,GAAoB,CAAC,CAAC,QAAF,IAAc,cAAd,IAAgC,CAAC,CAAC,KAAF,GAAU,CAA1C,GAA8C,CAA9C,GAAkD,CAA1E,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAC,CAAC,MAAF,CAAS,EAAT,GAAc,IAAlB,CAAR;;AAEA,gBAAI,CAAC,CAAC,MAAF,CAAS,KAAT,IAAkB,CAAC,CAAC,MAAF,CAAS,KAAT,CAAe,MAArC,EAA6C;AAC3C,cAAA,QAAQ,CAAC,CAAD,EAAI,CAAC,CAAC,MAAF,CAAS,KAAT,CAAe,MAAf,GAAwB,IAA5B,CAAR;AACA,cAAA,QAAQ,CAAC,CAAD,EAAK,CAAC,CAAC,MAAF,CAAS,KAAT,CAAe,MAAf,IAAyB,CAA1B,GAA+B,IAAnC,CAAR;AACD;;AAED,gBAAI,CAAC,CAAC,MAAF,CAAS,IAAb,EAAmB;AACjB,cAAA,IAAI,CAAC,KAAL,GAAa,OAAO,CAAC,IAAI,CAAC,KAAN,EAAa,CAAC,CAAC,WAAf,EAA4B,CAAC,CAAC,OAA9B,EAAuC,CAAvC,CAApB;AACD;;AAED,YAAA,CAAC,CAAC,OAAF,GAAY,CAAZ;AACA,YAAA,CAAC,CAAC,MAAF,GAAW,WAAX;AACD;AACF,SA9CD,CA8CE;AA9CF,aA+CK;AACH,cAAI,MAAM,GAAI,UAAU,IAAK,CAAC,CAAC,MAAF,GAAW,CAAZ,IAAkB,CAAtB,CAAX,IAAwC,CAArD;AACA,cAAI,WAAW,GAAG,CAAC,CAAnB;;AAEA,cAAI,CAAC,CAAC,QAAF,IAAc,cAAd,IAAgC,CAAC,CAAC,KAAF,GAAU,CAA9C,EAAiD;AAC/C,YAAA,WAAW,GAAG,CAAd;AACD,WAFD,MAEO,IAAI,CAAC,CAAC,KAAF,GAAU,CAAd,EAAiB;AACtB,YAAA,WAAW,GAAG,CAAd;AACD,WAFM,MAEA,IAAI,CAAC,CAAC,KAAF,KAAY,CAAhB,EAAmB;AACxB,YAAA,WAAW,GAAG,CAAd;AACD,WAFM,MAEA;AACL,YAAA,WAAW,GAAG,CAAd;AACD;;AAED,UAAA,MAAM,IAAI,WAAW,IAAI,CAAzB;;AAEA,cAAI,CAAC,CAAC,QAAF,KAAe,CAAnB,EAAsB;AACpB,YAAA,MAAM,IAAI,WAAV;AACD;;AAED,UAAA,MAAM,IAAI,KAAM,MAAM,GAAG,EAAzB;AACA,UAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACA,UAAA,WAAW,CAAC,CAAD,EAAI,MAAJ,CAAX;AACA;;AAEA,cAAI,CAAC,CAAC,QAAF,KAAe,CAAnB,EAAsB;AACpB,YAAA,WAAW,CAAC,CAAD,EAAI,IAAI,CAAC,KAAL,KAAe,EAAnB,CAAX;AACA,YAAA,WAAW,CAAC,CAAD,EAAI,IAAI,CAAC,KAAL,GAAa,MAAjB,CAAX;AACD;;AAED,UAAA,IAAI,CAAC,KAAL,GAAa,CAAb,CA9BG,CA8BY;AAChB;AACF,OArGuC,CAqGtC;;;AAEF,UAAI,CAAC,CAAC,MAAF,KAAa,WAAjB,EAA8B;AAC5B,YACE,CAAC,CAAC,MAAF,CAAS;AACT;AAFF,UAGE;AACA,UAAA,GAAG,GAAG,CAAC,CAAC,OAAR;AACA;;AAEA,iBAAO,CAAC,CAAC,OAAF,IAAa,CAAC,CAAC,MAAF,CAAS,KAAT,CAAe,MAAf,GAAwB,MAArC,CAAP,EAAqD;AACnD,gBAAI,CAAC,CAAC,OAAF,KAAc,CAAC,CAAC,gBAApB,EAAsC;AACpC,kBAAI,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,CAAC,CAAC,OAAF,GAAY,GAAjC,EAAsC;AACpC,gBAAA,IAAI,CAAC,KAAL,GAAa,OAAO,CAAC,IAAI,CAAC,KAAN,EAAa,CAAC,CAAC,WAAf,EAA4B,CAAC,CAAC,OAAF,GAAY,GAAxC,EAA6C,GAA7C,CAApB;AACD;;AAED,cAAA,aAAa,CAAC,IAAD,CAAb;AACA,cAAA,GAAG,GAAG,CAAC,CAAC,OAAR;;AAEA,kBAAI,CAAC,CAAC,OAAF,KAAc,CAAC,CAAC,gBAApB,EAAsC;AACpC;AACD;AACF;;AAED,YAAA,QAAQ,CAAC,CAAD,EAAI,CAAC,CAAC,MAAF,CAAS,KAAT,CAAe,CAAC,CAAC,OAAjB,IAA4B,IAAhC,CAAR;AACA,YAAA,CAAC,CAAC,OAAF;AACD;;AAED,cAAI,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,CAAC,CAAC,OAAF,GAAY,GAAjC,EAAsC;AACpC,YAAA,IAAI,CAAC,KAAL,GAAa,OAAO,CAAC,IAAI,CAAC,KAAN,EAAa,CAAC,CAAC,WAAf,EAA4B,CAAC,CAAC,OAAF,GAAY,GAAxC,EAA6C,GAA7C,CAApB;AACD;;AAED,cAAI,CAAC,CAAC,OAAF,KAAc,CAAC,CAAC,MAAF,CAAS,KAAT,CAAe,MAAjC,EAAyC;AACvC,YAAA,CAAC,CAAC,OAAF,GAAY,CAAZ;AACA,YAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACD;AACF,SAjCD,MAiCO;AACL,UAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACD;AACF;;AAED,UAAI,CAAC,CAAC,MAAF,KAAa,UAAjB,EAA6B;AAC3B,YACE,CAAC,CAAC,MAAF,CAAS;AACT;AAFF,UAGE;AACA,UAAA,GAAG,GAAG,CAAC,CAAC,OAAR;AACA;AACA;;AAEA,aAAG;AACD,gBAAI,CAAC,CAAC,OAAF,KAAc,CAAC,CAAC,gBAApB,EAAsC;AACpC,kBAAI,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,CAAC,CAAC,OAAF,GAAY,GAAjC,EAAsC;AACpC,gBAAA,IAAI,CAAC,KAAL,GAAa,OAAO,CAAC,IAAI,CAAC,KAAN,EAAa,CAAC,CAAC,WAAf,EAA4B,CAAC,CAAC,OAAF,GAAY,GAAxC,EAA6C,GAA7C,CAApB;AACD;;AAED,cAAA,aAAa,CAAC,IAAD,CAAb;AACA,cAAA,GAAG,GAAG,CAAC,CAAC,OAAR;;AAEA,kBAAI,CAAC,CAAC,OAAF,KAAc,CAAC,CAAC,gBAApB,EAAsC;AACpC,gBAAA,GAAG,GAAG,CAAN;AACA;AACD;AACF,aAbA,CAaC;;;AAEF,gBAAI,CAAC,CAAC,OAAF,GAAY,CAAC,CAAC,MAAF,CAAS,IAAT,CAAc,MAA9B,EAAsC;AACpC,cAAA,GAAG,GAAG,CAAC,CAAC,MAAF,CAAS,IAAT,CAAc,UAAd,CAAyB,CAAC,CAAC,OAAF,EAAzB,IAAwC,IAA9C;AACD,aAFD,MAEO;AACL,cAAA,GAAG,GAAG,CAAN;AACD;;AAED,YAAA,QAAQ,CAAC,CAAD,EAAI,GAAJ,CAAR;AACD,WAtBD,QAsBS,GAAG,KAAK,CAtBjB;;AAwBA,cAAI,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,CAAC,CAAC,OAAF,GAAY,GAAjC,EAAsC;AACpC,YAAA,IAAI,CAAC,KAAL,GAAa,OAAO,CAAC,IAAI,CAAC,KAAN,EAAa,CAAC,CAAC,WAAf,EAA4B,CAAC,CAAC,OAAF,GAAY,GAAxC,EAA6C,GAA7C,CAApB;AACD;;AAED,cAAI,GAAG,KAAK,CAAZ,EAAe;AACb,YAAA,CAAC,CAAC,OAAF,GAAY,CAAZ;AACA,YAAA,CAAC,CAAC,MAAF,GAAW,aAAX;AACD;AACF,SAxCD,MAwCO;AACL,UAAA,CAAC,CAAC,MAAF,GAAW,aAAX;AACD;AACF;;AAED,UAAI,CAAC,CAAC,MAAF,KAAa,aAAjB,EAAgC;AAC9B,YACE,CAAC,CAAC,MAAF,CAAS;AACT;AAFF,UAGE;AACA,UAAA,GAAG,GAAG,CAAC,CAAC,OAAR;AACA;AACA;;AAEA,aAAG;AACD,gBAAI,CAAC,CAAC,OAAF,KAAc,CAAC,CAAC,gBAApB,EAAsC;AACpC,kBAAI,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,CAAC,CAAC,OAAF,GAAY,GAAjC,EAAsC;AACpC,gBAAA,IAAI,CAAC,KAAL,GAAa,OAAO,CAAC,IAAI,CAAC,KAAN,EAAa,CAAC,CAAC,WAAf,EAA4B,CAAC,CAAC,OAAF,GAAY,GAAxC,EAA6C,GAA7C,CAApB;AACD;;AAED,cAAA,aAAa,CAAC,IAAD,CAAb;AACA,cAAA,GAAG,GAAG,CAAC,CAAC,OAAR;;AAEA,kBAAI,CAAC,CAAC,OAAF,KAAc,CAAC,CAAC,gBAApB,EAAsC;AACpC,gBAAA,GAAG,GAAG,CAAN;AACA;AACD;AACF,aAbA,CAaC;;;AAEF,gBAAI,CAAC,CAAC,OAAF,GAAY,CAAC,CAAC,MAAF,CAAS,OAAT,CAAiB,MAAjC,EAAyC;AACvC,cAAA,GAAG,GAAG,CAAC,CAAC,MAAF,CAAS,OAAT,CAAiB,UAAjB,CAA4B,CAAC,CAAC,OAAF,EAA5B,IAA2C,IAAjD;AACD,aAFD,MAEO;AACL,cAAA,GAAG,GAAG,CAAN;AACD;;AAED,YAAA,QAAQ,CAAC,CAAD,EAAI,GAAJ,CAAR;AACD,WAtBD,QAsBS,GAAG,KAAK,CAtBjB;;AAwBA,cAAI,CAAC,CAAC,MAAF,CAAS,IAAT,IAAiB,CAAC,CAAC,OAAF,GAAY,GAAjC,EAAsC;AACpC,YAAA,IAAI,CAAC,KAAL,GAAa,OAAO,CAAC,IAAI,CAAC,KAAN,EAAa,CAAC,CAAC,WAAf,EAA4B,CAAC,CAAC,OAAF,GAAY,GAAxC,EAA6C,GAA7C,CAApB;AACD;;AAED,cAAI,GAAG,KAAK,CAAZ,EAAe;AACb,YAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACD;AACF,SAvCD,MAuCO;AACL,UAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACD;AACF;;AAED,UAAI,CAAC,CAAC,MAAF,KAAa,UAAjB,EAA6B;AAC3B,YAAI,CAAC,CAAC,MAAF,CAAS,IAAb,EAAmB;AACjB,cAAI,CAAC,CAAC,OAAF,GAAY,CAAZ,GAAgB,CAAC,CAAC,gBAAtB,EAAwC;AACtC,YAAA,aAAa,CAAC,IAAD,CAAb;AACD;;AAED,cAAI,CAAC,CAAC,OAAF,GAAY,CAAZ,IAAiB,CAAC,CAAC,gBAAvB,EAAyC;AACvC,YAAA,QAAQ,CAAC,CAAD,EAAI,IAAI,CAAC,KAAL,GAAa,IAAjB,CAAR;AACA,YAAA,QAAQ,CAAC,CAAD,EAAK,IAAI,CAAC,KAAL,IAAc,CAAf,GAAoB,IAAxB,CAAR;AACA,YAAA,IAAI,CAAC,KAAL,GAAa,CAAb,CAHuC,CAGxB;;AAEf,YAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACD;AACF,SAZD,MAYO;AACL,UAAA,CAAC,CAAC,MAAF,GAAW,UAAX;AACD;AACF,OAzPuC,CAyPtC;;AAEF;;;AAEA,UAAI,CAAC,CAAC,OAAF,KAAc,CAAlB,EAAqB;AACnB,QAAA,aAAa,CAAC,IAAD,CAAb;;AAEA,YAAI,IAAI,CAAC,SAAL,KAAmB,CAAvB,EAA0B;AACxB;;;;;AAKG;AACH,UAAA,CAAC,CAAC,UAAF,GAAe,CAAC,CAAhB;AACA,iBAAO,IAAP;AACD;AACD;;;AAGG;;AACJ,OAjBD,MAiBO,IAAI,IAAI,CAAC,QAAL,KAAkB,CAAlB,IAAuB,IAAI,CAAC,KAAD,CAAJ,IAAe,IAAI,CAAC,SAAD,CAA1C,IAAyD,KAAK,KAAK,QAAvE,EAAiF;AACtF,eAAO,GAAG,CAAC,IAAD,EAAO,WAAP,CAAV;AACD;AACD;;;AAEA,UAAI,CAAC,CAAC,MAAF,KAAa,YAAb,IAA6B,IAAI,CAAC,QAAL,KAAkB,CAAnD,EAAsD;AACpD,eAAO,GAAG,CAAC,IAAD,EAAO,WAAP,CAAV;AACD;AACD;AACG;;;AAEH,UAAI,IAAI,CAAC,QAAL,KAAkB,CAAlB,IAAuB,CAAC,CAAC,SAAF,KAAgB,CAAvC,IAA6C,KAAK,KAAK,UAAV,IAAwB,CAAC,CAAC,MAAF,KAAa,YAAtF,EAAqG;AACnG,YAAI,MAAM,GACR,CAAC,CAAC,QAAF,KAAe,cAAf,GACI,YAAY,CAAC,CAAD,EAAI,KAAJ,CADhB,GAEI,CAAC,CAAC,QAAF,KAAe,KAAf,GACA,WAAW,CAAC,CAAD,EAAI,KAAJ,CADX,GAEA,mBAAmB,CAAC,CAAC,CAAC,KAAH,CAAnB,CAA6B,IAA7B,CAAkC,CAAlC,EAAqC,KAArC,CALN;;AAOA,YAAI,MAAM,KAAK,iBAAX,IAAgC,MAAM,KAAK,cAA/C,EAA+D;AAC7D,UAAA,CAAC,CAAC,MAAF,GAAW,YAAX;AACD;;AAED,YAAI,MAAM,KAAK,YAAX,IAA2B,MAAM,KAAK,iBAA1C,EAA6D;AAC3D,cAAI,IAAI,CAAC,SAAL,KAAmB,CAAvB,EAA0B;AACxB,YAAA,CAAC,CAAC,UAAF,GAAe,CAAC,CAAhB;AACA;AACD;;AAED,iBAAO,IAAP;AACA;;;;;;AAMG;AACJ;;AAED,YAAI,MAAM,KAAK,aAAf,EAA8B;AAC5B,cAAI,KAAK,KAAK,eAAd,EAA+B;AAC7B,YAAA,WAAW,CAAC,CAAD,CAAX;AACD,WAFD,MAEO,IAAI,KAAK,KAAK,OAAd,EAAuB;AAC5B;AACA,YAAA,kBAAkB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,KAAV,CAAlB;AACA;;AAEG;;;AAEH,gBAAI,KAAK,KAAK,YAAd,EAA4B;AAC1B;;AAEA;AACA,cAAA,MAAM,CAAC,CAAC,CAAC,IAAH,CAAN,CAJ0B,CAIX;;AAEf,kBAAI,CAAC,CAAC,SAAF,KAAgB,CAApB,EAAuB;AACrB,gBAAA,CAAC,CAAC,QAAF,GAAa,CAAb;AACA,gBAAA,CAAC,CAAC,WAAF,GAAgB,CAAhB;AACA,gBAAA,CAAC,CAAC,MAAF,GAAW,CAAX;AACD;AACF;AACF;;AAED,UAAA,aAAa,CAAC,IAAD,CAAb;;AAEA,cAAI,IAAI,CAAC,SAAL,KAAmB,CAAvB,EAA0B;AACxB,YAAA,CAAC,CAAC,UAAF,GAAe,CAAC,CAAhB;AACA;;AAEA,mBAAO,IAAP;AACD;AACF;AACF,OAtVuC,CAsVtC;AACF;;;AAEA,UAAI,KAAK,KAAK,QAAd,EAAwB;AACtB,eAAO,IAAP;AACD;;AAED,UAAI,CAAC,CAAC,IAAF,IAAU,CAAd,EAAiB;AACf,eAAO,YAAP;AACD;AACD;;;AAEA,UAAI,CAAC,CAAC,IAAF,KAAW,CAAf,EAAkB;AAChB,QAAA,QAAQ,CAAC,CAAD,EAAI,IAAI,CAAC,KAAL,GAAa,IAAjB,CAAR;AACA,QAAA,QAAQ,CAAC,CAAD,EAAK,IAAI,CAAC,KAAL,IAAc,CAAf,GAAoB,IAAxB,CAAR;AACA,QAAA,QAAQ,CAAC,CAAD,EAAK,IAAI,CAAC,KAAL,IAAc,EAAf,GAAqB,IAAzB,CAAR;AACA,QAAA,QAAQ,CAAC,CAAD,EAAK,IAAI,CAAC,KAAL,IAAc,EAAf,GAAqB,IAAzB,CAAR;AACA,QAAA,QAAQ,CAAC,CAAD,EAAI,IAAI,CAAC,QAAL,GAAgB,IAApB,CAAR;AACA,QAAA,QAAQ,CAAC,CAAD,EAAK,IAAI,CAAC,QAAL,IAAiB,CAAlB,GAAuB,IAA3B,CAAR;AACA,QAAA,QAAQ,CAAC,CAAD,EAAK,IAAI,CAAC,QAAL,IAAiB,EAAlB,GAAwB,IAA5B,CAAR;AACA,QAAA,QAAQ,CAAC,CAAD,EAAK,IAAI,CAAC,QAAL,IAAiB,EAAlB,GAAwB,IAA5B,CAAR;AACD,OATD,MASO;AACL,QAAA,WAAW,CAAC,CAAD,EAAI,IAAI,CAAC,KAAL,KAAe,EAAnB,CAAX;AACA,QAAA,WAAW,CAAC,CAAD,EAAI,IAAI,CAAC,KAAL,GAAa,MAAjB,CAAX;AACD;;AAED,MAAA,aAAa,CAAC,IAAD,CAAb;AACA;;AAEG;;AAEH,UAAI,CAAC,CAAC,IAAF,GAAS,CAAb,EAAgB;AACd,QAAA,CAAC,CAAC,IAAF,GAAS,CAAC,CAAC,CAAC,IAAZ;AACD;AACD;;;AAEA,aAAO,CAAC,CAAC,OAAF,KAAc,CAAd,GAAkB,IAAlB,GAAyB,YAAhC;AACD,KA3XD;;AA6XA,QAAI,UAAU,GAAG,SAAS,UAAT,CAAoB,IAApB,EAAwB;AACvC,UACE,CAAC,IAAD;AACA;AACA,OAAC,IAAI,CAAC;AACN;AAJF,QAKE;AACA,eAAO,cAAP;AACD;;AAED,UAAI,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,MAAxB;;AAEA,UACE,MAAM,KAAK,UAAX,IACA,MAAM,KAAK,WADX,IAEA,MAAM,KAAK,UAFX,IAGA,MAAM,KAAK,aAHX,IAIA,MAAM,KAAK,UAJX,IAKA,MAAM,KAAK,UALX,IAMA,MAAM,KAAK,YAPb,EAQE;AACA,eAAO,GAAG,CAAC,IAAD,EAAO,cAAP,CAAV;AACD;;AAED,MAAA,IAAI,CAAC,KAAL,GAAa,IAAb;AACA,aAAO,MAAM,KAAK,UAAX,GAAwB,GAAG,CAAC,IAAD,EAAO,YAAP,CAA3B,GAAkD,IAAzD;AACD,KA1BD;AA2BA;;;AAGG;;;AAEH,QAAI,oBAAoB,GAAG,SAAS,oBAAT,CAA8B,IAA9B,EAAoC,UAApC,EAA8C;AACvE,UAAI,UAAU,GAAG,UAAU,CAAC,MAA5B;;AAEA,UACE,CAAC,IAAD;AACA;AACA,OAAC,IAAI,CAAC;AACN;AAJF,QAKE;AACA,eAAO,cAAP;AACD;;AAED,UAAI,CAAC,GAAG,IAAI,CAAC,KAAb;AACA,UAAI,IAAI,GAAG,CAAC,CAAC,IAAb;;AAEA,UAAI,IAAI,KAAK,CAAT,IAAe,IAAI,KAAK,CAAT,IAAc,CAAC,CAAC,MAAF,KAAa,UAA1C,IAAyD,CAAC,CAAC,SAA/D,EAA0E;AACxE,eAAO,cAAP;AACD;AACD;;;AAEA,UAAI,IAAI,KAAK,CAAb,EAAgB;AACd;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,SAAS,CAAC,IAAI,CAAC,KAAN,EAAa,UAAb,EAAyB,UAAzB,EAAqC,CAArC,CAAtB;AACD;;AAED,MAAA,CAAC,CAAC,IAAF,GAAS,CAAT;AACA;;AAEA;;AAEA,UAAI,UAAU,IAAI,CAAC,CAAC,MAApB,EAA4B;AAC1B,YAAI,IAAI,KAAK,CAAb,EAAgB;AACd;;AAEA;AACA,UAAA,MAAM,CAAC,CAAC,CAAC,IAAH,CAAN,CAJc,CAIC;;AAEf,UAAA,CAAC,CAAC,QAAF,GAAa,CAAb;AACA,UAAA,CAAC,CAAC,WAAF,GAAgB,CAAhB;AACA,UAAA,CAAC,CAAC,MAAF,GAAW,CAAX;AACD;AACD;AACA;;;AAEA,YAAI,OAAO,GAAG,IAAI,UAAJ,CAAe,CAAC,CAAC,MAAjB,CAAd;AACA,QAAA,OAAO,CAAC,GAAR,CAAY,UAAU,CAAC,QAAX,CAAoB,UAAU,GAAG,CAAC,CAAC,MAAnC,EAA2C,UAA3C,CAAZ,EAAoE,CAApE;AACA,QAAA,UAAU,GAAG,OAAb;AACA,QAAA,UAAU,GAAG,CAAC,CAAC,MAAf;AACD;AACD;;;AAEA,UAAI,KAAK,GAAG,IAAI,CAAC,QAAjB;AACA,UAAI,IAAI,GAAG,IAAI,CAAC,OAAhB;AACA,UAAI,KAAK,GAAG,IAAI,CAAC,KAAjB;AACA,MAAA,IAAI,CAAC,QAAL,GAAgB,UAAhB;AACA,MAAA,IAAI,CAAC,OAAL,GAAe,CAAf;AACA,MAAA,IAAI,CAAC,KAAL,GAAa,UAAb;AACA,MAAA,WAAW,CAAC,CAAD,CAAX;;AAEA,aAAO,CAAC,CAAC,SAAF,IAAe,WAAtB,EAAmC;AACjC,YAAI,GAAG,GAAG,CAAC,CAAC,QAAZ;AACA,YAAI,CAAC,GAAG,CAAC,CAAC,SAAF,IAAe,WAAW,GAAG,CAA7B,CAAR;;AAEA,WAAG;AACD;AACA,UAAA,CAAC,CAAC,KAAF,GAAU,IAAI,CAAC,CAAD,EAAI,CAAC,CAAC,KAAN,EAAa,CAAC,CAAC,MAAF,CAAS,GAAG,GAAG,WAAN,GAAoB,CAA7B,CAAb,CAAd;AACA,UAAA,CAAC,CAAC,IAAF,CAAO,GAAG,GAAG,CAAC,CAAC,MAAf,IAAyB,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,CAAzB;AACA,UAAA,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAT,IAAkB,GAAlB;AACA,UAAA,GAAG;AACJ,SAND,QAMS,EAAE,CANX;;AAQA,QAAA,CAAC,CAAC,QAAF,GAAa,GAAb;AACA,QAAA,CAAC,CAAC,SAAF,GAAc,WAAW,GAAG,CAA5B;AACA,QAAA,WAAW,CAAC,CAAD,CAAX;AACD;;AAED,MAAA,CAAC,CAAC,QAAF,IAAc,CAAC,CAAC,SAAhB;AACA,MAAA,CAAC,CAAC,WAAF,GAAgB,CAAC,CAAC,QAAlB;AACA,MAAA,CAAC,CAAC,MAAF,GAAW,CAAC,CAAC,SAAb;AACA,MAAA,CAAC,CAAC,SAAF,GAAc,CAAd;AACA,MAAA,CAAC,CAAC,YAAF,GAAiB,CAAC,CAAC,WAAF,GAAgB,WAAW,GAAG,CAA/C;AACA,MAAA,CAAC,CAAC,eAAF,GAAoB,CAApB;AACA,MAAA,IAAI,CAAC,OAAL,GAAe,IAAf;AACA,MAAA,IAAI,CAAC,KAAL,GAAa,KAAb;AACA,MAAA,IAAI,CAAC,QAAL,GAAgB,KAAhB;AACA,MAAA,CAAC,CAAC,IAAF,GAAS,IAAT;AACA,aAAO,IAAP;AACD,KAvFD;;AAyFA,QAAI,aAAa,GAAG,WAApB;AACA,QAAI,cAAc,GAAG,YAArB;AACA,QAAI,cAAc,GAAG,YAArB;AACA,QAAI,kBAAkB,GAAG,gBAAzB;AACA,QAAI,kBAAkB,GAAG,gBAAzB;AACA,QAAI,SAAS,GAAG,OAAhB;AACA,QAAI,YAAY,GAAG,UAAnB;AACA,QAAI,sBAAsB,GAAG,oBAA7B;AACA,QAAI,WAAW,GAAG,oCAAlB;AACA;;;;;;;AAOA;;AAEA,QAAI,SAAS,GAAG;AACd,MAAA,WAAW,EAAE,aADC;AAEd,MAAA,YAAY,EAAE,cAFA;AAGd,MAAA,YAAY,EAAE,cAHA;AAId,MAAA,gBAAgB,EAAE,kBAJJ;AAKd,MAAA,gBAAgB,EAAE,kBALJ;AAMd,MAAA,OAAO,EAAE,SANK;AAOd,MAAA,UAAU,EAAE,YAPE;AAQd,MAAA,oBAAoB,EAAE,sBARR;AASd,MAAA,WAAW,EAAA;AATG,KAAhB;;AAYA,aAAS,OAAT,CAAiB,GAAjB,EAAoB;AAClB;;AAEA,UAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,MAAM,CAAC,QAAd,KAA2B,QAA/D,EAAyE;AACvE,QAAA,OAAO,GAAG,UAAU,GAAV,EAAa;AACrB,iBAAO,OAAO,GAAd;AACD,SAFD;AAGD,OAJD,MAIO;AACL,QAAA,OAAO,GAAG,UAAU,GAAV,EAAa;AACrB,iBAAO,GAAG,IAAI,OAAO,MAAP,KAAkB,UAAzB,IAAuC,GAAG,CAAC,WAAJ,KAAoB,MAA3D,IAAqE,GAAG,KAAK,MAAM,CAAC,SAApF,GACH,QADG,GAEH,OAAO,GAFX;AAGD,SAJD;AAKD;;AAED,aAAO,OAAO,CAAC,GAAD,CAAd;AACD;;AAED,QAAI,IAAI,GAAG,SAAS,IAAT,CAAc,GAAd,EAAmB,GAAnB,EAAsB;AAC/B,aAAO,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,GAArC,EAA0C,GAA1C,CAAP;AACD,KAFD;;AAIA,QAAI,MAAM,GAAG,SAAS,MAAT,CACX;AACA;AAFW,M;AAIX,UAAI,OAAO,GAAG,KAAK,CAAC,SAAN,CAAgB,KAAhB,CAAsB,IAAtB,CAA2B,SAA3B,EAAsC,CAAtC,CAAd;;AAEA,aAAO,OAAO,CAAC,MAAf,EAAuB;AACrB,YAAI,MAAM,GAAG,OAAO,CAAC,KAAR,EAAb;;AAEA,YAAI,CAAC,MAAL,EAAa;AACX;AACD;;AAED,YAAI,OAAO,CAAC,MAAD,CAAP,KAAoB,QAAxB,EAAkC;AAChC,gBAAM,IAAI,SAAJ,CAAiB,MAAM,GAAA,oBAAvB,CAAN;AACD;;AAED,aAAK,IAAI,CAAT,IAAc,MAAd,EAAsB;AACpB,cAAI,IAAI,CAAC,MAAD,EAAS,CAAT,CAAR,EAAqB;AACnB,YAAA,GAAG,CAAC,CAAD,CAAH,GAAS,MAAM,CAAC,CAAD,CAAf;AACD;AACF;AACF;;AAED,aAAO,GAAP;AACD,KAzBD,CA9xHsB,CAuzHpB;;;AAEF,QAAI,aAAa,GAAG,SAAS,aAAT,CAAuB,MAAvB,EAA6B;AAC/C;AACA,UAAI,GAAG,GAAG,CAAV;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,GAAG,CAAvC,EAA0C,CAAC,EAA3C,EAA+C;AAC7C,QAAA,GAAG,IAAI,MAAM,CAAC,CAAD,CAAN,CAAU,MAAjB;AACD,OAN8C,CAM7C;;;AAEF,UAAI,MAAM,GAAG,IAAI,UAAJ,CAAe,GAAf,CAAb;;AAEA,WAAK,IAAI,EAAE,GAAG,CAAT,EAAY,GAAG,GAAG,CAAlB,EAAqB,EAAE,GAAG,MAAM,CAAC,MAAtC,EAA8C,EAAE,GAAG,EAAnD,EAAuD,EAAE,EAAzD,EAA6D;AAC3D,YAAI,KAAK,GAAG,MAAM,CAAC,EAAD,CAAlB;AACA,QAAA,MAAM,CAAC,GAAP,CAAW,KAAX,EAAkB,GAAlB;AACA,QAAA,GAAG,IAAI,KAAK,CAAC,MAAb;AACD;;AAED,aAAO,MAAP;AACD,KAjBD;;AAmBA,QAAI,MAAM,GAAG;AACX,MAAA,MAAM,EAAA,MADK;AAEX,MAAA,aAAa,EAAA;AAFF,KAAb,CA50HsB,CAi1HtB;AACA;AACA;AACA;AACA;;AAEA,QAAI,gBAAgB,GAAG,IAAvB;;AAEA,QAAI;AACF,MAAA,MAAM,CAAC,YAAP,CAAoB,KAApB,CAA0B,IAA1B,EAAgC,IAAI,UAAJ,CAAe,CAAf,CAAhC;AACD,KAFD,CAEE,OAAO,EAAP,EAAW;AACX,MAAA,gBAAgB,GAAG,KAAnB;AACD,KA71HqB,CA61HpB;AACF;AACA;;;AAEA,QAAI,QAAQ,GAAG,IAAI,UAAJ,CAAe,GAAf,CAAf;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,MAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAC,IAAI,GAAL,GAAW,CAAX,GAAe,CAAC,IAAI,GAAL,GAAW,CAAX,GAAe,CAAC,IAAI,GAAL,GAAW,CAAX,GAAe,CAAC,IAAI,GAAL,GAAW,CAAX,GAAe,CAAC,IAAI,GAAL,GAAW,CAAX,GAAe,CAAzF;AACD;;AAED,IAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,QAAQ,CAAC,GAAD,CAAR,GAAgB,CAAhC,CAv2HsB,CAu2HY;AAClC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAS,OAAT,GAAgB;AACd;AACA,WAAK,KAAL,GAAa,IAAb,CAFc,CAEI;;AAElB,WAAK,OAAL,GAAe,CAAf;AACA;;AAEA,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA,WAAK,MAAL,GAAc,IAAd,CAbc,CAaK;;AAEnB,WAAK,QAAL,GAAgB,CAAhB;AACA;;AAEA,WAAK,SAAL,GAAiB,CAAjB;AACA;;AAEA,WAAK,SAAL,GAAiB,CAAjB;AACA;;AAEA,WAAK,GAAL,GAAW,EAAX;AACA;;AACA;;AAEA,WAAK,KAAL,GAAa,IAAb;AACA;;AAEA,WAAK,SAAL,GAAiB,CAAjB;AACA;;AACA;;AAEA,WAAK,KAAL,GAAa,CAAb;AACD;;AAED,QAAI,OAAO,GAAG,OAAd,CAl6HsB,CAo6HtB;;AACA,QAAI,QAAQ,GAAG,MAAM,CAAC,SAAP,CAAiB,QAAhC;AACA;;AAEA;;AAEA,QAAI,YAAY,GAAG,SAAS,CAAC,UAA7B;AACA,QAAI,YAAY,GAAG,SAAS,CAAC,YAA7B;AACA,QAAI,cAAc,GAAG,SAAS,CAAC,YAA/B;AACA,QAAI,UAAU,GAAG,SAAS,CAAC,QAA3B;AACA,QAAI,MAAM,GAAG,SAAS,CAAC,IAAvB;AACA,QAAI,cAAc,GAAG,SAAS,CAAC,YAA/B;AACA,QAAI,uBAAuB,GAAG,SAAS,CAAC,qBAAxC;AACA,QAAI,oBAAoB,GAAG,SAAS,CAAC,kBAArC;AACA,QAAI,YAAY,GAAG,SAAS,CAAC,UAA7B;AACA;;AAEA;;;;;;AAMK;;AAEL;;;;AAIK;;AAEL;;;;;;AAMK;;AAEL;;;;;;;AAOK;;AAEL;;;;AAIK;;AAEL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CK;;AAEL,aAAS,OAAT,CAAiB,OAAjB,EAAwB;AACtB,WAAK,OAAL,GAAe,MAAM,CAAC,MAAP,CACb;AACE,QAAA,KAAK,EAAE,uBADT;AAEE,QAAA,MAAM,EAAE,YAFV;AAGE,QAAA,SAAS,EAAE,KAHb;AAIE,QAAA,UAAU,EAAE,EAJd;AAKE,QAAA,QAAQ,EAAE,CALZ;AAME,QAAA,QAAQ,EAAE;AANZ,OADa,EASb,OAAO,IAAI,EATE,CAAf;AAWA,UAAI,GAAG,GAAG,KAAK,OAAf;;AAEA,UAAI,GAAG,CAAC,GAAJ,IAAW,GAAG,CAAC,UAAJ,GAAiB,CAAhC,EAAmC;AACjC,QAAA,GAAG,CAAC,UAAJ,GAAiB,CAAC,GAAG,CAAC,UAAtB;AACD,OAFD,MAEO,IAAI,GAAG,CAAC,IAAJ,IAAY,GAAG,CAAC,UAAJ,GAAiB,CAA7B,IAAkC,GAAG,CAAC,UAAJ,GAAiB,EAAvD,EAA2D;AAChE,QAAA,GAAG,CAAC,UAAJ,IAAkB,EAAlB;AACD;;AAED,WAAK,GAAL,GAAW,CAAX,CApBsB,CAoBT;;AAEb,WAAK,GAAL,GAAW,EAAX,CAtBsB,CAsBR;;AAEd,WAAK,KAAL,GAAa,KAAb,CAxBsB,CAwBH;;AAEnB,WAAK,MAAL,GAAc,EAAd,CA1BsB,CA0BL;;AAEjB,WAAK,IAAL,GAAY,IAAI,OAAJ,EAAZ;AACA,WAAK,IAAL,CAAU,SAAV,GAAsB,CAAtB;AACA,UAAI,MAAM,GAAG,SAAS,CAAC,YAAV,CAAuB,KAAK,IAA5B,EAAkC,GAAG,CAAC,KAAtC,EAA6C,GAAG,CAAC,MAAjD,EAAyD,GAAG,CAAC,UAA7D,EAAyE,GAAG,CAAC,QAA7E,EAAuF,GAAG,CAAC,QAA3F,CAAb;;AAEA,UAAI,MAAM,KAAK,MAAf,EAAuB;AACrB,cAAM,IAAI,KAAJ,CAAU,QAAQ,CAAC,MAAD,CAAlB,CAAN;AACD;;AAED,UAAI,GAAG,CAAC,MAAR,EAAgB;AACd,QAAA,SAAS,CAAC,gBAAV,CAA2B,KAAK,IAAhC,EAAsC,GAAG,CAAC,MAA1C;AACD;;AAED,UAAI,GAAG,CAAC,UAAR,EAAoB;AAClB,YAAI,IAAJ,CADkB,CACT;;AAET,YAAI,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,UAAlB,MAAkC,sBAAtC,EAA8D;AAC5D,UAAA,IAAI,GAAG,IAAI,UAAJ,CAAe,GAAG,CAAC,UAAnB,CAAP;AACD,SAFD,MAEO;AACL,UAAA,IAAI,GAAG,GAAG,CAAC,UAAX;AACD;;AAED,QAAA,MAAM,GAAG,SAAS,CAAC,oBAAV,CAA+B,KAAK,IAApC,EAA0C,IAA1C,CAAT;;AAEA,YAAI,MAAM,KAAK,MAAf,EAAuB;AACrB,gBAAM,IAAI,KAAJ,CAAU,QAAQ,CAAC,MAAD,CAAlB,CAAN;AACD;;AAED,aAAK,SAAL,GAAiB,IAAjB;AACD;AACF;AACD;;;;;;;;;;;;;;;;;;;;;AAqBK;;;AAEL,IAAA,OAAO,CAAC,SAAR,CAAkB,IAAlB,GAAyB,UAAU,IAAV,EAAgB,UAAhB,EAA0B;AACjD,UAAI,IAAI,GAAG,KAAK,IAAhB;AACA,UAAI,SAAS,GAAG,KAAK,OAAL,CAAa,SAA7B;AAEA,UAAI,MAAJ;;AACA,UAAI,WAAJ;;AAEA,UAAI,KAAK,KAAT,EAAgB;AACd,eAAO,KAAP;AACD;;AAED,UAAI,UAAU,KAAK,CAAC,CAAC,UAArB,EAAiC;AAC/B,QAAA,WAAW,GAAG,UAAd;AACD,OAFD,MAEO;AACL,QAAA,WAAW,GAAG,UAAU,KAAK,IAAf,GAAsB,UAAtB,GAAmC,YAAjD;AACD,OAfgD,CAe/C;;;AAEF,UAAI,QAAQ,CAAC,IAAT,CAAc,IAAd,MAAwB,sBAA5B,EAAoD;AAClD,QAAA,IAAI,CAAC,KAAL,GAAa,IAAI,UAAJ,CAAe,IAAf,CAAb;AACD,OAFD,MAEO;AACL,QAAA,IAAI,CAAC,KAAL,GAAa,IAAb;AACD;;AAED,MAAA,IAAI,CAAC,OAAL,GAAe,CAAf;AACA,MAAA,IAAI,CAAC,QAAL,GAAgB,IAAI,CAAC,KAAL,CAAW,MAA3B;;AAEA,eAAS;AACP,YAAI,IAAI,CAAC,SAAL,KAAmB,CAAvB,EAA0B;AACxB,UAAA,IAAI,CAAC,MAAL,GAAc,IAAI,UAAJ,CAAe,SAAf,CAAd;AACA,UAAA,IAAI,CAAC,QAAL,GAAgB,CAAhB;AACA,UAAA,IAAI,CAAC,SAAL,GAAiB,SAAjB;AACD,SALM,CAKL;;;AAEF,YAAI,CAAC,WAAW,KAAK,YAAhB,IAAgC,WAAW,KAAK,cAAjD,KAAoE,IAAI,CAAC,SAAL,IAAkB,CAA1F,EAA6F;AAC3F,eAAK,MAAL,CAAY,IAAI,CAAC,MAAL,CAAY,QAAZ,CAAqB,CAArB,EAAwB,IAAI,CAAC,QAA7B,CAAZ;AACA,UAAA,IAAI,CAAC,SAAL,GAAiB,CAAjB;AACA;AACD;;AAED,QAAA,MAAM,GAAG,SAAS,CAAC,OAAV,CAAkB,IAAlB,EAAwB,WAAxB,CAAT,CAbO,CAauC;;AAE9C,YAAI,MAAM,KAAK,cAAf,EAA+B;AAC7B,cAAI,IAAI,CAAC,QAAL,GAAgB,CAApB,EAAuB;AACrB,iBAAK,MAAL,CAAY,IAAI,CAAC,MAAL,CAAY,QAAZ,CAAqB,CAArB,EAAwB,IAAI,CAAC,QAA7B,CAAZ;AACD;;AAED,UAAA,MAAM,GAAG,SAAS,CAAC,UAAV,CAAqB,KAAK,IAA1B,CAAT;AACA,eAAK,KAAL,CAAW,MAAX;AACA,eAAK,KAAL,GAAa,IAAb;AACA,iBAAO,MAAM,KAAK,MAAlB;AACD,SAxBM,CAwBL;;;AAEF,YAAI,IAAI,CAAC,SAAL,KAAmB,CAAvB,EAA0B;AACxB,eAAK,MAAL,CAAY,IAAI,CAAC,MAAjB;AACA;AACD,SA7BM,CA6BL;;;AAEF,YAAI,WAAW,GAAG,CAAd,IAAmB,IAAI,CAAC,QAAL,GAAgB,CAAvC,EAA0C;AACxC,eAAK,MAAL,CAAY,IAAI,CAAC,MAAL,CAAY,QAAZ,CAAqB,CAArB,EAAwB,IAAI,CAAC,QAA7B,CAAZ;AACA,UAAA,IAAI,CAAC,SAAL,GAAiB,CAAjB;AACA;AACD;;AAED,YAAI,IAAI,CAAC,QAAL,KAAkB,CAAtB,EAAyB;AACvB;AACD;AACF;;AAED,aAAO,IAAP;AACD,KArED;AAsEA;;;;;;AAMK;;;AAEL,IAAA,OAAO,CAAC,SAAR,CAAkB,MAAlB,GAA2B,UAAU,KAAV,EAAe;AACxC,WAAK,MAAL,CAAY,IAAZ,CAAiB,KAAjB;AACD,KAFD;AAGA;;;;;;;;AAQK;;;AAEL,IAAA,OAAO,CAAC,SAAR,CAAkB,KAAlB,GAA0B,UAAU,MAAV,EAAgB;AACxC;AACA,UAAI,MAAM,KAAK,MAAf,EAAuB;AACrB,aAAK,MAAL,GAAc,MAAM,CAAC,aAAP,CAAqB,KAAK,MAA1B,CAAd;AACD;;AAED,WAAK,MAAL,GAAc,EAAd;AACA,WAAK,GAAL,GAAW,MAAX;AACA,WAAK,GAAL,GAAW,KAAK,IAAL,CAAU,GAArB;AACD,KATD;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BK;;;AAEL,aAAS,SAAT,CAAmB,KAAnB,EAA0B,OAA1B,EAAiC;AAC/B,UAAI,QAAQ,GAAG,IAAI,OAAJ,CAAY,OAAZ,CAAf;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc,KAAd,EAAqB,IAArB,EAF+B,CAEJ;;AAE3B,UAAI,QAAQ,CAAC,GAAb,EAAkB;AAChB,cAAM,QAAQ,CAAC,GAAT,IAAgB,QAAQ,CAAC,QAAQ,CAAC,GAAV,CAA9B;AACD;;AAED,aAAO,QAAQ,CAAC,MAAhB;AACD;AACD;;;;;;;AAOK;AAEL;;;AACA,aAAS,UAAT,CAAoB,KAApB,EAA2B,OAA3B,EAAkC;AAChC,MAAA,OAAO,GAAG,OAAO,IAAI,EAArB;AACA,MAAA,OAAO,CAAC,GAAR,GAAc,IAAd;AACA,aAAO,SAAS,CAAC,KAAD,EAAQ,OAAR,CAAhB;AACD;AACD;;;;;;;AAOK;AACL;;;AACA,aAAS,IAAT,CAAc,KAAd,EAAqB,OAArB,EAA4B;AAC1B,MAAA,OAAO,GAAG,OAAO,IAAI,EAArB;AACA,MAAA,OAAO,CAAC,IAAR,GAAe,IAAf;AACA,aAAO,SAAS,CAAC,KAAD,EAAQ,OAAR,CAAhB;AACD;;AAED,WAAO;AAAE,MAAA,OAAO,EAAA,OAAT;AAAW,MAAA,SAAS,EAAA;AAApB,KAAP;AACD;AACF","sourceRoot":"","sourcesContent":["/* eslint-disable */\nvar workerURL;\nexport function createDeflateWorker() {\n    // Lazily compute the worker URL to allow importing the SDK in NodeJS\n    if (!workerURL) {\n        workerURL = URL.createObjectURL(new Blob([\"(\" + workerCodeFn + \")(self)\"]));\n    }\n    return new Worker(workerURL);\n}\nfunction workerCodeFn() {\n    monitor(function () {\n        var _a = makePakoDeflate(), Deflate = _a.Deflate, constants = _a.constants;\n        var deflate = new Deflate();\n        var rawSize = 0;\n        self.addEventListener('message', monitor(function (event) {\n            var data = event.data;\n            switch (data.action) {\n                case 'write':\n                    var additionalRawSize = pushData(data.data);\n                    self.postMessage({\n                        id: data.id,\n                        compressedSize: deflate.chunks.reduce(function (total, chunk) { return total + chunk.length; }, 0),\n                        additionalRawSize: additionalRawSize,\n                    });\n                    break;\n                case 'flush':\n                    var additionalRawSize = data.data ? pushData(data.data) : 0;\n                    deflate.push('', constants.Z_FINISH);\n                    self.postMessage({\n                        id: data.id,\n                        result: deflate.result,\n                        additionalRawSize: additionalRawSize,\n                        rawSize: rawSize,\n                    });\n                    deflate = new Deflate();\n                    rawSize = 0;\n                    break;\n            }\n        }));\n        function pushData(data) {\n            var binaryData = new TextEncoder().encode(data);\n            deflate.push(binaryData, constants.Z_SYNC_FLUSH);\n            rawSize += binaryData.length;\n            return binaryData.length;\n        }\n    })();\n    function monitor(fn) {\n        return function () {\n            try {\n                return fn.apply(this, arguments);\n            }\n            catch (e) {\n                try {\n                    self.postMessage({ error: e });\n                }\n                catch (_) {\n                    // DATA_CLONE_ERR, cf https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n                    self.postMessage({ error: '' + e });\n                }\n            }\n        };\n    }\n    // https://github.com/nodeca/pako/blob/034669ba0f1a4c0590e45f7c2820128200f972b3/dist/pako_deflate.es5.js\n    function makePakoDeflate() {\n        // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n        //\n        // This software is provided 'as-is', without any express or implied\n        // warranty. In no event will the authors be held liable for any damages\n        // arising from the use of this software.\n        //\n        // Permission is granted to anyone to use this software for any purpose,\n        // including commercial applications, and to alter it and redistribute it\n        // freely, subject to the following restrictions:\n        //\n        // 1. The origin of this software must not be misrepresented; you must not\n        //   claim that you wrote the original software. If you use this software\n        //   in a product, an acknowledgment in the product documentation would be\n        //   appreciated but is not required.\n        // 2. Altered source versions must be plainly marked as such, and must not be\n        //   misrepresented as being the original software.\n        // 3. This notice may not be removed or altered from any source distribution.\n        /* eslint-disable space-unary-ops */\n        /* Public constants ========================================================== */\n        /* =========================================================================== */\n        // const Z_FILTERED          = 1;\n        // const Z_HUFFMAN_ONLY      = 2;\n        // const Z_RLE               = 3;\n        var Z_FIXED = 4; // const Z_DEFAULT_STRATEGY  = 0;\n        /* Possible values of the data_type field (though see inflate()) */\n        var Z_BINARY = 0;\n        var Z_TEXT = 1; // const Z_ASCII             = 1; // = Z_TEXT\n        var Z_UNKNOWN = 2;\n        /* ============================================================================ */\n        function zero(buf) {\n            var len = buf.length;\n            while (--len >= 0) {\n                buf[len] = 0;\n            }\n        } // From zutil.h\n        var STORED_BLOCK = 0;\n        var STATIC_TREES = 1;\n        var DYN_TREES = 2;\n        /* The three kinds of block type */\n        var MIN_MATCH = 3;\n        var MAX_MATCH = 258;\n        /* The minimum and maximum match lengths */\n        // From deflate.h\n        /* ===========================================================================\n         * Internal compression state.\n         */\n        var LENGTH_CODES = 29;\n        /* number of length codes, not counting the special END_BLOCK code */\n        var LITERALS = 256;\n        /* number of literal bytes 0..255 */\n        var L_CODES = LITERALS + 1 + LENGTH_CODES;\n        /* number of Literal or Length codes, including the END_BLOCK code */\n        var D_CODES = 30;\n        /* number of distance codes */\n        var BL_CODES = 19;\n        /* number of codes used to transfer the bit lengths */\n        var HEAP_SIZE = 2 * L_CODES + 1;\n        /* maximum heap size */\n        var MAX_BITS = 15;\n        /* All codes must not exceed MAX_BITS bits */\n        var Buf_size = 16;\n        /* size of bit buffer in bi_buf */\n        /* ===========================================================================\n         * Constants\n         */\n        var MAX_BL_BITS = 7;\n        /* Bit length codes must not exceed MAX_BL_BITS bits */\n        var END_BLOCK = 256;\n        /* end of block literal code */\n        var REP_3_6 = 16;\n        /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n        var REPZ_3_10 = 17;\n        /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n        var REPZ_11_138 = 18;\n        /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n        /* eslint-disable comma-spacing,array-bracket-spacing */\n        var extra_lbits = \n        /* extra bits for each length code */\n        new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);\n        var extra_dbits = \n        /* extra bits for each distance code */\n        new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);\n        var extra_blbits = \n        /* extra bits for each bit length code */\n        new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);\n        var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n        /* eslint-enable comma-spacing,array-bracket-spacing */\n        /* The lengths of the bit length codes are sent in order of decreasing\n         * probability, to avoid transmitting the lengths for unused bit length codes.\n         */\n        /* ===========================================================================\n         * Local data. These are initialized only once.\n         */\n        // We pre-fill arrays with 0 to avoid uninitialized gaps\n        var DIST_CODE_LEN = 512;\n        /* see definition of array dist_code below */\n        // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n        var static_ltree = new Array((L_CODES + 2) * 2);\n        zero(static_ltree);\n        /* The static literal tree. Since the bit lengths are imposed, there is no\n         * need for the L_CODES extra codes used during heap construction. However\n         * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n         * below).\n         */\n        var static_dtree = new Array(D_CODES * 2);\n        zero(static_dtree);\n        /* The static distance tree. (Actually a trivial tree since all codes use\n         * 5 bits.)\n         */\n        var _dist_code = new Array(DIST_CODE_LEN);\n        zero(_dist_code);\n        /* Distance codes. The first 256 values correspond to the distances\n         * 3 .. 258, the last 256 values correspond to the top 8 bits of\n         * the 15 bit distances.\n         */\n        var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n        zero(_length_code);\n        /* length code for each normalized match length (0 == MIN_MATCH) */\n        var base_length = new Array(LENGTH_CODES);\n        zero(base_length);\n        /* First normalized length for each code (0 = MIN_MATCH) */\n        var base_dist = new Array(D_CODES);\n        zero(base_dist);\n        /* First normalized distance for each code (0 = distance of 1) */\n        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n            this.static_tree = static_tree;\n            /* static tree or NULL */\n            this.extra_bits = extra_bits;\n            /* extra bits for each code or NULL */\n            this.extra_base = extra_base;\n            /* base index for extra_bits */\n            this.elems = elems;\n            /* max number of elements in the tree */\n            this.max_length = max_length;\n            /* max bit length for the codes */\n            // show if `static_tree` has data or dummy - needed for monomorphic objects\n            this.has_stree = static_tree && static_tree.length;\n        }\n        var static_l_desc;\n        var static_d_desc;\n        var static_bl_desc;\n        function TreeDesc(dyn_tree, stat_desc) {\n            this.dyn_tree = dyn_tree;\n            /* the dynamic tree */\n            this.max_code = 0;\n            /* largest code with non zero frequency */\n            this.stat_desc = stat_desc;\n            /* the corresponding static tree */\n        }\n        var d_code = function d_code(dist) {\n            return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n        };\n        /* ===========================================================================\n         * Output a short LSB first on the stream.\n         * IN assertion: there is enough room in pendingBuf.\n         */\n        var put_short = function put_short(s, w) {\n            //    put_byte(s, (uch)((w) & 0xff));\n            //    put_byte(s, (uch)((ush)(w) >> 8));\n            s.pending_buf[s.pending++] = w & 0xff;\n            s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n        };\n        /* ===========================================================================\n         * Send a value on a given number of bits.\n         * IN assertion: length <= 16 and value fits in length bits.\n         */\n        var send_bits = function send_bits(s, value, length) {\n            if (s.bi_valid > Buf_size - length) {\n                s.bi_buf |= (value << s.bi_valid) & 0xffff;\n                put_short(s, s.bi_buf);\n                s.bi_buf = value >> (Buf_size - s.bi_valid);\n                s.bi_valid += length - Buf_size;\n            }\n            else {\n                s.bi_buf |= (value << s.bi_valid) & 0xffff;\n                s.bi_valid += length;\n            }\n        };\n        var send_code = function send_code(s, c, tree) {\n            send_bits(s, tree[c * 2], \n            /* .Code */\n            tree[c * 2 + 1]\n            /* .Len */\n            );\n        };\n        /* ===========================================================================\n         * Reverse the first len bits of a code, using straightforward code (a faster\n         * method would use a table)\n         * IN assertion: 1 <= len <= 15\n         */\n        var bi_reverse = function bi_reverse(code, len) {\n            var res = 0;\n            do {\n                res |= code & 1;\n                code >>>= 1;\n                res <<= 1;\n            } while (--len > 0);\n            return res >>> 1;\n        };\n        /* ===========================================================================\n         * Flush the bit buffer, keeping at most 7 bits in it.\n         */\n        var bi_flush = function bi_flush(s) {\n            if (s.bi_valid === 16) {\n                put_short(s, s.bi_buf);\n                s.bi_buf = 0;\n                s.bi_valid = 0;\n            }\n            else if (s.bi_valid >= 8) {\n                s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n                s.bi_buf >>= 8;\n                s.bi_valid -= 8;\n            }\n        };\n        /* ===========================================================================\n         * Compute the optimal bit lengths for a tree and update the total bit length\n         * for the current block.\n         * IN assertion: the fields freq and dad are set, heap[heap_max] and\n         *    above are the tree nodes sorted by increasing frequency.\n         * OUT assertions: the field len is set to the optimal bit length, the\n         *     array bl_count contains the frequencies for each bit length.\n         *     The length opt_len is updated; static_len is also updated if stree is\n         *     not null.\n         */\n        var gen_bitlen = function gen_bitlen(s, desc //    deflate_state *s; //    tree_desc *desc;    /* the tree descriptor */\n        ) {\n            var tree = desc.dyn_tree;\n            var max_code = desc.max_code;\n            var stree = desc.stat_desc.static_tree;\n            var has_stree = desc.stat_desc.has_stree;\n            var extra = desc.stat_desc.extra_bits;\n            var base = desc.stat_desc.extra_base;\n            var max_length = desc.stat_desc.max_length;\n            var h;\n            /* heap index */\n            var n;\n            var m;\n            /* iterate over the tree elements */\n            var bits;\n            /* bit length */\n            var xbits;\n            /* extra bits */\n            var f;\n            /* frequency */\n            var overflow = 0;\n            /* number of elements with bit length too large */\n            for (bits = 0; bits <= MAX_BITS; bits++) {\n                s.bl_count[bits] = 0;\n            }\n            /* In a first pass, compute the optimal bit lengths (which may\n             * overflow in the case of the bit length tree).\n             */\n            tree[s.heap[s.heap_max] * 2 + 1] =\n                /* .Len */\n                0;\n            /* root of the heap */\n            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n                n = s.heap[h];\n                bits =\n                    tree[tree[n * 2 + 1] *\n                        /* .Dad */\n                        2 +\n                        1] +\n                        /* .Len */\n                        1;\n                if (bits > max_length) {\n                    bits = max_length;\n                    overflow++;\n                }\n                tree[n * 2 + 1] =\n                    /* .Len */\n                    bits;\n                /* We overwrite tree[n].Dad which is no longer needed */\n                if (n > max_code) {\n                    continue;\n                }\n                /* not a leaf node */\n                s.bl_count[bits]++;\n                xbits = 0;\n                if (n >= base) {\n                    xbits = extra[n - base];\n                }\n                f = tree[n * 2];\n                /* .Freq */\n                s.opt_len += f * (bits + xbits);\n                if (has_stree) {\n                    s.static_len +=\n                        f *\n                            (stree[n * 2 + 1] +\n                                /* .Len */\n                                xbits);\n                }\n            }\n            if (overflow === 0) {\n                return;\n            } // Trace((stderr,\"\\nbit length overflow\\n\"));\n            /* This happens for example on obj2 and pic of the Calgary corpus */\n            /* Find the first bit length which could increase: */\n            do {\n                bits = max_length - 1;\n                while (s.bl_count[bits] === 0) {\n                    bits--;\n                }\n                s.bl_count[bits]--;\n                /* move one leaf down the tree */\n                s.bl_count[bits + 1] += 2;\n                /* move one overflow item as its brother */\n                s.bl_count[max_length]--;\n                /* The brother of the overflow item also moves one step up,\n                 * but this does not affect bl_count[max_length]\n                 */\n                overflow -= 2;\n            } while (overflow > 0);\n            /* Now recompute all bit lengths, scanning in increasing frequency.\n             * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n             * lengths instead of fixing only the wrong ones. This idea is taken\n             * from 'ar' written by Haruhiko Okumura.)\n             */\n            for (bits = max_length; bits !== 0; bits--) {\n                n = s.bl_count[bits];\n                while (n !== 0) {\n                    m = s.heap[--h];\n                    if (m > max_code) {\n                        continue;\n                    }\n                    if (tree[m * 2 + 1] !==\n                        /* .Len */\n                        bits) {\n                        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                        s.opt_len +=\n                            (bits - tree[m * 2 + 1]) *\n                                /* .Len */\n                                tree[m * 2];\n                        /* .Freq */\n                        tree[m * 2 + 1] =\n                            /* .Len */\n                            bits;\n                    }\n                    n--;\n                }\n            }\n        };\n        /* ===========================================================================\n         * Generate the codes for a given tree and bit counts (which need not be\n         * optimal).\n         * IN assertion: the array bl_count contains the bit length statistics for\n         * the given tree and the field len is set for all tree elements.\n         * OUT assertion: the field code is set for all tree elements of non\n         *     zero code length.\n         */\n        var gen_codes = function gen_codes(tree, max_code, bl_count //    ct_data *tree;             /* the tree to decorate */ //    int max_code;              /* largest code with non zero frequency */ //    ushf *bl_count;            /* number of codes at each bit length */\n        ) {\n            var next_code = new Array(MAX_BITS + 1);\n            /* next code value for each bit length */\n            var code = 0;\n            /* running code value */\n            var bits;\n            /* bit index */\n            var n;\n            /* code index */\n            /* The distribution counts are first used to generate the code values\n             * without bit reversal.\n             */\n            for (bits = 1; bits <= MAX_BITS; bits++) {\n                next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n            }\n            /* Check that the bit counts in bl_count are consistent. The last code\n             * must be all ones.\n             */\n            // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n            //        \"inconsistent bit counts\");\n            // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n            for (n = 0; n <= max_code; n++) {\n                var len = tree[n * 2 + 1];\n                /* .Len */\n                if (len === 0) {\n                    continue;\n                }\n                /* Now reverse the bits */\n                tree[n * 2] =\n                    /* .Code */\n                    bi_reverse(next_code[len]++, len); // Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n                //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n            }\n        };\n        /* ===========================================================================\n         * Initialize the various 'constant' tables.\n         */\n        var tr_static_init = function tr_static_init() {\n            var n;\n            /* iterates over tree elements */\n            var bits;\n            /* bit counter */\n            var length;\n            /* length value */\n            var code;\n            /* code value */\n            var dist;\n            /* distance index */\n            var bl_count = new Array(MAX_BITS + 1);\n            /* number of codes at each bit length for an optimal tree */\n            // do check in _tr_init()\n            // if (static_init_done) return;\n            /* For some embedded targets, global variables are not initialized: */\n            /* #ifdef NO_INIT_GLOBAL_POINTERS\n            static_l_desc.static_tree = static_ltree;\n            static_l_desc.extra_bits = extra_lbits;\n            static_d_desc.static_tree = static_dtree;\n            static_d_desc.extra_bits = extra_dbits;\n            static_bl_desc.extra_bits = extra_blbits;\n          #endif */\n            /* Initialize the mapping length (0..255) -> length code (0..28) */\n            length = 0;\n            for (code = 0; code < LENGTH_CODES - 1; code++) {\n                base_length[code] = length;\n                for (n = 0; n < 1 << extra_lbits[code]; n++) {\n                    _length_code[length++] = code;\n                }\n            } // Assert (length == 256, \"tr_static_init: length != 256\");\n            /* Note that the length 255 (match length 258) can be represented\n             * in two different ways: code 284 + 5 bits or code 285, so we\n             * overwrite length_code[255] to use the best encoding:\n             */\n            _length_code[length - 1] = code;\n            /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n            dist = 0;\n            for (code = 0; code < 16; code++) {\n                base_dist[code] = dist;\n                for (n = 0; n < 1 << extra_dbits[code]; n++) {\n                    _dist_code[dist++] = code;\n                }\n            } // Assert (dist == 256, \"tr_static_init: dist != 256\");\n            dist >>= 7;\n            /* from now on, all distances are divided by 128 */\n            for (; code < D_CODES; code++) {\n                base_dist[code] = dist << 7;\n                for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {\n                    _dist_code[256 + dist++] = code;\n                }\n            } // Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n            /* Construct the codes of the static literal tree */\n            for (bits = 0; bits <= MAX_BITS; bits++) {\n                bl_count[bits] = 0;\n            }\n            n = 0;\n            while (n <= 143) {\n                static_ltree[n * 2 + 1] =\n                    /* .Len */\n                    8;\n                n++;\n                bl_count[8]++;\n            }\n            while (n <= 255) {\n                static_ltree[n * 2 + 1] =\n                    /* .Len */\n                    9;\n                n++;\n                bl_count[9]++;\n            }\n            while (n <= 279) {\n                static_ltree[n * 2 + 1] =\n                    /* .Len */\n                    7;\n                n++;\n                bl_count[7]++;\n            }\n            while (n <= 287) {\n                static_ltree[n * 2 + 1] =\n                    /* .Len */\n                    8;\n                n++;\n                bl_count[8]++;\n            }\n            /* Codes 286 and 287 do not exist, but we must include them in the\n             * tree construction to get a canonical Huffman tree (longest code\n             * all ones)\n             */\n            gen_codes(static_ltree, L_CODES + 1, bl_count);\n            /* The static distance tree is trivial: */\n            for (n = 0; n < D_CODES; n++) {\n                static_dtree[n * 2 + 1] =\n                    /* .Len */\n                    5;\n                static_dtree[n * 2] =\n                    /* .Code */\n                    bi_reverse(n, 5);\n            } // Now data ready and we can init static trees\n            static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n            static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n            static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); // static_init_done = true;\n        };\n        /* ===========================================================================\n         * Initialize a new block.\n         */\n        var init_block = function init_block(s) {\n            var n;\n            /* iterates over tree elements */\n            /* Initialize the trees. */\n            for (n = 0; n < L_CODES; n++) {\n                s.dyn_ltree[n * 2] =\n                    /* .Freq */\n                    0;\n            }\n            for (n = 0; n < D_CODES; n++) {\n                s.dyn_dtree[n * 2] =\n                    /* .Freq */\n                    0;\n            }\n            for (n = 0; n < BL_CODES; n++) {\n                s.bl_tree[n * 2] =\n                    /* .Freq */\n                    0;\n            }\n            s.dyn_ltree[END_BLOCK * 2] =\n                /* .Freq */\n                1;\n            s.opt_len = s.static_len = 0;\n            s.last_lit = s.matches = 0;\n        };\n        /* ===========================================================================\n         * Flush the bit buffer and align the output on a byte boundary\n         */\n        var bi_windup = function bi_windup(s) {\n            if (s.bi_valid > 8) {\n                put_short(s, s.bi_buf);\n            }\n            else if (s.bi_valid > 0) {\n                // put_byte(s, (Byte)s->bi_buf);\n                s.pending_buf[s.pending++] = s.bi_buf;\n            }\n            s.bi_buf = 0;\n            s.bi_valid = 0;\n        };\n        /* ===========================================================================\n         * Copy a stored block, storing first the length and its\n         * one's complement if requested.\n         */\n        var copy_block = function copy_block(s, buf, len, header // DeflateState *s; //charf    *buf;    /* the input data */ //unsigned len;     /* its length */ //int      header;  /* true if block header must be written */\n        ) {\n            bi_windup(s);\n            /* align on byte boundary */\n            if (header) {\n                put_short(s, len);\n                put_short(s, ~len);\n            } //  while (len--) {\n            //    put_byte(s, *buf++);\n            //  }\n            s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n            s.pending += len;\n        };\n        /* ===========================================================================\n         * Compares to subtrees, using the tree depth as tie breaker when\n         * the subtrees have equal frequency. This minimizes the worst case length.\n         */\n        var smaller = function smaller(tree, n, m, depth) {\n            var _n2 = n * 2;\n            var _m2 = m * 2;\n            return (tree[_n2] <\n                /* .Freq */\n                tree[_m2] ||\n                /* .Freq */\n                (tree[_n2] ===\n                    /* .Freq */\n                    tree[_m2] &&\n                    /* .Freq */\n                    depth[n] <= depth[m]));\n        };\n        /* ===========================================================================\n         * Restore the heap property by moving down the tree starting at node k,\n         * exchanging a node with the smallest of its two sons if necessary, stopping\n         * when the heap property is re-established (each father smaller than its\n         * two sons).\n         */\n        var pqdownheap = function pqdownheap(s, tree, k //    deflate_state *s; //    ct_data *tree;  /* the tree to restore */ //    int k;               /* node to move down */\n        ) {\n            var v = s.heap[k];\n            var j = k << 1;\n            /* left son of k */\n            while (j <= s.heap_len) {\n                /* Set j to the smallest of the two sons: */\n                if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n                    j++;\n                }\n                /* Exit if v is smaller than both sons */\n                if (smaller(tree, v, s.heap[j], s.depth)) {\n                    break;\n                }\n                /* Exchange v with the smallest son */\n                s.heap[k] = s.heap[j];\n                k = j;\n                /* And continue down the tree, setting j to the left son of k */\n                j <<= 1;\n            }\n            s.heap[k] = v;\n        }; // inlined manually\n        // const SMALLEST = 1;\n        /* ===========================================================================\n         * Send the block data compressed using the given Huffman trees\n         */\n        var compress_block = function compress_block(s, ltree, dtree //    deflate_state *s; //    const ct_data *ltree; /* literal tree */ //    const ct_data *dtree; /* distance tree */\n        ) {\n            var dist;\n            /* distance of matched string */\n            var lc;\n            /* match length or unmatched char (if dist == 0) */\n            var lx = 0;\n            /* running index in l_buf */\n            var code;\n            /* the code to send */\n            var extra;\n            /* number of extra bits to send */\n            if (s.last_lit !== 0) {\n                do {\n                    dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | s.pending_buf[s.d_buf + lx * 2 + 1];\n                    lc = s.pending_buf[s.l_buf + lx];\n                    lx++;\n                    if (dist === 0) {\n                        send_code(s, lc, ltree);\n                        /* send a literal byte */\n                        // Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n                    }\n                    else {\n                        /* Here, lc is the match length - MIN_MATCH */\n                        code = _length_code[lc];\n                        send_code(s, code + LITERALS + 1, ltree);\n                        /* send the length code */\n                        extra = extra_lbits[code];\n                        if (extra !== 0) {\n                            lc -= base_length[code];\n                            send_bits(s, lc, extra);\n                            /* send the extra length bits */\n                        }\n                        dist--;\n                        /* dist is now the match distance - 1 */\n                        code = d_code(dist); // Assert (code < D_CODES, \"bad d_code\");\n                        send_code(s, code, dtree);\n                        /* send the distance code */\n                        extra = extra_dbits[code];\n                        if (extra !== 0) {\n                            dist -= base_dist[code];\n                            send_bits(s, dist, extra);\n                            /* send the extra distance bits */\n                        }\n                    }\n                    /* literal or match pair ? */\n                    /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n                    // Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n                    //       \"pendingBuf overflow\");\n                } while (lx < s.last_lit);\n            }\n            send_code(s, END_BLOCK, ltree);\n        };\n        /* ===========================================================================\n         * Construct one Huffman tree and assigns the code bit strings and lengths.\n         * Update the total bit length for the current block.\n         * IN assertion: the field freq is set for all tree elements.\n         * OUT assertions: the fields len and code are set to the optimal bit length\n         *     and corresponding code. The length opt_len is updated; static_len is\n         *     also updated if stree is not null. The field max_code is set.\n         */\n        var build_tree = function build_tree(s, desc //    deflate_state *s; //    tree_desc *desc; /* the tree descriptor */\n        ) {\n            var tree = desc.dyn_tree;\n            var stree = desc.stat_desc.static_tree;\n            var has_stree = desc.stat_desc.has_stree;\n            var elems = desc.stat_desc.elems;\n            var n;\n            var m;\n            /* iterate over heap elements */\n            var max_code = -1;\n            /* largest code with non zero frequency */\n            var node;\n            /* new node being created */\n            /* Construct the initial heap, with least frequent element in\n             * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n             * heap[0] is not used.\n             */\n            s.heap_len = 0;\n            s.heap_max = HEAP_SIZE;\n            for (n = 0; n < elems; n++) {\n                if (tree[n * 2] !==\n                    /* .Freq */\n                    0) {\n                    s.heap[++s.heap_len] = max_code = n;\n                    s.depth[n] = 0;\n                }\n                else {\n                    tree[n * 2 + 1] =\n                        /* .Len */\n                        0;\n                }\n            }\n            /* The pkzip format requires that at least one distance code exists,\n             * and that at least one bit should be sent even if there is only one\n             * possible code. So to avoid special checks later on we force at least\n             * two codes of non zero frequency.\n             */\n            while (s.heap_len < 2) {\n                node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n                tree[node * 2] =\n                    /* .Freq */\n                    1;\n                s.depth[node] = 0;\n                s.opt_len--;\n                if (has_stree) {\n                    s.static_len -= stree[node * 2 + 1];\n                    /* .Len */\n                }\n                /* node is 0 or 1 so it does not have extra bits */\n            }\n            desc.max_code = max_code;\n            /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n             * establish sub-heaps of increasing lengths:\n             */\n            for (n = s.heap_len >> 1; \n            /* int /2 */\n            n >= 1; n--) {\n                pqdownheap(s, tree, n);\n            }\n            /* Construct the Huffman tree by repeatedly combining the least two\n             * frequent nodes.\n             */\n            node = elems;\n            /* next internal node of the tree */\n            do {\n                // pqremove(s, tree, n);  /* n = node of least frequency */\n                /** * pqremove ** */\n                n = s.heap[1];\n                /* SMALLEST */\n                s.heap[1] = s.heap[s.heap_len--];\n                /* SMALLEST */\n                pqdownheap(s, tree, 1\n                /* SMALLEST */\n                );\n                /***/\n                m = s.heap[1];\n                /* SMALLEST */\n                /* m = node of next least frequency */\n                s.heap[--s.heap_max] = n;\n                /* keep the nodes sorted by frequency */\n                s.heap[--s.heap_max] = m;\n                /* Create a new node father of n and m */\n                tree[node * 2] =\n                    /* .Freq */\n                    tree[n * 2] +\n                        /* .Freq */\n                        tree[m * 2];\n                /* .Freq */\n                s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n                tree[n * 2 + 1] =\n                    /* .Dad */\n                    tree[m * 2 + 1] =\n                        /* .Dad */\n                        node;\n                /* and insert the new node in the heap */\n                s.heap[1] = node++;\n                /* SMALLEST */\n                pqdownheap(s, tree, 1\n                /* SMALLEST */\n                );\n            } while (s.heap_len >= 2);\n            s.heap[--s.heap_max] = s.heap[1];\n            /* SMALLEST */\n            /* At this point, the fields freq and dad are set. We can now\n             * generate the bit lengths.\n             */\n            gen_bitlen(s, desc);\n            /* The field len is now set, we can generate the bit codes */\n            gen_codes(tree, max_code, s.bl_count);\n        };\n        /* ===========================================================================\n         * Scan a literal or distance tree to determine the frequencies of the codes\n         * in the bit length tree.\n         */\n        var scan_tree = function scan_tree(s, tree, max_code //    deflate_state *s; //    ct_data *tree;   /* the tree to be scanned */ //    int max_code;    /* and its largest code of non zero frequency */\n        ) {\n            var n;\n            /* iterates over all tree elements */\n            var prevlen = -1;\n            /* last emitted length */\n            var curlen;\n            /* length of current code */\n            var nextlen = tree[0 * 2 + 1];\n            /* .Len */\n            /* length of next code */\n            var count = 0;\n            /* repeat count of the current code */\n            var max_count = 7;\n            /* max repeat count */\n            var min_count = 4;\n            /* min repeat count */\n            if (nextlen === 0) {\n                max_count = 138;\n                min_count = 3;\n            }\n            tree[(max_code + 1) * 2 + 1] =\n                /* .Len */\n                0xffff;\n            /* guard */\n            for (n = 0; n <= max_code; n++) {\n                curlen = nextlen;\n                nextlen = tree[(n + 1) * 2 + 1];\n                /* .Len */\n                if (++count < max_count && curlen === nextlen) {\n                    continue;\n                }\n                else if (count < min_count) {\n                    s.bl_tree[curlen * 2] +=\n                        /* .Freq */\n                        count;\n                }\n                else if (curlen !== 0) {\n                    if (curlen !== prevlen) {\n                        s.bl_tree[curlen * 2] /* .Freq */++;\n                    }\n                    s.bl_tree[REP_3_6 * 2] /* .Freq */++;\n                }\n                else if (count <= 10) {\n                    s.bl_tree[REPZ_3_10 * 2] /* .Freq */++;\n                }\n                else {\n                    s.bl_tree[REPZ_11_138 * 2] /* .Freq */++;\n                }\n                count = 0;\n                prevlen = curlen;\n                if (nextlen === 0) {\n                    max_count = 138;\n                    min_count = 3;\n                }\n                else if (curlen === nextlen) {\n                    max_count = 6;\n                    min_count = 3;\n                }\n                else {\n                    max_count = 7;\n                    min_count = 4;\n                }\n            }\n        };\n        /* ===========================================================================\n         * Send a literal or distance tree in compressed form, using the codes in\n         * bl_tree.\n         */\n        var send_tree = function send_tree(s, tree, max_code //    deflate_state *s; //    ct_data *tree; /* the tree to be scanned */ //    int max_code;       /* and its largest code of non zero frequency */\n        ) {\n            var n;\n            /* iterates over all tree elements */\n            var prevlen = -1;\n            /* last emitted length */\n            var curlen;\n            /* length of current code */\n            var nextlen = tree[0 * 2 + 1];\n            /* .Len */\n            /* length of next code */\n            var count = 0;\n            /* repeat count of the current code */\n            var max_count = 7;\n            /* max repeat count */\n            var min_count = 4;\n            /* min repeat count */\n            /* tree[max_code+1].Len = -1; */\n            /* guard already set */\n            if (nextlen === 0) {\n                max_count = 138;\n                min_count = 3;\n            }\n            for (n = 0; n <= max_code; n++) {\n                curlen = nextlen;\n                nextlen = tree[(n + 1) * 2 + 1];\n                /* .Len */\n                if (++count < max_count && curlen === nextlen) {\n                    continue;\n                }\n                else if (count < min_count) {\n                    do {\n                        send_code(s, curlen, s.bl_tree);\n                    } while (--count !== 0);\n                }\n                else if (curlen !== 0) {\n                    if (curlen !== prevlen) {\n                        send_code(s, curlen, s.bl_tree);\n                        count--;\n                    } // Assert(count >= 3 && count <= 6, \" 3_6?\");\n                    send_code(s, REP_3_6, s.bl_tree);\n                    send_bits(s, count - 3, 2);\n                }\n                else if (count <= 10) {\n                    send_code(s, REPZ_3_10, s.bl_tree);\n                    send_bits(s, count - 3, 3);\n                }\n                else {\n                    send_code(s, REPZ_11_138, s.bl_tree);\n                    send_bits(s, count - 11, 7);\n                }\n                count = 0;\n                prevlen = curlen;\n                if (nextlen === 0) {\n                    max_count = 138;\n                    min_count = 3;\n                }\n                else if (curlen === nextlen) {\n                    max_count = 6;\n                    min_count = 3;\n                }\n                else {\n                    max_count = 7;\n                    min_count = 4;\n                }\n            }\n        };\n        /* ===========================================================================\n         * Construct the Huffman tree for the bit lengths and return the index in\n         * bl_order of the last bit length code to send.\n         */\n        var build_bl_tree = function build_bl_tree(s) {\n            var max_blindex;\n            /* index of last bit length code of non zero freq */\n            /* Determine the bit length frequencies for literal and distance trees */\n            scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n            scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n            /* Build the bit length tree: */\n            build_tree(s, s.bl_desc);\n            /* opt_len now includes the length of the tree representations, except\n             * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n             */\n            /* Determine the number of bit length codes to send. The pkzip format\n             * requires that at least 4 bit length codes be sent. (appnote.txt says\n             * 3 but the actual value used is 4.)\n             */\n            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n                if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !==\n                    /* .Len */\n                    0) {\n                    break;\n                }\n            }\n            /* Update opt_len to include the bit length tree and counts */\n            s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; // Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n            //        s->opt_len, s->static_len));\n            return max_blindex;\n        };\n        /* ===========================================================================\n         * Send the header for a block using dynamic Huffman trees: the counts, the\n         * lengths of the bit length codes, the literal tree and the distance tree.\n         * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n         */\n        var send_all_trees = function send_all_trees(s, lcodes, dcodes, blcodes //    deflate_state *s; //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n        ) {\n            var rank;\n            /* index in bl_order */\n            // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n            // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n            //        \"too many codes\");\n            // Tracev((stderr, \"\\nbl counts: \"));\n            send_bits(s, lcodes - 257, 5);\n            /* not +255 as stated in appnote.txt */\n            send_bits(s, dcodes - 1, 5);\n            send_bits(s, blcodes - 4, 4);\n            /* not -3 as stated in appnote.txt */\n            for (rank = 0; rank < blcodes; rank++) {\n                // Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n                send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], \n                /* .Len */\n                3);\n            } // Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n            send_tree(s, s.dyn_ltree, lcodes - 1);\n            /* literal tree */\n            // Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n            send_tree(s, s.dyn_dtree, dcodes - 1);\n            /* distance tree */\n            // Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n        };\n        /* ===========================================================================\n         * Check if the data type is TEXT or BINARY, using the following algorithm:\n         * - TEXT if the two conditions below are satisfied:\n         *    a) There are no non-portable control characters belonging to the\n         *       \"black list\" (0..6, 14..25, 28..31).\n         *    b) There is at least one printable character belonging to the\n         *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n         * - BINARY otherwise.\n         * - The following partially-portable control characters form a\n         *   \"gray list\" that is ignored in this detection algorithm:\n         *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n         * IN assertion: the fields Freq of dyn_ltree are set.\n         */\n        var detect_data_type = function detect_data_type(s) {\n            /* black_mask is the bit mask of black-listed bytes\n             * set bits 0..6, 14..25, and 28..31\n             * 0xf3ffc07f = binary 11110011111111111100000001111111\n             */\n            var black_mask = 0xf3ffc07f;\n            var n;\n            /* Check for non-textual (\"black-listed\") bytes. */\n            for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n                if (black_mask & 1 &&\n                    s.dyn_ltree[n * 2] !==\n                        /* .Freq */\n                        0) {\n                    return Z_BINARY;\n                }\n            }\n            /* Check for textual (\"white-listed\") bytes. */\n            if (s.dyn_ltree[9 * 2] !==\n                /* .Freq */\n                0 ||\n                s.dyn_ltree[10 * 2] !==\n                    /* .Freq */\n                    0 ||\n                s.dyn_ltree[13 * 2] !==\n                    /* .Freq */\n                    0) {\n                return Z_TEXT;\n            }\n            for (n = 32; n < LITERALS; n++) {\n                if (s.dyn_ltree[n * 2] !==\n                    /* .Freq */\n                    0) {\n                    return Z_TEXT;\n                }\n            }\n            /* There are no \"black-listed\" or \"white-listed\" bytes:\n             * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n             */\n            return Z_BINARY;\n        };\n        var static_init_done = false;\n        /* ===========================================================================\n         * Initialize the tree data structures for a new zlib stream.\n         */\n        var _tr_init = function _tr_init(s) {\n            if (!static_init_done) {\n                tr_static_init();\n                static_init_done = true;\n            }\n            s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n            s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n            s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n            s.bi_buf = 0;\n            s.bi_valid = 0;\n            /* Initialize the first block of the first file: */\n            init_block(s);\n        };\n        /* ===========================================================================\n         * Send a stored block\n         */\n        var _tr_stored_block = function _tr_stored_block(s, buf, stored_len, last // DeflateState *s; //charf *buf;       /* input block */ //ulg stored_len;   /* length of input block */ //int last;         /* one if this is the last block for a file */\n        ) {\n            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n            /* send block type */\n            copy_block(s, buf, stored_len, true);\n            /* with header */\n        };\n        /* ===========================================================================\n         * Send one empty static block to give enough lookahead for inflate.\n         * This takes 10 bits, of which 7 may remain in the bit buffer.\n         */\n        var _tr_align = function _tr_align(s) {\n            send_bits(s, STATIC_TREES << 1, 3);\n            send_code(s, END_BLOCK, static_ltree);\n            bi_flush(s);\n        };\n        /* ===========================================================================\n         * Determine the best encoding for the current block: dynamic trees, static\n         * trees or store, and output the encoded block to the zip file.\n         */\n        var _tr_flush_block = function _tr_flush_block(s, buf, stored_len, last // DeflateState *s; //charf *buf;       /* input block, or NULL if too old */ //ulg stored_len;   /* length of input block */ //int last;         /* one if this is the last block for a file */\n        ) {\n            var opt_lenb;\n            var static_lenb;\n            /* opt_len and static_len in bytes */\n            var max_blindex = 0;\n            /* index of last bit length code of non zero freq */\n            /* Build the Huffman trees unless a stored block is forced */\n            if (s.level > 0) {\n                /* Check if the file is binary or text */\n                if (s.strm.data_type === Z_UNKNOWN) {\n                    s.strm.data_type = detect_data_type(s);\n                }\n                /* Construct the literal and distance trees */\n                build_tree(s, s.l_desc); // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n                //        s->static_len));\n                build_tree(s, s.d_desc); // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n                //        s->static_len));\n                /* At this point, opt_len and static_len are the total bit lengths of\n                 * the compressed block data, excluding the tree representations.\n                 */\n                /* Build the bit length tree for the above two trees, and get the index\n                 * in bl_order of the last bit length code to send.\n                 */\n                max_blindex = build_bl_tree(s);\n                /* Determine the best encoding. Compute the block lengths in bytes. */\n                opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n                static_lenb = (s.static_len + 3 + 7) >>> 3; // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n                //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n                //        s->last_lit));\n                if (static_lenb <= opt_lenb) {\n                    opt_lenb = static_lenb;\n                }\n            }\n            else {\n                // Assert(buf != (char*)0, \"lost buf\");\n                opt_lenb = static_lenb = stored_len + 5;\n                /* force a stored block */\n            }\n            if (stored_len + 4 <= opt_lenb && buf !== -1) {\n                /* 4: two words for the lengths */\n                /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n                 * Otherwise we can't have processed more than WSIZE input bytes since\n                 * the last block flush, because compression would have been\n                 * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n                 * transform a block into a stored block.\n                 */\n                _tr_stored_block(s, buf, stored_len, last);\n            }\n            else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n                send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n                compress_block(s, static_ltree, static_dtree);\n            }\n            else {\n                send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n                send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n                compress_block(s, s.dyn_ltree, s.dyn_dtree);\n            } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n            /* The above check is made mod 2^32, for files larger than 512 MB\n             * and uLong implemented on 32 bits.\n             */\n            init_block(s);\n            if (last) {\n                bi_windup(s);\n            } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n            //       s->compressed_len-7*last));\n        };\n        /* ===========================================================================\n         * Save the match info and tally the frequency counts. Return true if\n         * the current block must be flushed.\n         */\n        var _tr_tally = function _tr_tally(s, dist, lc //    deflate_state *s; //    unsigned dist;  /* distance of matched string */ //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n        ) {\n            // let out_length, in_length, dcode;\n            s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;\n            s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n            s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n            s.last_lit++;\n            if (dist === 0) {\n                /* lc is the unmatched char */\n                s.dyn_ltree[lc * 2] /* .Freq */++;\n            }\n            else {\n                s.matches++;\n                /* Here, lc is the match length - MIN_MATCH */\n                dist--;\n                /* dist = match distance - 1 */\n                // Assert((ush)dist < (ush)MAX_DIST(s) &&\n                //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n                //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n                s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /* .Freq */++;\n                s.dyn_dtree[d_code(dist) * 2] /* .Freq */++;\n            } // (!) This block is disabled in zlib defaults,\n            // don't enable it for binary compatibility\n            // #ifdef TRUNCATE_BLOCK\n            //  /* Try to guess if it is profitable to stop the current block here */\n            //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n            //    /* Compute an upper bound for the compressed length */\n            //    out_length = s.last_lit*8;\n            //    in_length = s.strstart - s.block_start;\n            //\n            //    for (dcode = 0; dcode < D_CODES; dcode++) {\n            //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n            //    }\n            //    out_length >>>= 3;\n            //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n            //    //       s->last_lit, in_length, out_length,\n            //    //       100L - out_length*100L/in_length));\n            //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n            //      return true;\n            //    }\n            //  }\n            // #endif\n            return s.last_lit === s.lit_bufsize - 1;\n            /* We avoid equality with lit_bufsize because of wraparound at 64K\n             * on 16 bit machines and because stored blocks are restricted to\n             * 64K-1 bytes.\n             */\n        };\n        var _tr_init_1 = _tr_init;\n        var _tr_stored_block_1 = _tr_stored_block;\n        var _tr_flush_block_1 = _tr_flush_block;\n        var _tr_tally_1 = _tr_tally;\n        var _tr_align_1 = _tr_align;\n        var trees = {\n            _tr_init: _tr_init_1,\n            _tr_stored_block: _tr_stored_block_1,\n            _tr_flush_block: _tr_flush_block_1,\n            _tr_tally: _tr_tally_1,\n            _tr_align: _tr_align_1,\n        };\n        // It isn't worth it to make additional optimizations as in original.\n        // Small size is preferable.\n        // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n        // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n        //\n        // This software is provided 'as-is', without any express or implied\n        // warranty. In no event will the authors be held liable for any damages\n        // arising from the use of this software.\n        //\n        // Permission is granted to anyone to use this software for any purpose,\n        // including commercial applications, and to alter it and redistribute it\n        // freely, subject to the following restrictions:\n        //\n        // 1. The origin of this software must not be misrepresented; you must not\n        //   claim that you wrote the original software. If you use this software\n        //   in a product, an acknowledgment in the product documentation would be\n        //   appreciated but is not required.\n        // 2. Altered source versions must be plainly marked as such, and must not be\n        //   misrepresented as being the original software.\n        // 3. This notice may not be removed or altered from any source distribution.\n        var adler32 = function adler32(adler, buf, len, pos) {\n            var s1 = (adler & 0xffff) | 0;\n            var s2 = ((adler >>> 16) & 0xffff) | 0;\n            var n = 0;\n            while (len !== 0) {\n                // Set limit ~ twice less than 5552, to keep\n                // s2 in 31-bits, because we force signed ints.\n                // in other case %= will fail.\n                n = len > 2000 ? 2000 : len;\n                len -= n;\n                do {\n                    s1 = (s1 + buf[pos++]) | 0;\n                    s2 = (s2 + s1) | 0;\n                } while (--n);\n                s1 %= 65521;\n                s2 %= 65521;\n            }\n            return s1 | (s2 << 16) | 0;\n        };\n        var adler32_1 = adler32;\n        // So write code to minimize size - no pregenerated tables\n        // and array tools dependencies.\n        // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n        // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n        //\n        // This software is provided 'as-is', without any express or implied\n        // warranty. In no event will the authors be held liable for any damages\n        // arising from the use of this software.\n        //\n        // Permission is granted to anyone to use this software for any purpose,\n        // including commercial applications, and to alter it and redistribute it\n        // freely, subject to the following restrictions:\n        //\n        // 1. The origin of this software must not be misrepresented; you must not\n        //   claim that you wrote the original software. If you use this software\n        //   in a product, an acknowledgment in the product documentation would be\n        //   appreciated but is not required.\n        // 2. Altered source versions must be plainly marked as such, and must not be\n        //   misrepresented as being the original software.\n        // 3. This notice may not be removed or altered from any source distribution.\n        // Use ordinary array, since untyped makes no boost here\n        var makeTable = function makeTable() {\n            var c;\n            var table = [];\n            for (var n = 0; n < 256; n++) {\n                c = n;\n                for (var k = 0; k < 8; k++) {\n                    c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;\n                }\n                table[n] = c;\n            }\n            return table;\n        }; // Create table on load. Just 255 signed longs. Not a problem.\n        var crcTable = new Uint32Array(makeTable());\n        var crc32 = function crc32(crc, buf, len, pos) {\n            var t = crcTable;\n            var end = pos + len;\n            crc ^= -1;\n            for (var i = pos; i < end; i++) {\n                crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xff];\n            }\n            return crc ^ -1; // >>> 0;\n        };\n        var crc32_1 = crc32;\n        // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n        //\n        // This software is provided 'as-is', without any express or implied\n        // warranty. In no event will the authors be held liable for any damages\n        // arising from the use of this software.\n        //\n        // Permission is granted to anyone to use this software for any purpose,\n        // including commercial applications, and to alter it and redistribute it\n        // freely, subject to the following restrictions:\n        //\n        // 1. The origin of this software must not be misrepresented; you must not\n        //   claim that you wrote the original software. If you use this software\n        //   in a product, an acknowledgment in the product documentation would be\n        //   appreciated but is not required.\n        // 2. Altered source versions must be plainly marked as such, and must not be\n        //   misrepresented as being the original software.\n        // 3. This notice may not be removed or altered from any source distribution.\n        var messages = {\n            2: 'need dictionary',\n            /* Z_NEED_DICT       2  */\n            1: 'stream end',\n            /* Z_STREAM_END      1  */\n            0: '',\n            /* Z_OK              0  */\n            '-1': 'file error',\n            /* Z_ERRNO         (-1) */\n            '-2': 'stream error',\n            /* Z_STREAM_ERROR  (-2) */\n            '-3': 'data error',\n            /* Z_DATA_ERROR    (-3) */\n            '-4': 'insufficient memory',\n            /* Z_MEM_ERROR     (-4) */\n            '-5': 'buffer error',\n            /* Z_BUF_ERROR     (-5) */\n            '-6': 'incompatible version',\n        };\n        // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n        //\n        // This software is provided 'as-is', without any express or implied\n        // warranty. In no event will the authors be held liable for any damages\n        // arising from the use of this software.\n        //\n        // Permission is granted to anyone to use this software for any purpose,\n        // including commercial applications, and to alter it and redistribute it\n        // freely, subject to the following restrictions:\n        //\n        // 1. The origin of this software must not be misrepresented; you must not\n        //   claim that you wrote the original software. If you use this software\n        //   in a product, an acknowledgment in the product documentation would be\n        //   appreciated but is not required.\n        // 2. Altered source versions must be plainly marked as such, and must not be\n        //   misrepresented as being the original software.\n        // 3. This notice may not be removed or altered from any source distribution.\n        var constants = {\n            /* Allowed flush values; see deflate() and inflate() below for details */\n            Z_NO_FLUSH: 0,\n            Z_PARTIAL_FLUSH: 1,\n            Z_SYNC_FLUSH: 2,\n            Z_FULL_FLUSH: 3,\n            Z_FINISH: 4,\n            Z_BLOCK: 5,\n            Z_TREES: 6,\n            /* Return codes for the compression/decompression functions. Negative values\n             * are errors, positive values are used for special but normal events.\n             */\n            Z_OK: 0,\n            Z_STREAM_END: 1,\n            Z_NEED_DICT: 2,\n            Z_ERRNO: -1,\n            Z_STREAM_ERROR: -2,\n            Z_DATA_ERROR: -3,\n            Z_MEM_ERROR: -4,\n            Z_BUF_ERROR: -5,\n            // Z_VERSION_ERROR: -6,\n            /* compression levels */\n            Z_NO_COMPRESSION: 0,\n            Z_BEST_SPEED: 1,\n            Z_BEST_COMPRESSION: 9,\n            Z_DEFAULT_COMPRESSION: -1,\n            Z_FILTERED: 1,\n            Z_HUFFMAN_ONLY: 2,\n            Z_RLE: 3,\n            Z_FIXED: 4,\n            Z_DEFAULT_STRATEGY: 0,\n            /* Possible values of the data_type field (though see inflate()) */\n            Z_BINARY: 0,\n            Z_TEXT: 1,\n            // Z_ASCII:                1, // = Z_TEXT (deprecated)\n            Z_UNKNOWN: 2,\n            /* The deflate compression method */\n            Z_DEFLATED: 8,\n        };\n        // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n        //\n        // This software is provided 'as-is', without any express or implied\n        // warranty. In no event will the authors be held liable for any damages\n        // arising from the use of this software.\n        //\n        // Permission is granted to anyone to use this software for any purpose,\n        // including commercial applications, and to alter it and redistribute it\n        // freely, subject to the following restrictions:\n        //\n        // 1. The origin of this software must not be misrepresented; you must not\n        //   claim that you wrote the original software. If you use this software\n        //   in a product, an acknowledgment in the product documentation would be\n        //   appreciated but is not required.\n        // 2. Altered source versions must be plainly marked as such, and must not be\n        //   misrepresented as being the original software.\n        // 3. This notice may not be removed or altered from any source distribution.\n        var _tr_init$1 = trees._tr_init;\n        var _tr_stored_block$1 = trees._tr_stored_block;\n        var _tr_flush_block$1 = trees._tr_flush_block;\n        var _tr_tally$1 = trees._tr_tally;\n        var _tr_align$1 = trees._tr_align;\n        /* Public constants ========================================================== */\n        /* =========================================================================== */\n        var Z_NO_FLUSH = constants.Z_NO_FLUSH;\n        var Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH;\n        var Z_FULL_FLUSH = constants.Z_FULL_FLUSH;\n        var Z_FINISH = constants.Z_FINISH;\n        var Z_BLOCK = constants.Z_BLOCK;\n        var Z_OK = constants.Z_OK;\n        var Z_STREAM_END = constants.Z_STREAM_END;\n        var Z_STREAM_ERROR = constants.Z_STREAM_ERROR;\n        var Z_DATA_ERROR = constants.Z_DATA_ERROR;\n        var Z_BUF_ERROR = constants.Z_BUF_ERROR;\n        var Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION;\n        var Z_FILTERED = constants.Z_FILTERED;\n        var Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY;\n        var Z_RLE = constants.Z_RLE;\n        var Z_FIXED$1 = constants.Z_FIXED;\n        var Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY;\n        var Z_UNKNOWN$1 = constants.Z_UNKNOWN;\n        var Z_DEFLATED = constants.Z_DEFLATED;\n        /* ============================================================================ */\n        var MAX_MEM_LEVEL = 9;\n        /* Maximum value for memLevel in deflateInit2 */\n        var MAX_WBITS = 15;\n        /* 32K LZ77 window */\n        var DEF_MEM_LEVEL = 8;\n        var LENGTH_CODES$1 = 29;\n        /* number of length codes, not counting the special END_BLOCK code */\n        var LITERALS$1 = 256;\n        /* number of literal bytes 0..255 */\n        var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;\n        /* number of Literal or Length codes, including the END_BLOCK code */\n        var D_CODES$1 = 30;\n        /* number of distance codes */\n        var BL_CODES$1 = 19;\n        /* number of codes used to transfer the bit lengths */\n        var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;\n        /* maximum heap size */\n        var MAX_BITS$1 = 15;\n        /* All codes must not exceed MAX_BITS bits */\n        var MIN_MATCH$1 = 3;\n        var MAX_MATCH$1 = 258;\n        var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;\n        var PRESET_DICT = 0x20;\n        var INIT_STATE = 42;\n        var EXTRA_STATE = 69;\n        var NAME_STATE = 73;\n        var COMMENT_STATE = 91;\n        var HCRC_STATE = 103;\n        var BUSY_STATE = 113;\n        var FINISH_STATE = 666;\n        var BS_NEED_MORE = 1;\n        /* block not completed, need more input or more output */\n        var BS_BLOCK_DONE = 2;\n        /* block flush performed */\n        var BS_FINISH_STARTED = 3;\n        /* finish started, need only more output at next deflate */\n        var BS_FINISH_DONE = 4;\n        /* finish done, accept no more input or output */\n        var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n        var err = function err(strm, errorCode) {\n            strm.msg = messages[errorCode];\n            return errorCode;\n        };\n        var rank = function rank(f) {\n            return (f << 1) - (f > 4 ? 9 : 0);\n        };\n        var zero$1 = function zero(buf) {\n            var len = buf.length;\n            while (--len >= 0) {\n                buf[len] = 0;\n            }\n        };\n        /* eslint-disable new-cap */\n        var HASH_ZLIB = function HASH_ZLIB(s, prev, data) {\n            return ((prev << s.hash_shift) ^ data) & s.hash_mask;\n        }; // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n        // But breaks binary compatibility\n        // let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n        var HASH = HASH_ZLIB;\n        /* =========================================================================\n         * Flush as much pending output as possible. All deflate() output goes\n         * through this function so some applications may wish to modify it\n         * to avoid allocating a large strm->output buffer and copying into it.\n         * (See also read_buf()).\n         */\n        var flush_pending = function flush_pending(strm) {\n            var s = strm.state; // _tr_flush_bits(s);\n            var len = s.pending;\n            if (len > strm.avail_out) {\n                len = strm.avail_out;\n            }\n            if (len === 0) {\n                return;\n            }\n            strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n            strm.next_out += len;\n            s.pending_out += len;\n            strm.total_out += len;\n            strm.avail_out -= len;\n            s.pending -= len;\n            if (s.pending === 0) {\n                s.pending_out = 0;\n            }\n        };\n        var flush_block_only = function flush_block_only(s, last) {\n            _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n            s.block_start = s.strstart;\n            flush_pending(s.strm);\n        };\n        var put_byte = function put_byte(s, b) {\n            s.pending_buf[s.pending++] = b;\n        };\n        /* =========================================================================\n         * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n         * IN assertion: the stream state is correct and there is enough room in\n         * pending_buf.\n         */\n        var putShortMSB = function putShortMSB(s, b) {\n            //  put_byte(s, (Byte)(b >> 8));\n            //  put_byte(s, (Byte)(b & 0xff));\n            s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n            s.pending_buf[s.pending++] = b & 0xff;\n        };\n        /* ===========================================================================\n         * Read a new buffer from the current input stream, update the adler32\n         * and total number of bytes read.  All deflate() input goes through\n         * this function so some applications may wish to modify it to avoid\n         * allocating a large strm->input buffer and copying from it.\n         * (See also flush_pending()).\n         */\n        var read_buf = function read_buf(strm, buf, start, size) {\n            var len = strm.avail_in;\n            if (len > size) {\n                len = size;\n            }\n            if (len === 0) {\n                return 0;\n            }\n            strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);\n            buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n            if (strm.state.wrap === 1) {\n                strm.adler = adler32_1(strm.adler, buf, len, start);\n            }\n            else if (strm.state.wrap === 2) {\n                strm.adler = crc32_1(strm.adler, buf, len, start);\n            }\n            strm.next_in += len;\n            strm.total_in += len;\n            return len;\n        };\n        /* ===========================================================================\n         * Set match_start to the longest match starting at the given string and\n         * return its length. Matches shorter or equal to prev_length are discarded,\n         * in which case the result is equal to prev_length and match_start is\n         * garbage.\n         * IN assertions: cur_match is the head of the hash chain for the current\n         *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n         * OUT assertion: the match length is not greater than s->lookahead.\n         */\n        var longest_match = function longest_match(s, cur_match) {\n            var chain_length = s.max_chain_length;\n            /* max hash chain length */\n            var scan = s.strstart;\n            /* current string */\n            var match;\n            /* matched string */\n            var len;\n            /* length of current match */\n            var best_len = s.prev_length;\n            /* best match length so far */\n            var nice_match = s.nice_match;\n            /* stop if match long enough */\n            var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n            /* NIL */\n            var _win = s.window; // shortcut\n            var wmask = s.w_mask;\n            var prev = s.prev;\n            /* Stop when cur_match becomes <= limit. To simplify the code,\n             * we prevent matches with the string of window index 0.\n             */\n            var strend = s.strstart + MAX_MATCH$1;\n            var scan_end1 = _win[scan + best_len - 1];\n            var scan_end = _win[scan + best_len];\n            /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n             * It is easy to get rid of this optimization if necessary.\n             */\n            // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n            /* Do not waste too much time if we already have a good match: */\n            if (s.prev_length >= s.good_match) {\n                chain_length >>= 2;\n            }\n            /* Do not look for matches beyond the end of the input. This is necessary\n             * to make deflate deterministic.\n             */\n            if (nice_match > s.lookahead) {\n                nice_match = s.lookahead;\n            } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n            do {\n                // Assert(cur_match < s->strstart, \"no future\");\n                match = cur_match;\n                /* Skip to next match if the match length cannot increase\n                 * or if the match length is less than 2.  Note that the checks below\n                 * for insufficient lookahead only occur occasionally for performance\n                 * reasons.  Therefore uninitialized memory will be accessed, and\n                 * conditional jumps will be made that depend on those values.\n                 * However the length of the match is limited to the lookahead, so\n                 * the output of deflate is not affected by the uninitialized values.\n                 */\n                if (_win[match + best_len] !== scan_end ||\n                    _win[match + best_len - 1] !== scan_end1 ||\n                    _win[match] !== _win[scan] ||\n                    _win[++match] !== _win[scan + 1]) {\n                    continue;\n                }\n                /* The check at best_len-1 can be removed because it will be made\n                 * again later. (This heuristic is not always a win.)\n                 * It is not necessary to compare scan[2] and match[2] since they\n                 * are always equal when the other bytes match, given that\n                 * the hash keys are equal and that HASH_BITS >= 8.\n                 */\n                scan += 2;\n                match++; // Assert(*scan == *match, \"match[2]?\");\n                /* We check for insufficient lookahead only every 8th comparison;\n                 * the 256th check will be made at strstart+258.\n                 */\n                do {\n                    /* jshint noempty:false */\n                } while (_win[++scan] === _win[++match] &&\n                    _win[++scan] === _win[++match] &&\n                    _win[++scan] === _win[++match] &&\n                    _win[++scan] === _win[++match] &&\n                    _win[++scan] === _win[++match] &&\n                    _win[++scan] === _win[++match] &&\n                    _win[++scan] === _win[++match] &&\n                    _win[++scan] === _win[++match] &&\n                    scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n                len = MAX_MATCH$1 - (strend - scan);\n                scan = strend - MAX_MATCH$1;\n                if (len > best_len) {\n                    s.match_start = cur_match;\n                    best_len = len;\n                    if (len >= nice_match) {\n                        break;\n                    }\n                    scan_end1 = _win[scan + best_len - 1];\n                    scan_end = _win[scan + best_len];\n                }\n            } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n            if (best_len <= s.lookahead) {\n                return best_len;\n            }\n            return s.lookahead;\n        };\n        /* ===========================================================================\n         * Fill the window when the lookahead becomes insufficient.\n         * Updates strstart and lookahead.\n         *\n         * IN assertion: lookahead < MIN_LOOKAHEAD\n         * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n         *    At least one byte has been read, or avail_in == 0; reads are\n         *    performed for at least two bytes (required for the zip translate_eol\n         *    option -- not supported here).\n         */\n        var fill_window = function fill_window(s) {\n            var _w_size = s.w_size;\n            var p;\n            var n;\n            var m;\n            var more;\n            var str; // Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n            do {\n                more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed\n                /* Deal with !@#$% 64K limit: */\n                // if (sizeof(int) <= 2) {\n                //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n                //        more = wsize;\n                //\n                //  } else if (more == (unsigned)(-1)) {\n                //        /* Very unlikely, but possible on 16 bit machine if\n                //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n                //         */\n                //        more--;\n                //    }\n                // }\n                /* If the window is almost full and there is insufficient lookahead,\n                 * move the upper half to the lower one to make room in the upper half.\n                 */\n                if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n                    s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n                    s.match_start -= _w_size;\n                    s.strstart -= _w_size;\n                    /* we now have strstart >= MAX_DIST */\n                    s.block_start -= _w_size;\n                    /* Slide the hash table (could be avoided with 32 bit values\n                   at the expense of memory usage). We slide even when level == 0\n                   to keep the hash table consistent if we switch back to level > 0\n                   later. (Using level 0 permanently is not an optimal usage of\n                   zlib, so we don't care about this pathological case.)\n                   */\n                    n = s.hash_size;\n                    p = n;\n                    do {\n                        m = s.head[--p];\n                        s.head[p] = m >= _w_size ? m - _w_size : 0;\n                    } while (--n);\n                    n = _w_size;\n                    p = n;\n                    do {\n                        m = s.prev[--p];\n                        s.prev[p] = m >= _w_size ? m - _w_size : 0;\n                        /* If n is not on any hash chain, prev[n] is garbage but\n                         * its value will never be used.\n                         */\n                    } while (--n);\n                    more += _w_size;\n                }\n                if (s.strm.avail_in === 0) {\n                    break;\n                }\n                /* If there was no sliding:\n                 *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n                 *    more == window_size - lookahead - strstart\n                 * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n                 * => more >= window_size - 2*WSIZE + 2\n                 * In the BIG_MEM or MMAP case (not yet supported),\n                 *   window_size == input_size + MIN_LOOKAHEAD  &&\n                 *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n                 * Otherwise, window_size == 2*WSIZE so more >= 2.\n                 * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n                 */\n                // Assert(more >= 2, \"more < 2\");\n                n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n                s.lookahead += n;\n                /* Initialize the hash value now that we have some input: */\n                if (s.lookahead + s.insert >= MIN_MATCH$1) {\n                    str = s.strstart - s.insert;\n                    s.ins_h = s.window[str];\n                    /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n                    s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); // #if MIN_MATCH != 3\n                    //        Call update_hash() MIN_MATCH-3 more times\n                    // #endif\n                    while (s.insert) {\n                        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n                        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n                        s.prev[str & s.w_mask] = s.head[s.ins_h];\n                        s.head[s.ins_h] = str;\n                        str++;\n                        s.insert--;\n                        if (s.lookahead + s.insert < MIN_MATCH$1) {\n                            break;\n                        }\n                    }\n                }\n                /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n                 * but this is not important since only literal bytes will be emitted.\n                 */\n            } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n            /* If the WIN_INIT bytes after the end of the current data have never been\n             * written, then zero those bytes in order to avoid memory check reports of\n             * the use of uninitialized (or uninitialised as Julian writes) bytes by\n             * the longest match routines.  Update the high water mark for the next\n             * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n             * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n             */\n            //  if (s.high_water < s.window_size) {\n            //    const curr = s.strstart + s.lookahead;\n            //    let init = 0;\n            //\n            //    if (s.high_water < curr) {\n            //      /* Previous high water mark below current data -- zero WIN_INIT\n            //       * bytes or up to end of window, whichever is less.\n            //       */\n            //      init = s.window_size - curr;\n            //      if (init > WIN_INIT)\n            //        init = WIN_INIT;\n            //      zmemzero(s->window + curr, (unsigned)init);\n            //      s->high_water = curr + init;\n            //    }\n            //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n            //      /* High water mark at or above current data, but below current data\n            //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n            //       * to end of window, whichever is less.\n            //       */\n            //      init = (ulg)curr + WIN_INIT - s->high_water;\n            //      if (init > s->window_size - s->high_water)\n            //        init = s->window_size - s->high_water;\n            //      zmemzero(s->window + s->high_water, (unsigned)init);\n            //      s->high_water += init;\n            //    }\n            //  }\n            //\n            //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n            //    \"not enough room for search\");\n        };\n        /* ===========================================================================\n         * Copy without compression as much as possible from the input stream, return\n         * the current block state.\n         * This function does not insert new strings in the dictionary since\n         * uncompressible data is probably not useful. This function is used\n         * only for the level=0 compression option.\n         * NOTE: this function should be optimized to avoid extra copying from\n         * window to pending_buf.\n         */\n        var deflate_stored = function deflate_stored(s, flush) {\n            /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n             * to pending_buf_size, and each stored block has a 5 byte header:\n             */\n            var max_block_size = 0xffff;\n            if (max_block_size > s.pending_buf_size - 5) {\n                max_block_size = s.pending_buf_size - 5;\n            }\n            /* Copy as much as possible from input to output: */\n            for (;;) {\n                /* Fill the window as much as possible: */\n                if (s.lookahead <= 1) {\n                    // Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n                    //  s->block_start >= (long)s->w_size, \"slide too late\");\n                    //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n                    //        s.block_start >= s.w_size)) {\n                    //        throw  new Error(\"slide too late\");\n                    //      }\n                    fill_window(s);\n                    if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n                        return BS_NEED_MORE;\n                    }\n                    if (s.lookahead === 0) {\n                        break;\n                    }\n                    /* flush the current block */\n                } // Assert(s->block_start >= 0L, \"block gone\");\n                //    if (s.block_start < 0) throw new Error(\"block gone\");\n                s.strstart += s.lookahead;\n                s.lookahead = 0;\n                /* Emit a stored block if pending_buf will be full: */\n                var max_start = s.block_start + max_block_size;\n                if (s.strstart === 0 || s.strstart >= max_start) {\n                    /* strstart == 0 is possible when wraparound on 16-bit machine */\n                    s.lookahead = s.strstart - max_start;\n                    s.strstart = max_start;\n                    /** * FLUSH_BLOCK(s, 0); ** */\n                    flush_block_only(s, false);\n                    if (s.strm.avail_out === 0) {\n                        return BS_NEED_MORE;\n                    }\n                    /***/\n                }\n                /* Flush if we may have to slide, otherwise block_start may become\n                 * negative and the data will be gone:\n                 */\n                if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n                    /** * FLUSH_BLOCK(s, 0); ** */\n                    flush_block_only(s, false);\n                    if (s.strm.avail_out === 0) {\n                        return BS_NEED_MORE;\n                    }\n                    /***/\n                }\n            }\n            s.insert = 0;\n            if (flush === Z_FINISH) {\n                /** * FLUSH_BLOCK(s, 1); ** */\n                flush_block_only(s, true);\n                if (s.strm.avail_out === 0) {\n                    return BS_FINISH_STARTED;\n                }\n                /***/\n                return BS_FINISH_DONE;\n            }\n            if (s.strstart > s.block_start) {\n                /** * FLUSH_BLOCK(s, 0); ** */\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n                /***/\n            }\n            return BS_NEED_MORE;\n        };\n        /* ===========================================================================\n         * Compress as much as possible from the input stream, return the current\n         * block state.\n         * This function does not perform lazy evaluation of matches and inserts\n         * new strings in the dictionary only for unmatched strings or for short\n         * matches. It is used only for the fast compression options.\n         */\n        var deflate_fast = function deflate_fast(s, flush) {\n            var hash_head;\n            /* head of the hash chain */\n            var bflush;\n            /* set if current block must be flushed */\n            for (;;) {\n                /* Make sure that we always have enough lookahead, except\n                 * at the end of the input file. We need MAX_MATCH bytes\n                 * for the next match, plus MIN_MATCH bytes to insert the\n                 * string following the next match.\n                 */\n                if (s.lookahead < MIN_LOOKAHEAD) {\n                    fill_window(s);\n                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                        return BS_NEED_MORE;\n                    }\n                    if (s.lookahead === 0) {\n                        break;\n                        /* flush the current block */\n                    }\n                }\n                /* Insert the string window[strstart .. strstart+2] in the\n                 * dictionary, and set hash_head to the head of the hash chain:\n                 */\n                hash_head = 0;\n                /* NIL */\n                if (s.lookahead >= MIN_MATCH$1) {\n                    /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                    /***/\n                }\n                /* Find the longest match, discarding those <= prev_length.\n                 * At this point we have always match_length < MIN_MATCH\n                 */\n                if (hash_head !== 0 &&\n                    /* NIL */\n                    s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n                    /* To simplify the code, we prevent matches with the string\n                     * of window index 0 (in particular we have to avoid a match\n                     * of the string with itself at the start of the input file).\n                     */\n                    s.match_length = longest_match(s, hash_head);\n                    /* longest_match() sets match_start */\n                }\n                if (s.match_length >= MIN_MATCH$1) {\n                    // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n                    /** * _tr_tally_dist(s, s.strstart - s.match_start,\n                                 s.match_length - MIN_MATCH, bflush); ** */\n                    bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);\n                    s.lookahead -= s.match_length;\n                    /* Insert new strings in the hash table only if the match length\n                     * is not too large. This saves time but degrades compression.\n                     */\n                    if (s.match_length <= s.max_lazy_match &&\n                        /* max_insert_length */\n                        s.lookahead >= MIN_MATCH$1) {\n                        s.match_length--;\n                        /* string at strstart already in table */\n                        do {\n                            s.strstart++;\n                            /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n                            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                            s.head[s.ins_h] = s.strstart;\n                            /***/\n                            /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                             * always MIN_MATCH bytes ahead.\n                             */\n                        } while (--s.match_length !== 0);\n                        s.strstart++;\n                    }\n                    else {\n                        s.strstart += s.match_length;\n                        s.match_length = 0;\n                        s.ins_h = s.window[s.strstart];\n                        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]); // #if MIN_MATCH != 3\n                        //                Call UPDATE_HASH() MIN_MATCH-3 more times\n                        // #endif\n                        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n                         * matter since it will be recomputed at next deflate call.\n                         */\n                    }\n                }\n                else {\n                    /* No match, output a literal byte */\n                    // Tracevv((stderr,\"%c\", s.window[s.strstart]));\n                    /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n                    bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n                    s.lookahead--;\n                    s.strstart++;\n                }\n                if (bflush) {\n                    /** * FLUSH_BLOCK(s, 0); ** */\n                    flush_block_only(s, false);\n                    if (s.strm.avail_out === 0) {\n                        return BS_NEED_MORE;\n                    }\n                    /***/\n                }\n            }\n            s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n            if (flush === Z_FINISH) {\n                /** * FLUSH_BLOCK(s, 1); ** */\n                flush_block_only(s, true);\n                if (s.strm.avail_out === 0) {\n                    return BS_FINISH_STARTED;\n                }\n                /***/\n                return BS_FINISH_DONE;\n            }\n            if (s.last_lit) {\n                /** * FLUSH_BLOCK(s, 0); ** */\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n                /***/\n            }\n            return BS_BLOCK_DONE;\n        };\n        /* ===========================================================================\n         * Same as above, but achieves better compression. We use a lazy\n         * evaluation for matches: a match is finally adopted only if there is\n         * no better match at the next window position.\n         */\n        var deflate_slow = function deflate_slow(s, flush) {\n            var hash_head;\n            /* head of hash chain */\n            var bflush;\n            /* set if current block must be flushed */\n            var max_insert;\n            /* Process the input block. */\n            for (;;) {\n                /* Make sure that we always have enough lookahead, except\n                 * at the end of the input file. We need MAX_MATCH bytes\n                 * for the next match, plus MIN_MATCH bytes to insert the\n                 * string following the next match.\n                 */\n                if (s.lookahead < MIN_LOOKAHEAD) {\n                    fill_window(s);\n                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                        return BS_NEED_MORE;\n                    }\n                    if (s.lookahead === 0) {\n                        break;\n                    }\n                    /* flush the current block */\n                }\n                /* Insert the string window[strstart .. strstart+2] in the\n                 * dictionary, and set hash_head to the head of the hash chain:\n                 */\n                hash_head = 0;\n                /* NIL */\n                if (s.lookahead >= MIN_MATCH$1) {\n                    /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                    /***/\n                }\n                /* Find the longest match, discarding those <= prev_length.\n                 */\n                s.prev_length = s.match_length;\n                s.prev_match = s.match_start;\n                s.match_length = MIN_MATCH$1 - 1;\n                if (hash_head !== 0 &&\n                    /* NIL */\n                    s.prev_length < s.max_lazy_match &&\n                    s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n                /* MAX_DIST(s) */\n                ) {\n                    /* To simplify the code, we prevent matches with the string\n                     * of window index 0 (in particular we have to avoid a match\n                     * of the string with itself at the start of the input file).\n                     */\n                    s.match_length = longest_match(s, hash_head);\n                    /* longest_match() sets match_start */\n                    if (s.match_length <= 5 &&\n                        (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096))\n                    /* TOO_FAR */\n                    ) {\n                        /* If prev_match is also MIN_MATCH, match_start is garbage\n                         * but we will ignore the current match anyway.\n                         */\n                        s.match_length = MIN_MATCH$1 - 1;\n                    }\n                }\n                /* If there was a match at the previous step and the current\n                 * match is not better, output the previous match:\n                 */\n                if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {\n                    max_insert = s.strstart + s.lookahead - MIN_MATCH$1;\n                    /* Do not insert strings in hash table beyond this. */\n                    // check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n                    /** *_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                                 s.prev_length - MIN_MATCH, bflush);** */\n                    bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);\n                    /* Insert in hash table all strings up to the end of the match.\n                     * strstart-1 and strstart are already inserted. If there is not\n                     * enough lookahead, the last two strings are not inserted in\n                     * the hash table.\n                     */\n                    s.lookahead -= s.prev_length - 1;\n                    s.prev_length -= 2;\n                    do {\n                        if (++s.strstart <= max_insert) {\n                            /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n                            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);\n                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                            s.head[s.ins_h] = s.strstart;\n                            /***/\n                        }\n                    } while (--s.prev_length !== 0);\n                    s.match_available = 0;\n                    s.match_length = MIN_MATCH$1 - 1;\n                    s.strstart++;\n                    if (bflush) {\n                        /** * FLUSH_BLOCK(s, 0); ** */\n                        flush_block_only(s, false);\n                        if (s.strm.avail_out === 0) {\n                            return BS_NEED_MORE;\n                        }\n                        /***/\n                    }\n                }\n                else if (s.match_available) {\n                    /* If there was no match at the previous position, output a\n                     * single literal. If there was a match but the current match\n                     * is longer, truncate the previous match to a single literal.\n                     */\n                    // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n                    /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n                    bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n                    if (bflush) {\n                        /** * FLUSH_BLOCK_ONLY(s, 0) ** */\n                        flush_block_only(s, false);\n                        /***/\n                    }\n                    s.strstart++;\n                    s.lookahead--;\n                    if (s.strm.avail_out === 0) {\n                        return BS_NEED_MORE;\n                    }\n                }\n                else {\n                    /* There is no previous match to compare with, wait for\n                     * the next step to decide.\n                     */\n                    s.match_available = 1;\n                    s.strstart++;\n                    s.lookahead--;\n                }\n            } // Assert (flush != Z_NO_FLUSH, \"no flush?\");\n            if (s.match_available) {\n                // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n                /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n                bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);\n                s.match_available = 0;\n            }\n            s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;\n            if (flush === Z_FINISH) {\n                /** * FLUSH_BLOCK(s, 1); ** */\n                flush_block_only(s, true);\n                if (s.strm.avail_out === 0) {\n                    return BS_FINISH_STARTED;\n                }\n                /***/\n                return BS_FINISH_DONE;\n            }\n            if (s.last_lit) {\n                /** * FLUSH_BLOCK(s, 0); ** */\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n                /***/\n            }\n            return BS_BLOCK_DONE;\n        };\n        /* ===========================================================================\n         * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n         * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n         * deflate switches away from Z_RLE.)\n         */\n        var deflate_rle = function deflate_rle(s, flush) {\n            var bflush;\n            /* set if current block must be flushed */\n            var prev;\n            /* byte at distance one to match */\n            var scan;\n            var strend;\n            /* scan goes up to strend for length of run */\n            var _win = s.window;\n            for (;;) {\n                /* Make sure that we always have enough lookahead, except\n                 * at the end of the input file. We need MAX_MATCH bytes\n                 * for the longest run, plus one for the unrolled loop.\n                 */\n                if (s.lookahead <= MAX_MATCH$1) {\n                    fill_window(s);\n                    if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {\n                        return BS_NEED_MORE;\n                    }\n                    if (s.lookahead === 0) {\n                        break;\n                    }\n                    /* flush the current block */\n                }\n                /* See how many times the previous byte repeats */\n                s.match_length = 0;\n                if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {\n                    scan = s.strstart - 1;\n                    prev = _win[scan];\n                    if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n                        strend = s.strstart + MAX_MATCH$1;\n                        do {\n                            /* jshint noempty:false */\n                        } while (prev === _win[++scan] &&\n                            prev === _win[++scan] &&\n                            prev === _win[++scan] &&\n                            prev === _win[++scan] &&\n                            prev === _win[++scan] &&\n                            prev === _win[++scan] &&\n                            prev === _win[++scan] &&\n                            prev === _win[++scan] &&\n                            scan < strend);\n                        s.match_length = MAX_MATCH$1 - (strend - scan);\n                        if (s.match_length > s.lookahead) {\n                            s.match_length = s.lookahead;\n                        }\n                    } // Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n                }\n                /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n                if (s.match_length >= MIN_MATCH$1) {\n                    // check_match(s, s.strstart, s.strstart - 1, s.match_length);\n                    /** * _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ** */\n                    bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);\n                    s.lookahead -= s.match_length;\n                    s.strstart += s.match_length;\n                    s.match_length = 0;\n                }\n                else {\n                    /* No match, output a literal byte */\n                    // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n                    /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n                    bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n                    s.lookahead--;\n                    s.strstart++;\n                }\n                if (bflush) {\n                    /** * FLUSH_BLOCK(s, 0); ** */\n                    flush_block_only(s, false);\n                    if (s.strm.avail_out === 0) {\n                        return BS_NEED_MORE;\n                    }\n                    /***/\n                }\n            }\n            s.insert = 0;\n            if (flush === Z_FINISH) {\n                /** * FLUSH_BLOCK(s, 1); ** */\n                flush_block_only(s, true);\n                if (s.strm.avail_out === 0) {\n                    return BS_FINISH_STARTED;\n                }\n                /***/\n                return BS_FINISH_DONE;\n            }\n            if (s.last_lit) {\n                /** * FLUSH_BLOCK(s, 0); ** */\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n                /***/\n            }\n            return BS_BLOCK_DONE;\n        };\n        /* ===========================================================================\n         * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n         * (It will be regenerated if this run of deflate switches away from Huffman.)\n         */\n        var deflate_huff = function deflate_huff(s, flush) {\n            var bflush;\n            /* set if current block must be flushed */\n            for (;;) {\n                /* Make sure that we have a literal to write. */\n                if (s.lookahead === 0) {\n                    fill_window(s);\n                    if (s.lookahead === 0) {\n                        if (flush === Z_NO_FLUSH) {\n                            return BS_NEED_MORE;\n                        }\n                        break;\n                        /* flush the current block */\n                    }\n                }\n                /* Output a literal byte */\n                s.match_length = 0; // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n                /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n                bflush = _tr_tally$1(s, 0, s.window[s.strstart]);\n                s.lookahead--;\n                s.strstart++;\n                if (bflush) {\n                    /** * FLUSH_BLOCK(s, 0); ** */\n                    flush_block_only(s, false);\n                    if (s.strm.avail_out === 0) {\n                        return BS_NEED_MORE;\n                    }\n                    /***/\n                }\n            }\n            s.insert = 0;\n            if (flush === Z_FINISH) {\n                /** * FLUSH_BLOCK(s, 1); ** */\n                flush_block_only(s, true);\n                if (s.strm.avail_out === 0) {\n                    return BS_FINISH_STARTED;\n                }\n                /***/\n                return BS_FINISH_DONE;\n            }\n            if (s.last_lit) {\n                /** * FLUSH_BLOCK(s, 0); ** */\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n                /***/\n            }\n            return BS_BLOCK_DONE;\n        };\n        /* Values for max_lazy_match, good_match and max_chain_length, depending on\n         * the desired pack level (0..9). The values given below have been tuned to\n         * exclude worst case performance for pathological files. Better values may be\n         * found for specific files.\n         */\n        function Config(good_length, max_lazy, nice_length, max_chain, func) {\n            this.good_length = good_length;\n            this.max_lazy = max_lazy;\n            this.nice_length = nice_length;\n            this.max_chain = max_chain;\n            this.func = func;\n        }\n        var configuration_table = [\n            /*      good lazy nice chain */\n            new Config(0, 0, 0, 0, deflate_stored),\n            /* 0 store only */\n            new Config(4, 4, 8, 4, deflate_fast),\n            /* 1 max speed, no lazy matches */\n            new Config(4, 5, 16, 8, deflate_fast),\n            /* 2 */\n            new Config(4, 6, 32, 32, deflate_fast),\n            /* 3 */\n            new Config(4, 4, 16, 16, deflate_slow),\n            /* 4 lazy matches */\n            new Config(8, 16, 32, 32, deflate_slow),\n            /* 5 */\n            new Config(8, 16, 128, 128, deflate_slow),\n            /* 6 */\n            new Config(8, 32, 128, 256, deflate_slow),\n            /* 7 */\n            new Config(32, 128, 258, 1024, deflate_slow),\n            /* 8 */\n            new Config(32, 258, 258, 4096, deflate_slow),\n        ];\n        /* ===========================================================================\n         * Initialize the \"longest match\" routines for a new zlib stream\n         */\n        var lm_init = function lm_init(s) {\n            s.window_size = 2 * s.w_size;\n            /** * CLEAR_HASH(s); ** */\n            zero$1(s.head); // Fill with NIL (= 0);\n            /* Set the default configuration parameters:\n             */\n            s.max_lazy_match = configuration_table[s.level].max_lazy;\n            s.good_match = configuration_table[s.level].good_length;\n            s.nice_match = configuration_table[s.level].nice_length;\n            s.max_chain_length = configuration_table[s.level].max_chain;\n            s.strstart = 0;\n            s.block_start = 0;\n            s.lookahead = 0;\n            s.insert = 0;\n            s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n            s.match_available = 0;\n            s.ins_h = 0;\n        };\n        function DeflateState() {\n            this.strm = null;\n            /* pointer back to this zlib stream */\n            this.status = 0;\n            /* as the name implies */\n            this.pending_buf = null;\n            /* output still pending */\n            this.pending_buf_size = 0;\n            /* size of pending_buf */\n            this.pending_out = 0;\n            /* next pending byte to output to the stream */\n            this.pending = 0;\n            /* nb of bytes in the pending buffer */\n            this.wrap = 0;\n            /* bit 0 true for zlib, bit 1 true for gzip */\n            this.gzhead = null;\n            /* gzip header information to write */\n            this.gzindex = 0;\n            /* where in extra, name, or comment */\n            this.method = Z_DEFLATED;\n            /* can only be DEFLATED */\n            this.last_flush = -1;\n            /* value of flush param for previous deflate call */\n            this.w_size = 0;\n            /* LZ77 window size (32K by default) */\n            this.w_bits = 0;\n            /* log2(w_size)  (8..16) */\n            this.w_mask = 0;\n            /* w_size - 1 */\n            this.window = null;\n            /* Sliding window. Input bytes are read into the second half of the window,\n             * and move to the first half later to keep a dictionary of at least wSize\n             * bytes. With this organization, matches are limited to a distance of\n             * wSize-MAX_MATCH bytes, but this ensures that IO is always\n             * performed with a length multiple of the block size.\n             */\n            this.window_size = 0;\n            /* Actual size of window: 2*wSize, except when the user input buffer\n             * is directly used as sliding window.\n             */\n            this.prev = null;\n            /* Link to older string with same hash index. To limit the size of this\n             * array to 64K, this link is maintained only for the last 32K strings.\n             * An index in this array is thus a window index modulo 32K.\n             */\n            this.head = null;\n            /* Heads of the hash chains or NIL. */\n            this.ins_h = 0;\n            /* hash index of string to be inserted */\n            this.hash_size = 0;\n            /* number of elements in hash table */\n            this.hash_bits = 0;\n            /* log2(hash_size) */\n            this.hash_mask = 0;\n            /* hash_size-1 */\n            this.hash_shift = 0;\n            /* Number of bits by which ins_h must be shifted at each input\n             * step. It must be such that after MIN_MATCH steps, the oldest\n             * byte no longer takes part in the hash key, that is:\n             *   hash_shift * MIN_MATCH >= hash_bits\n             */\n            this.block_start = 0;\n            /* Window position at the beginning of the current output block. Gets\n             * negative when the window is moved backwards.\n             */\n            this.match_length = 0;\n            /* length of best match */\n            this.prev_match = 0;\n            /* previous match */\n            this.match_available = 0;\n            /* set if previous match exists */\n            this.strstart = 0;\n            /* start of string to insert */\n            this.match_start = 0;\n            /* start of matching string */\n            this.lookahead = 0;\n            /* number of valid bytes ahead in window */\n            this.prev_length = 0;\n            /* Length of the best match at previous step. Matches not greater than this\n             * are discarded. This is used in the lazy match evaluation.\n             */\n            this.max_chain_length = 0;\n            /* To speed up deflation, hash chains are never searched beyond this\n             * length.  A higher limit improves compression ratio but degrades the\n             * speed.\n             */\n            this.max_lazy_match = 0;\n            /* Attempt to find a better match only when the current match is strictly\n             * smaller than this value. This mechanism is used only for compression\n             * levels >= 4.\n             */\n            // That's alias to max_lazy_match, don't use directly\n            // this.max_insert_length = 0;\n            /* Insert new strings in the hash table only if the match length is not\n             * greater than this length. This saves time but degrades compression.\n             * max_insert_length is used only for compression levels <= 3.\n             */\n            this.level = 0;\n            /* compression level (1..9) */\n            this.strategy = 0;\n            /* favor or force Huffman coding */\n            this.good_match = 0;\n            /* Use a faster search when the previous match is longer than this */\n            this.nice_match = 0;\n            /* Stop searching when current match exceeds this */\n            /* used by trees.c: */\n            /* Didn't use ct_data typedef below to suppress compiler warning */\n            // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n            // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n            // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n            // Use flat array of DOUBLE size, with interleaved fata,\n            // because JS does not support effective\n            this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2);\n            this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2);\n            this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2);\n            zero$1(this.dyn_ltree);\n            zero$1(this.dyn_dtree);\n            zero$1(this.bl_tree);\n            this.l_desc = null;\n            /* desc. for literal tree */\n            this.d_desc = null;\n            /* desc. for distance tree */\n            this.bl_desc = null;\n            /* desc. for bit length tree */\n            // ush bl_count[MAX_BITS+1];\n            this.bl_count = new Uint16Array(MAX_BITS$1 + 1);\n            /* number of codes at each bit length for an optimal tree */\n            // int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n            this.heap = new Uint16Array(2 * L_CODES$1 + 1);\n            /* heap used to build the Huffman trees */\n            zero$1(this.heap);\n            this.heap_len = 0;\n            /* number of elements in the heap */\n            this.heap_max = 0;\n            /* element of largest frequency */\n            /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n             * The same heap array is used to build all trees.\n             */\n            this.depth = new Uint16Array(2 * L_CODES$1 + 1); // uch depth[2*L_CODES+1];\n            zero$1(this.depth);\n            /* Depth of each subtree used as tie breaker for trees of equal frequency\n             */\n            this.l_buf = 0;\n            /* buffer index for literals or lengths */\n            this.lit_bufsize = 0;\n            /* Size of match buffer for literals/lengths.  There are 4 reasons for\n             * limiting lit_bufsize to 64K:\n             *   - frequencies can be kept in 16 bit counters\n             *   - if compression is not successful for the first block, all input\n             *     data is still in the window so we can still emit a stored block even\n             *     when input comes from standard input.  (This can also be done for\n             *     all blocks if lit_bufsize is not greater than 32K.)\n             *   - if compression is not successful for a file smaller than 64K, we can\n             *     even emit a stored file instead of a stored block (saving 5 bytes).\n             *     This is applicable only for zip (not gzip or zlib).\n             *   - creating new Huffman trees less frequently may not provide fast\n             *     adaptation to changes in the input data statistics. (Take for\n             *     example a binary file with poorly compressible code followed by\n             *     a highly compressible string table.) Smaller buffer sizes give\n             *     fast adaptation but have of course the overhead of transmitting\n             *     trees more frequently.\n             *   - I can't count above 4\n             */\n            this.last_lit = 0;\n            /* running index in l_buf */\n            this.d_buf = 0;\n            /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n             * the same number of elements. To use different lengths, an extra flag\n             * array would be necessary.\n             */\n            this.opt_len = 0;\n            /* bit length of current block with optimal trees */\n            this.static_len = 0;\n            /* bit length of current block with static trees */\n            this.matches = 0;\n            /* number of string matches in current block */\n            this.insert = 0;\n            /* bytes at end of window left to insert */\n            this.bi_buf = 0;\n            /* Output buffer. bits are inserted starting at the bottom (least\n             * significant bits).\n             */\n            this.bi_valid = 0;\n            /* Number of valid bits in bi_buf.  All bits above the last valid bit\n             * are always zero.\n             */\n            // Used for window memory init. We safely ignore it for JS. That makes\n            // sense only for pointers and memory check tools.\n            // this.high_water = 0;\n            /* High water mark offset in window for initialized bytes -- bytes above\n             * this are set to zero in order to avoid memory check warnings when\n             * longest match routines access bytes past the input.  This is then\n             * updated to the new high water mark.\n             */\n        }\n        var deflateResetKeep = function deflateResetKeep(strm) {\n            if (!strm || !strm.state) {\n                return err(strm, Z_STREAM_ERROR);\n            }\n            strm.total_in = strm.total_out = 0;\n            strm.data_type = Z_UNKNOWN$1;\n            var s = strm.state;\n            s.pending = 0;\n            s.pending_out = 0;\n            if (s.wrap < 0) {\n                s.wrap = -s.wrap;\n                /* was made negative by deflate(..., Z_FINISH); */\n            }\n            s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n            strm.adler =\n                s.wrap === 2\n                    ? 0 // crc32(0, Z_NULL, 0)\n                    : 1; // adler32(0, Z_NULL, 0)\n            s.last_flush = Z_NO_FLUSH;\n            _tr_init$1(s);\n            return Z_OK;\n        };\n        var deflateReset = function deflateReset(strm) {\n            var ret = deflateResetKeep(strm);\n            if (ret === Z_OK) {\n                lm_init(strm.state);\n            }\n            return ret;\n        };\n        var deflateSetHeader = function deflateSetHeader(strm, head) {\n            if (!strm || !strm.state) {\n                return Z_STREAM_ERROR;\n            }\n            if (strm.state.wrap !== 2) {\n                return Z_STREAM_ERROR;\n            }\n            strm.state.gzhead = head;\n            return Z_OK;\n        };\n        var deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n            if (!strm) {\n                // === Z_NULL\n                return Z_STREAM_ERROR;\n            }\n            var wrap = 1;\n            if (level === Z_DEFAULT_COMPRESSION) {\n                level = 6;\n            }\n            if (windowBits < 0) {\n                /* suppress zlib wrapper */\n                wrap = 0;\n                windowBits = -windowBits;\n            }\n            else if (windowBits > 15) {\n                wrap = 2;\n                /* write gzip wrapper instead */\n                windowBits -= 16;\n            }\n            if (memLevel < 1 ||\n                memLevel > MAX_MEM_LEVEL ||\n                method !== Z_DEFLATED ||\n                windowBits < 8 ||\n                windowBits > 15 ||\n                level < 0 ||\n                level > 9 ||\n                strategy < 0 ||\n                strategy > Z_FIXED$1) {\n                return err(strm, Z_STREAM_ERROR);\n            }\n            if (windowBits === 8) {\n                windowBits = 9;\n            }\n            /* until 256-byte window bug fixed */\n            var s = new DeflateState();\n            strm.state = s;\n            s.strm = strm;\n            s.wrap = wrap;\n            s.gzhead = null;\n            s.w_bits = windowBits;\n            s.w_size = 1 << s.w_bits;\n            s.w_mask = s.w_size - 1;\n            s.hash_bits = memLevel + 7;\n            s.hash_size = 1 << s.hash_bits;\n            s.hash_mask = s.hash_size - 1;\n            s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);\n            s.window = new Uint8Array(s.w_size * 2);\n            s.head = new Uint16Array(s.hash_size);\n            s.prev = new Uint16Array(s.w_size); // Don't need mem init magic for JS.\n            // s.high_water = 0;  /* nothing written to s->window yet */\n            s.lit_bufsize = 1 << (memLevel + 6);\n            /* 16K elements by default */\n            s.pending_buf_size = s.lit_bufsize * 4; // overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n            // s->pending_buf = (uchf *) overlay;\n            s.pending_buf = new Uint8Array(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n            // s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n            s.d_buf = 1 * s.lit_bufsize; // s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n            s.l_buf = (1 + 2) * s.lit_bufsize;\n            s.level = level;\n            s.strategy = strategy;\n            s.method = method;\n            return deflateReset(strm);\n        };\n        var deflateInit = function deflateInit(strm, level) {\n            return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n        };\n        var deflate = function deflate(strm, flush) {\n            var beg;\n            var val; // for gzip header write only\n            if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n                return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n            }\n            var s = strm.state;\n            if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n                return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n            }\n            s.strm = strm;\n            /* just in case */\n            var old_flush = s.last_flush;\n            s.last_flush = flush;\n            /* Write the header */\n            if (s.status === INIT_STATE) {\n                if (s.wrap === 2) {\n                    // GZIP header\n                    strm.adler = 0; // crc32(0L, Z_NULL, 0);\n                    put_byte(s, 31);\n                    put_byte(s, 139);\n                    put_byte(s, 8);\n                    if (!s.gzhead) {\n                        // s->gzhead == Z_NULL\n                        put_byte(s, 0);\n                        put_byte(s, 0);\n                        put_byte(s, 0);\n                        put_byte(s, 0);\n                        put_byte(s, 0);\n                        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                        put_byte(s, OS_CODE);\n                        s.status = BUSY_STATE;\n                    }\n                    else {\n                        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                            (s.gzhead.hcrc ? 2 : 0) +\n                            (!s.gzhead.extra ? 0 : 4) +\n                            (!s.gzhead.name ? 0 : 8) +\n                            (!s.gzhead.comment ? 0 : 16));\n                        put_byte(s, s.gzhead.time & 0xff);\n                        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n                        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n                        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n                        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                        put_byte(s, s.gzhead.os & 0xff);\n                        if (s.gzhead.extra && s.gzhead.extra.length) {\n                            put_byte(s, s.gzhead.extra.length & 0xff);\n                            put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n                        }\n                        if (s.gzhead.hcrc) {\n                            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n                        }\n                        s.gzindex = 0;\n                        s.status = EXTRA_STATE;\n                    }\n                } // DEFLATE header\n                else {\n                    var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n                    var level_flags = -1;\n                    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n                        level_flags = 0;\n                    }\n                    else if (s.level < 6) {\n                        level_flags = 1;\n                    }\n                    else if (s.level === 6) {\n                        level_flags = 2;\n                    }\n                    else {\n                        level_flags = 3;\n                    }\n                    header |= level_flags << 6;\n                    if (s.strstart !== 0) {\n                        header |= PRESET_DICT;\n                    }\n                    header += 31 - (header % 31);\n                    s.status = BUSY_STATE;\n                    putShortMSB(s, header);\n                    /* Save the adler32 of the preset dictionary: */\n                    if (s.strstart !== 0) {\n                        putShortMSB(s, strm.adler >>> 16);\n                        putShortMSB(s, strm.adler & 0xffff);\n                    }\n                    strm.adler = 1; // adler32(0L, Z_NULL, 0);\n                }\n            } // #ifdef GZIP\n            if (s.status === EXTRA_STATE) {\n                if (s.gzhead.extra\n                /* != Z_NULL */\n                ) {\n                    beg = s.pending;\n                    /* start of bytes to update crc */\n                    while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n                        if (s.pending === s.pending_buf_size) {\n                            if (s.gzhead.hcrc && s.pending > beg) {\n                                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n                            }\n                            flush_pending(strm);\n                            beg = s.pending;\n                            if (s.pending === s.pending_buf_size) {\n                                break;\n                            }\n                        }\n                        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n                        s.gzindex++;\n                    }\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    if (s.gzindex === s.gzhead.extra.length) {\n                        s.gzindex = 0;\n                        s.status = NAME_STATE;\n                    }\n                }\n                else {\n                    s.status = NAME_STATE;\n                }\n            }\n            if (s.status === NAME_STATE) {\n                if (s.gzhead.name\n                /* != Z_NULL */\n                ) {\n                    beg = s.pending;\n                    /* start of bytes to update crc */\n                    // int val;\n                    do {\n                        if (s.pending === s.pending_buf_size) {\n                            if (s.gzhead.hcrc && s.pending > beg) {\n                                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n                            }\n                            flush_pending(strm);\n                            beg = s.pending;\n                            if (s.pending === s.pending_buf_size) {\n                                val = 1;\n                                break;\n                            }\n                        } // JS specific: little magic to add zero terminator to end of string\n                        if (s.gzindex < s.gzhead.name.length) {\n                            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n                        }\n                        else {\n                            val = 0;\n                        }\n                        put_byte(s, val);\n                    } while (val !== 0);\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    if (val === 0) {\n                        s.gzindex = 0;\n                        s.status = COMMENT_STATE;\n                    }\n                }\n                else {\n                    s.status = COMMENT_STATE;\n                }\n            }\n            if (s.status === COMMENT_STATE) {\n                if (s.gzhead.comment\n                /* != Z_NULL */\n                ) {\n                    beg = s.pending;\n                    /* start of bytes to update crc */\n                    // int val;\n                    do {\n                        if (s.pending === s.pending_buf_size) {\n                            if (s.gzhead.hcrc && s.pending > beg) {\n                                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n                            }\n                            flush_pending(strm);\n                            beg = s.pending;\n                            if (s.pending === s.pending_buf_size) {\n                                val = 1;\n                                break;\n                            }\n                        } // JS specific: little magic to add zero terminator to end of string\n                        if (s.gzindex < s.gzhead.comment.length) {\n                            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n                        }\n                        else {\n                            val = 0;\n                        }\n                        put_byte(s, val);\n                    } while (val !== 0);\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    if (val === 0) {\n                        s.status = HCRC_STATE;\n                    }\n                }\n                else {\n                    s.status = HCRC_STATE;\n                }\n            }\n            if (s.status === HCRC_STATE) {\n                if (s.gzhead.hcrc) {\n                    if (s.pending + 2 > s.pending_buf_size) {\n                        flush_pending(strm);\n                    }\n                    if (s.pending + 2 <= s.pending_buf_size) {\n                        put_byte(s, strm.adler & 0xff);\n                        put_byte(s, (strm.adler >> 8) & 0xff);\n                        strm.adler = 0; // crc32(0L, Z_NULL, 0);\n                        s.status = BUSY_STATE;\n                    }\n                }\n                else {\n                    s.status = BUSY_STATE;\n                }\n            } // #endif\n            /* Flush as much pending output as possible */\n            if (s.pending !== 0) {\n                flush_pending(strm);\n                if (strm.avail_out === 0) {\n                    /* Since avail_out is 0, deflate will be called again with\n                     * more output space, but possibly with both pending and\n                     * avail_in equal to zero. There won't be anything to do,\n                     * but this is not an error situation so make sure we\n                     * return OK instead of BUF_ERROR at next call of deflate:\n                     */\n                    s.last_flush = -1;\n                    return Z_OK;\n                }\n                /* Make sure there is something to do and avoid duplicate consecutive\n                 * flushes. For repeated and useless calls with Z_FINISH, we keep\n                 * returning Z_STREAM_END instead of Z_BUF_ERROR.\n                 */\n            }\n            else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n                return err(strm, Z_BUF_ERROR);\n            }\n            /* User must not provide more input after the first FINISH: */\n            if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n                return err(strm, Z_BUF_ERROR);\n            }\n            /* Start a new block or continue the current one.\n             */\n            if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n                var bstate = s.strategy === Z_HUFFMAN_ONLY\n                    ? deflate_huff(s, flush)\n                    : s.strategy === Z_RLE\n                        ? deflate_rle(s, flush)\n                        : configuration_table[s.level].func(s, flush);\n                if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n                    s.status = FINISH_STATE;\n                }\n                if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n                    if (strm.avail_out === 0) {\n                        s.last_flush = -1;\n                        /* avoid BUF_ERROR next call, see above */\n                    }\n                    return Z_OK;\n                    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n                     * of deflate should use the same flush parameter to make sure\n                     * that the flush is complete. So we don't have to output an\n                     * empty block here, this will be done at next call. This also\n                     * ensures that for a very small output buffer, we emit at most\n                     * one empty block.\n                     */\n                }\n                if (bstate === BS_BLOCK_DONE) {\n                    if (flush === Z_PARTIAL_FLUSH) {\n                        _tr_align$1(s);\n                    }\n                    else if (flush !== Z_BLOCK) {\n                        /* FULL_FLUSH or SYNC_FLUSH */\n                        _tr_stored_block$1(s, 0, 0, false);\n                        /* For a full flush, this empty block will be recognized\n                         * as a special marker by inflate_sync().\n                         */\n                        if (flush === Z_FULL_FLUSH) {\n                            /** * CLEAR_HASH(s); ** */\n                            /* forget history */\n                            zero$1(s.head); // Fill with NIL (= 0);\n                            if (s.lookahead === 0) {\n                                s.strstart = 0;\n                                s.block_start = 0;\n                                s.insert = 0;\n                            }\n                        }\n                    }\n                    flush_pending(strm);\n                    if (strm.avail_out === 0) {\n                        s.last_flush = -1;\n                        /* avoid BUF_ERROR at next call, see above */\n                        return Z_OK;\n                    }\n                }\n            } // Assert(strm->avail_out > 0, \"bug2\");\n            // if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n            if (flush !== Z_FINISH) {\n                return Z_OK;\n            }\n            if (s.wrap <= 0) {\n                return Z_STREAM_END;\n            }\n            /* Write the trailer */\n            if (s.wrap === 2) {\n                put_byte(s, strm.adler & 0xff);\n                put_byte(s, (strm.adler >> 8) & 0xff);\n                put_byte(s, (strm.adler >> 16) & 0xff);\n                put_byte(s, (strm.adler >> 24) & 0xff);\n                put_byte(s, strm.total_in & 0xff);\n                put_byte(s, (strm.total_in >> 8) & 0xff);\n                put_byte(s, (strm.total_in >> 16) & 0xff);\n                put_byte(s, (strm.total_in >> 24) & 0xff);\n            }\n            else {\n                putShortMSB(s, strm.adler >>> 16);\n                putShortMSB(s, strm.adler & 0xffff);\n            }\n            flush_pending(strm);\n            /* If avail_out is zero, the application will call deflate again\n             * to flush the rest.\n             */\n            if (s.wrap > 0) {\n                s.wrap = -s.wrap;\n            }\n            /* write the trailer only once! */\n            return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n        };\n        var deflateEnd = function deflateEnd(strm) {\n            if (!strm ||\n                /* == Z_NULL */\n                !strm.state\n            /* == Z_NULL */\n            ) {\n                return Z_STREAM_ERROR;\n            }\n            var status = strm.state.status;\n            if (status !== INIT_STATE &&\n                status !== EXTRA_STATE &&\n                status !== NAME_STATE &&\n                status !== COMMENT_STATE &&\n                status !== HCRC_STATE &&\n                status !== BUSY_STATE &&\n                status !== FINISH_STATE) {\n                return err(strm, Z_STREAM_ERROR);\n            }\n            strm.state = null;\n            return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n        };\n        /* =========================================================================\n         * Initializes the compression dictionary from the given byte\n         * sequence without producing any compressed output.\n         */\n        var deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {\n            var dictLength = dictionary.length;\n            if (!strm ||\n                /* == Z_NULL */\n                !strm.state\n            /* == Z_NULL */\n            ) {\n                return Z_STREAM_ERROR;\n            }\n            var s = strm.state;\n            var wrap = s.wrap;\n            if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n                return Z_STREAM_ERROR;\n            }\n            /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n            if (wrap === 1) {\n                /* adler32(strm->adler, dictionary, dictLength); */\n                strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n            }\n            s.wrap = 0;\n            /* avoid computing Adler-32 in read_buf */\n            /* if dictionary would fill window, just replace the history */\n            if (dictLength >= s.w_size) {\n                if (wrap === 0) {\n                    /* already empty otherwise */\n                    /** * CLEAR_HASH(s); ** */\n                    zero$1(s.head); // Fill with NIL (= 0);\n                    s.strstart = 0;\n                    s.block_start = 0;\n                    s.insert = 0;\n                }\n                /* use the tail */\n                // dictionary = dictionary.slice(dictLength - s.w_size);\n                var tmpDict = new Uint8Array(s.w_size);\n                tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n                dictionary = tmpDict;\n                dictLength = s.w_size;\n            }\n            /* insert dictionary into window and hash */\n            var avail = strm.avail_in;\n            var next = strm.next_in;\n            var input = strm.input;\n            strm.avail_in = dictLength;\n            strm.next_in = 0;\n            strm.input = dictionary;\n            fill_window(s);\n            while (s.lookahead >= MIN_MATCH$1) {\n                var str = s.strstart;\n                var n = s.lookahead - (MIN_MATCH$1 - 1);\n                do {\n                    /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n                    s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);\n                    s.prev[str & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = str;\n                    str++;\n                } while (--n);\n                s.strstart = str;\n                s.lookahead = MIN_MATCH$1 - 1;\n                fill_window(s);\n            }\n            s.strstart += s.lookahead;\n            s.block_start = s.strstart;\n            s.insert = s.lookahead;\n            s.lookahead = 0;\n            s.match_length = s.prev_length = MIN_MATCH$1 - 1;\n            s.match_available = 0;\n            strm.next_in = next;\n            strm.input = input;\n            strm.avail_in = avail;\n            s.wrap = wrap;\n            return Z_OK;\n        };\n        var deflateInit_1 = deflateInit;\n        var deflateInit2_1 = deflateInit2;\n        var deflateReset_1 = deflateReset;\n        var deflateResetKeep_1 = deflateResetKeep;\n        var deflateSetHeader_1 = deflateSetHeader;\n        var deflate_2 = deflate;\n        var deflateEnd_1 = deflateEnd;\n        var deflateSetDictionary_1 = deflateSetDictionary;\n        var deflateInfo = 'pako deflate (from Nodeca project)';\n        /* Not implemented\n      module.exports.deflateBound = deflateBound;\n      module.exports.deflateCopy = deflateCopy;\n      module.exports.deflateParams = deflateParams;\n      module.exports.deflatePending = deflatePending;\n      module.exports.deflatePrime = deflatePrime;\n      module.exports.deflateTune = deflateTune;\n      */\n        var deflate_1 = {\n            deflateInit: deflateInit_1,\n            deflateInit2: deflateInit2_1,\n            deflateReset: deflateReset_1,\n            deflateResetKeep: deflateResetKeep_1,\n            deflateSetHeader: deflateSetHeader_1,\n            deflate: deflate_2,\n            deflateEnd: deflateEnd_1,\n            deflateSetDictionary: deflateSetDictionary_1,\n            deflateInfo: deflateInfo,\n        };\n        function _typeof(obj) {\n            '@babel/helpers - typeof';\n            if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n                _typeof = function (obj) {\n                    return typeof obj;\n                };\n            }\n            else {\n                _typeof = function (obj) {\n                    return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype\n                        ? 'symbol'\n                        : typeof obj;\n                };\n            }\n            return _typeof(obj);\n        }\n        var _has = function _has(obj, key) {\n            return Object.prototype.hasOwnProperty.call(obj, key);\n        };\n        var assign = function assign(obj\n        /* from1, from2, from3, ... */\n        ) {\n            var sources = Array.prototype.slice.call(arguments, 1);\n            while (sources.length) {\n                var source = sources.shift();\n                if (!source) {\n                    continue;\n                }\n                if (_typeof(source) !== 'object') {\n                    throw new TypeError(source + \"must be non-object\");\n                }\n                for (var p in source) {\n                    if (_has(source, p)) {\n                        obj[p] = source[p];\n                    }\n                }\n            }\n            return obj;\n        }; // Join array of chunks to single array.\n        var flattenChunks = function flattenChunks(chunks) {\n            // calculate data length\n            var len = 0;\n            for (var i = 0, l = chunks.length; i < l; i++) {\n                len += chunks[i].length;\n            } // join chunks\n            var result = new Uint8Array(len);\n            for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {\n                var chunk = chunks[_i];\n                result.set(chunk, pos);\n                pos += chunk.length;\n            }\n            return result;\n        };\n        var common = {\n            assign: assign,\n            flattenChunks: flattenChunks,\n        };\n        // String encode/decode helpers\n        //\n        // - apply(Array) can fail on Android 2.2\n        // - apply(Uint8Array) can fail on iOS 5.1 Safari\n        //\n        var STR_APPLY_UIA_OK = true;\n        try {\n            String.fromCharCode.apply(null, new Uint8Array(1));\n        }\n        catch (__) {\n            STR_APPLY_UIA_OK = false;\n        } // Table with utf8 lengths (calculated by first byte of sequence)\n        // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n        // because max possible codepoint is 0x10ffff\n        var _utf8len = new Uint8Array(256);\n        for (var q = 0; q < 256; q++) {\n            _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n        }\n        _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n        // convert string to array (typed, when possible)\n        // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n        //\n        // This software is provided 'as-is', without any express or implied\n        // warranty. In no event will the authors be held liable for any damages\n        // arising from the use of this software.\n        //\n        // Permission is granted to anyone to use this software for any purpose,\n        // including commercial applications, and to alter it and redistribute it\n        // freely, subject to the following restrictions:\n        //\n        // 1. The origin of this software must not be misrepresented; you must not\n        //   claim that you wrote the original software. If you use this software\n        //   in a product, an acknowledgment in the product documentation would be\n        //   appreciated but is not required.\n        // 2. Altered source versions must be plainly marked as such, and must not be\n        //   misrepresented as being the original software.\n        // 3. This notice may not be removed or altered from any source distribution.\n        function ZStream() {\n            /* next input byte */\n            this.input = null; // JS specific, because we have no pointers\n            this.next_in = 0;\n            /* number of bytes available at input */\n            this.avail_in = 0;\n            /* total number of input bytes read so far */\n            this.total_in = 0;\n            /* next output byte should be put there */\n            this.output = null; // JS specific, because we have no pointers\n            this.next_out = 0;\n            /* remaining free space at output */\n            this.avail_out = 0;\n            /* total number of bytes output so far */\n            this.total_out = 0;\n            /* last error message, NULL if no error */\n            this.msg = '';\n            /* Z_NULL */\n            /* not visible by applications */\n            this.state = null;\n            /* best guess about the data type: binary or text */\n            this.data_type = 2;\n            /* Z_UNKNOWN */\n            /* adler32 value of the uncompressed data */\n            this.adler = 0;\n        }\n        var zstream = ZStream;\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        var toString = Object.prototype.toString;\n        /* Public constants ========================================================== */\n        /* =========================================================================== */\n        var Z_NO_FLUSH$1 = constants.Z_NO_FLUSH;\n        var Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH;\n        var Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH;\n        var Z_FINISH$1 = constants.Z_FINISH;\n        var Z_OK$1 = constants.Z_OK;\n        var Z_STREAM_END$1 = constants.Z_STREAM_END;\n        var Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION;\n        var Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY;\n        var Z_DEFLATED$1 = constants.Z_DEFLATED;\n        /* =========================================================================== */\n        /**\n         * class Deflate\n         *\n         * Generic JS-style wrapper for zlib calls. If you don't need\n         * streaming behaviour - use more simple functions: [[deflate]],\n         * [[deflateRaw]] and [[gzip]].\n         * */\n        /* internal\n         * Deflate.chunks -> Array\n         *\n         * Chunks of output data, if [[Deflate#onData]] not overridden.\n         * */\n        /**\n         * Deflate.result -> Uint8Array\n         *\n         * Compressed result, generated by default [[Deflate#onData]]\n         * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n         * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n         * */\n        /**\n         * Deflate.err -> Number\n         *\n         * Error code after deflate finished. 0 (Z_OK) on success.\n         * You will not need it in real life, because deflate errors\n         * are possible only on wrong options or bad `onData` / `onEnd`\n         * custom handlers.\n         * */\n        /**\n         * Deflate.msg -> String\n         *\n         * Error message, if [[Deflate.err]] != 0\n         * */\n        /**\n         * new Deflate(options)\n         * - options (Object): zlib deflate options.\n         *\n         * Creates new deflator instance with specified params. Throws exception\n         * on bad params. Supported options:\n         *\n         * - `level`\n         * - `windowBits`\n         * - `memLevel`\n         * - `strategy`\n         * - `dictionary`\n         *\n         * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n         * for more information on these.\n         *\n         * Additional options, for internal needs:\n         *\n         * - `chunkSize` - size of generated data chunks (16K by default)\n         * - `raw` (Boolean) - do raw deflate\n         * - `gzip` (Boolean) - create gzip wrapper\n         * - `header` (Object) - custom header for gzip\n         *   - `text` (Boolean) - true if compressed data believed to be text\n         *   - `time` (Number) - modification time, unix timestamp\n         *   - `os` (Number) - operation system code\n         *   - `extra` (Array) - array of bytes with extra data (max 65536)\n         *   - `name` (String) - file name (binary string)\n         *   - `comment` (String) - comment (binary string)\n         *   - `hcrc` (Boolean) - true if header crc should be added\n         *\n         * ##### Example:\n         *\n         * ```javascript\n         * const pako = require('pako')\n         *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n         *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n         *\n         * const deflate = new pako.Deflate({ level: 3});\n         *\n         * deflate.push(chunk1, false);\n         * deflate.push(chunk2, true);  // true -> last chunk\n         *\n         * if (deflate.err) { throw new Error(deflate.err); }\n         *\n         * console.log(deflate.result);\n         * ```\n         * */\n        function Deflate(options) {\n            this.options = common.assign({\n                level: Z_DEFAULT_COMPRESSION$1,\n                method: Z_DEFLATED$1,\n                chunkSize: 16384,\n                windowBits: 15,\n                memLevel: 8,\n                strategy: Z_DEFAULT_STRATEGY$1,\n            }, options || {});\n            var opt = this.options;\n            if (opt.raw && opt.windowBits > 0) {\n                opt.windowBits = -opt.windowBits;\n            }\n            else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n                opt.windowBits += 16;\n            }\n            this.err = 0; // error code, if happens (0 = Z_OK)\n            this.msg = ''; // error message\n            this.ended = false; // used to avoid multiple onEnd() calls\n            this.chunks = []; // chunks of compressed data\n            this.strm = new zstream();\n            this.strm.avail_out = 0;\n            var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n            if (status !== Z_OK$1) {\n                throw new Error(messages[status]);\n            }\n            if (opt.header) {\n                deflate_1.deflateSetHeader(this.strm, opt.header);\n            }\n            if (opt.dictionary) {\n                var dict; // Convert data if needed\n                if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n                    dict = new Uint8Array(opt.dictionary);\n                }\n                else {\n                    dict = opt.dictionary;\n                }\n                status = deflate_1.deflateSetDictionary(this.strm, dict);\n                if (status !== Z_OK$1) {\n                    throw new Error(messages[status]);\n                }\n                this._dict_set = true;\n            }\n        }\n        /**\n         * Deflate#push(data[, flush_mode]) -> Boolean\n         * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n         *   converted to utf8 byte sequence.\n         * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n         *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n         *\n         * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n         * new compressed chunks. Returns `true` on success. The last data block must\n         * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n         * buffers and call [[Deflate#onEnd]].\n         *\n         * On fail call [[Deflate#onEnd]] with error code and return false.\n         *\n         * ##### Example\n         *\n         * ```javascript\n         * push(chunk, false); // push one of data chunks\n         * ...\n         * push(chunk, true);  // push last chunk\n         * ```\n         * */\n        Deflate.prototype.push = function (data, flush_mode) {\n            var strm = this.strm;\n            var chunkSize = this.options.chunkSize;\n            var status;\n            var _flush_mode;\n            if (this.ended) {\n                return false;\n            }\n            if (flush_mode === ~~flush_mode) {\n                _flush_mode = flush_mode;\n            }\n            else {\n                _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;\n            } // Convert data if needed\n            if (toString.call(data) === '[object ArrayBuffer]') {\n                strm.input = new Uint8Array(data);\n            }\n            else {\n                strm.input = data;\n            }\n            strm.next_in = 0;\n            strm.avail_in = strm.input.length;\n            for (;;) {\n                if (strm.avail_out === 0) {\n                    strm.output = new Uint8Array(chunkSize);\n                    strm.next_out = 0;\n                    strm.avail_out = chunkSize;\n                } // Make sure avail_out > 6 to avoid repeating markers\n                if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {\n                    this.onData(strm.output.subarray(0, strm.next_out));\n                    strm.avail_out = 0;\n                    continue;\n                }\n                status = deflate_1.deflate(strm, _flush_mode); // Ended => flush and finish\n                if (status === Z_STREAM_END$1) {\n                    if (strm.next_out > 0) {\n                        this.onData(strm.output.subarray(0, strm.next_out));\n                    }\n                    status = deflate_1.deflateEnd(this.strm);\n                    this.onEnd(status);\n                    this.ended = true;\n                    return status === Z_OK$1;\n                } // Flush if out buffer full\n                if (strm.avail_out === 0) {\n                    this.onData(strm.output);\n                    continue;\n                } // Flush if requested and has data\n                if (_flush_mode > 0 && strm.next_out > 0) {\n                    this.onData(strm.output.subarray(0, strm.next_out));\n                    strm.avail_out = 0;\n                    continue;\n                }\n                if (strm.avail_in === 0) {\n                    break;\n                }\n            }\n            return true;\n        };\n        /**\n         * Deflate#onData(chunk) -> Void\n         * - chunk (Uint8Array): output data.\n         *\n         * By default, stores data blocks in `chunks[]` property and glue\n         * those in `onEnd`. Override this handler, if you need another behaviour.\n         * */\n        Deflate.prototype.onData = function (chunk) {\n            this.chunks.push(chunk);\n        };\n        /**\n         * Deflate#onEnd(status) -> Void\n         * - status (Number): deflate status. 0 (Z_OK) on success,\n         *   other if not.\n         *\n         * Called once after you tell deflate that the input stream is\n         * complete (Z_FINISH). By default - join collected chunks,\n         * free memory and fill `results` / `err` properties.\n         * */\n        Deflate.prototype.onEnd = function (status) {\n            // On success - join\n            if (status === Z_OK$1) {\n                this.result = common.flattenChunks(this.chunks);\n            }\n            this.chunks = [];\n            this.err = status;\n            this.msg = this.strm.msg;\n        };\n        /**\n         * deflate(data[, options]) -> Uint8Array\n         * - data (Uint8Array|String): input data to compress.\n         * - options (Object): zlib deflate options.\n         *\n         * Compress `data` with deflate algorithm and `options`.\n         *\n         * Supported options are:\n         *\n         * - level\n         * - windowBits\n         * - memLevel\n         * - strategy\n         * - dictionary\n         *\n         * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n         * for more information on these.\n         *\n         * Sugar (options):\n         *\n         * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n         *   negative windowBits implicitly.\n         *\n         * ##### Example:\n         *\n         * ```javascript\n         * const pako = require('pako')\n         * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n         *\n         * console.log(pako.deflate(data));\n         * ```\n         * */\n        function deflate$1(input, options) {\n            var deflator = new Deflate(options);\n            deflator.push(input, true); // That will never happens, if you don't cheat with options :)\n            if (deflator.err) {\n                throw deflator.msg || messages[deflator.err];\n            }\n            return deflator.result;\n        }\n        /**\n         * deflateRaw(data[, options]) -> Uint8Array\n         * - data (Uint8Array|String): input data to compress.\n         * - options (Object): zlib deflate options.\n         *\n         * The same as [[deflate]], but creates raw data, without wrapper\n         * (header and adler32 crc).\n         * */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        function deflateRaw(input, options) {\n            options = options || {};\n            options.raw = true;\n            return deflate$1(input, options);\n        }\n        /**\n         * gzip(data[, options]) -> Uint8Array\n         * - data (Uint8Array|String): input data to compress.\n         * - options (Object): zlib deflate options.\n         *\n         * The same as [[deflate]], but create gzip wrapper instead of\n         * deflate one.\n         * */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        function gzip(input, options) {\n            options = options || {};\n            options.gzip = true;\n            return deflate$1(input, options);\n        }\n        return { Deflate: Deflate, constants: constants };\n    }\n}\n//# sourceMappingURL=deflateWorker.js.map"]},"metadata":{},"sourceType":"module"}