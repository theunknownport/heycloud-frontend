{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { getter } from '@progress/kendo-react-common';\n/** @hidden */\n\nexport var getValueMap = function (value, idGetter) {\n  var map = {};\n\n  if (value && value.length) {\n    value.forEach(function (item) {\n      map[idGetter(item)] = true;\n    });\n  }\n\n  return map;\n};\n/**\n * Get MultiSelectTree new value from the component `onChange` event.\n *\n * @param {any[]} data\n * @param {object} options\n * @returns {any[]}\n */\n\nexport var getMultiSelectTreeValue = function (data, options) {\n  var items = options.items,\n      dataItemKey = options.dataItemKey,\n      value = options.value,\n      _a = options.subItemsField,\n      subItemsField = _a === void 0 ? 'items' : _a,\n      operation = options.operation;\n  var idGetter = getter(dataItemKey);\n  var valueMap = getValueMap(value, idGetter);\n\n  if (operation === 'clear') {\n    return [];\n  } else if (operation === 'delete') {\n    var deletedItemsMap_1 = getValueMap(items, idGetter);\n    return value.filter(function (item) {\n      return !deletedItemsMap_1[idGetter(item)];\n    });\n  } // operation === 'toggle'\n\n\n  var selectedItem = items[0];\n  var selectedId = idGetter(selectedItem);\n  var subItemGetter = getter(subItemsField);\n\n  var stack = __spreadArray([], data, true);\n\n  var context = [];\n  var parents = [];\n  var foundItem;\n\n  while (stack.length) {\n    var currentItem = stack.pop();\n\n    if (selectedId === idGetter(currentItem)) {\n      parents = context.map(function (contextItem) {\n        return contextItem.item;\n      });\n      foundItem = currentItem;\n      break;\n    } else {\n      if (context && context.length && context[context.length - 1].parentPosition === stack.length) {\n        context.pop();\n      }\n\n      var subItems = subItemGetter(currentItem);\n\n      if (subItems && subItems.length) {\n        context.push({\n          item: currentItem,\n          parentPosition: stack.length\n        });\n        stack.push.apply(stack, subItems);\n      }\n    }\n  }\n\n  var childrenStack = __spreadArray([], subItemGetter(foundItem) || [], true);\n\n  var children = [];\n\n  while (childrenStack.length) {\n    var currentItem = childrenStack.pop();\n    children.push(currentItem);\n    var subItems = subItemGetter(currentItem);\n\n    if (subItems && subItems.length) {\n      childrenStack.push.apply(childrenStack, subItems);\n    }\n  }\n\n  var isChecked = !valueMap[selectedId];\n  var newValue = [];\n\n  if (isChecked) {\n    newValue.push.apply(newValue, value);\n    newValue.push(foundItem);\n    newValue.push.apply(newValue, children.filter(function (item) {\n      return !valueMap[idGetter(item)];\n    }));\n    var parentCandidates = parents.filter(function (item) {\n      return !valueMap[idGetter(item)];\n    });\n    var newValueMap_1 = getValueMap(newValue, idGetter);\n\n    for (var i = parentCandidates.length - 1; i > -1; i--) {\n      var candidate = parentCandidates[i];\n      var subItems = subItemGetter(candidate);\n      var checkedChildrenLength = subItems.filter(function (item) {\n        return newValueMap_1[idGetter(item)];\n      }).length;\n\n      if (checkedChildrenLength < subItems.length) {\n        break;\n      } else {\n        newValue.push(candidate);\n        newValueMap_1[idGetter(candidate)] = true;\n      }\n    }\n  } else {\n    var foundId_1 = idGetter(foundItem);\n    var childrenMap_1 = getValueMap(children, idGetter);\n    var parentsMap_1 = getValueMap(parents, idGetter);\n    newValue.push.apply(newValue, value.filter(function (item) {\n      var itemId = idGetter(item);\n      return !childrenMap_1[itemId] && foundId_1 !== itemId && !parentsMap_1[itemId];\n    }));\n  }\n\n  return newValue;\n}; // /** @hidden */\n// const mapCheckAndIntermidiate = (\n//     data,\n//     options: {\n//         valueMap: {[dataItemKey: string]: boolean};\n//         callback?: (item: any) => any;\n//         idGetter: (item: any) => any;\n//         subItemGetter: (item: any) => any;\n//         subItemSetter: (item: any, value: any) => void;\n//         checkSetter: (item: any, value: any) => void;\n//         checkIndeterminateSetter: (item: any, value: any) => void;\n//     }\n// ) => {\n//     const {\n//         idGetter,\n//         subItemGetter,\n//         subItemSetter,\n//         checkSetter,\n//         checkIndeterminateSetter\n//     } = options;\n//     if (!data || !data.length) { return [data, false];}\n//     let hasChecked = false;\n//     const newData = [...data].map(dataItem => {\n//         const [children, hasCheckedChildren] = mapCheckAndIntermidiate(subItemGetter(dataItem), options);\n//         const isChecked = options.valueMap[idGetter(dataItem)];\n//         if (isChecked || hasCheckedChildren) {\n//             hasChecked = true;\n//         }\n//         const newItem = { ...dataItem };\n//         subItemSetter(newItem, children);\n//         checkSetter(newItem, isChecked);\n//         checkIndeterminateSetter(newItem, !isChecked && hasCheckedChildren);\n//         return options.callback ? options.callback(newItem) : newItem;\n//     });\n//     return [newData, hasChecked];\n// };\n// /**\n//  *\n//  * @param data\n//  * @param options\n//  * @returns\n//  */\n// /**\n//  * Creates a new array with the results of calling the provided callback function\n//  * on every element in the provided data tree. The new tree items have their `check` and `checkIndeterminate` fields set based on provided value.\n//  *\n//  * @param {any[]} tree - The data tree.\n//  * @param {object} options - The options used to map the tree items like check and checkIndeterminateField fields\n//  * @returns {any[]} - The new data tree.\n//  */\n// export const mapMultiSelectTreeData = (\n//     tree,\n//     options: {\n//         checkField?: string;\n//         checkIndeterminateField?: string;\n//         subItemsField?: string;\n//         dataItemKey: string;\n//         value: Array<any>;\n//         callback?: (item) => any;\n//     }\n// ) => {\n//     const {\n//         subItemsField = 'items',\n//         checkField = 'checkField',\n//         checkIndeterminateField = 'checkIndeterminateField',\n//         callback\n//     } = options;\n//     const idGetter = getter(options.dataItemKey);\n//     const [result] = mapCheckAndIntermidiate(\n//         tree,\n//         {\n//             callback,\n//             valueMap: getValueMap(options.value, idGetter),\n//             idGetter,\n//             subItemGetter: getter(subItemsField),\n//             subItemSetter: setter(subItemsField),\n//             checkSetter: setter(checkField),\n//             checkIndeterminateSetter: setter(checkIndeterminateField)\n//         }\n//     );\n//     return result;\n// };","map":{"version":3,"sources":["C:/Projects/React/heycloud-frontent-2/node_modules/@progress/kendo-react-dropdowns/dist/es/MultiSelectTree/utils.js"],"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","getter","getValueMap","value","idGetter","map","forEach","item","getMultiSelectTreeValue","data","options","items","dataItemKey","_a","subItemsField","operation","valueMap","deletedItemsMap_1","filter","selectedItem","selectedId","subItemGetter","stack","context","parents","foundItem","currentItem","pop","contextItem","parentPosition","subItems","push","apply","childrenStack","children","isChecked","newValue","parentCandidates","newValueMap_1","candidate","checkedChildrenLength","foundId_1","childrenMap_1","parentsMap_1","itemId"],"mappings":"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","sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { getter } from '@progress/kendo-react-common';\n/** @hidden */\nexport var getValueMap = function (value, idGetter) {\n    var map = {};\n    if (value && value.length) {\n        value.forEach(function (item) {\n            map[idGetter(item)] = true;\n        });\n    }\n    return map;\n};\n/**\n * Get MultiSelectTree new value from the component `onChange` event.\n *\n * @param {any[]} data\n * @param {object} options\n * @returns {any[]}\n */\nexport var getMultiSelectTreeValue = function (data, options) {\n    var items = options.items, dataItemKey = options.dataItemKey, value = options.value, _a = options.subItemsField, subItemsField = _a === void 0 ? 'items' : _a, operation = options.operation;\n    var idGetter = getter(dataItemKey);\n    var valueMap = getValueMap(value, idGetter);\n    if (operation === 'clear') {\n        return [];\n    }\n    else if (operation === 'delete') {\n        var deletedItemsMap_1 = getValueMap(items, idGetter);\n        return value.filter(function (item) { return !deletedItemsMap_1[idGetter(item)]; });\n    }\n    // operation === 'toggle'\n    var selectedItem = items[0];\n    var selectedId = idGetter(selectedItem);\n    var subItemGetter = getter(subItemsField);\n    var stack = __spreadArray([], data, true);\n    var context = [];\n    var parents = [];\n    var foundItem;\n    while (stack.length) {\n        var currentItem = stack.pop();\n        if (selectedId === idGetter(currentItem)) {\n            parents = context.map(function (contextItem) { return contextItem.item; });\n            foundItem = currentItem;\n            break;\n        }\n        else {\n            if (context &&\n                context.length &&\n                context[context.length - 1].parentPosition === stack.length) {\n                context.pop();\n            }\n            var subItems = subItemGetter(currentItem);\n            if (subItems && subItems.length) {\n                context.push({ item: currentItem, parentPosition: stack.length });\n                stack.push.apply(stack, subItems);\n            }\n        }\n    }\n    var childrenStack = __spreadArray([], (subItemGetter(foundItem) || []), true);\n    var children = [];\n    while (childrenStack.length) {\n        var currentItem = childrenStack.pop();\n        children.push(currentItem);\n        var subItems = subItemGetter(currentItem);\n        if (subItems && subItems.length) {\n            childrenStack.push.apply(childrenStack, subItems);\n        }\n    }\n    var isChecked = !valueMap[selectedId];\n    var newValue = [];\n    if (isChecked) {\n        newValue.push.apply(newValue, value);\n        newValue.push(foundItem);\n        newValue.push.apply(newValue, children.filter(function (item) { return !valueMap[idGetter(item)]; }));\n        var parentCandidates = parents.filter(function (item) { return !valueMap[idGetter(item)]; });\n        var newValueMap_1 = getValueMap(newValue, idGetter);\n        for (var i = parentCandidates.length - 1; i > -1; i--) {\n            var candidate = parentCandidates[i];\n            var subItems = subItemGetter(candidate);\n            var checkedChildrenLength = subItems.filter(function (item) { return newValueMap_1[idGetter(item)]; }).length;\n            if (checkedChildrenLength < subItems.length) {\n                break;\n            }\n            else {\n                newValue.push(candidate);\n                newValueMap_1[idGetter(candidate)] = true;\n            }\n        }\n    }\n    else {\n        var foundId_1 = idGetter(foundItem);\n        var childrenMap_1 = getValueMap(children, idGetter);\n        var parentsMap_1 = getValueMap(parents, idGetter);\n        newValue.push.apply(newValue, (value\n            .filter(function (item) {\n            var itemId = idGetter(item);\n            return !childrenMap_1[itemId] && foundId_1 !== itemId && !parentsMap_1[itemId];\n        })));\n    }\n    return newValue;\n};\n// /** @hidden */\n// const mapCheckAndIntermidiate = (\n//     data,\n//     options: {\n//         valueMap: {[dataItemKey: string]: boolean};\n//         callback?: (item: any) => any;\n//         idGetter: (item: any) => any;\n//         subItemGetter: (item: any) => any;\n//         subItemSetter: (item: any, value: any) => void;\n//         checkSetter: (item: any, value: any) => void;\n//         checkIndeterminateSetter: (item: any, value: any) => void;\n//     }\n// ) => {\n//     const {\n//         idGetter,\n//         subItemGetter,\n//         subItemSetter,\n//         checkSetter,\n//         checkIndeterminateSetter\n//     } = options;\n//     if (!data || !data.length) { return [data, false];}\n//     let hasChecked = false;\n//     const newData = [...data].map(dataItem => {\n//         const [children, hasCheckedChildren] = mapCheckAndIntermidiate(subItemGetter(dataItem), options);\n//         const isChecked = options.valueMap[idGetter(dataItem)];\n//         if (isChecked || hasCheckedChildren) {\n//             hasChecked = true;\n//         }\n//         const newItem = { ...dataItem };\n//         subItemSetter(newItem, children);\n//         checkSetter(newItem, isChecked);\n//         checkIndeterminateSetter(newItem, !isChecked && hasCheckedChildren);\n//         return options.callback ? options.callback(newItem) : newItem;\n//     });\n//     return [newData, hasChecked];\n// };\n// /**\n//  *\n//  * @param data\n//  * @param options\n//  * @returns\n//  */\n// /**\n//  * Creates a new array with the results of calling the provided callback function\n//  * on every element in the provided data tree. The new tree items have their `check` and `checkIndeterminate` fields set based on provided value.\n//  *\n//  * @param {any[]} tree - The data tree.\n//  * @param {object} options - The options used to map the tree items like check and checkIndeterminateField fields\n//  * @returns {any[]} - The new data tree.\n//  */\n// export const mapMultiSelectTreeData = (\n//     tree,\n//     options: {\n//         checkField?: string;\n//         checkIndeterminateField?: string;\n//         subItemsField?: string;\n//         dataItemKey: string;\n//         value: Array<any>;\n//         callback?: (item) => any;\n//     }\n// ) => {\n//     const {\n//         subItemsField = 'items',\n//         checkField = 'checkField',\n//         checkIndeterminateField = 'checkIndeterminateField',\n//         callback\n//     } = options;\n//     const idGetter = getter(options.dataItemKey);\n//     const [result] = mapCheckAndIntermidiate(\n//         tree,\n//         {\n//             callback,\n//             valueMap: getValueMap(options.value, idGetter),\n//             idGetter,\n//             subItemGetter: getter(subItemsField),\n//             subItemSetter: setter(subItemsField),\n//             checkSetter: setter(checkField),\n//             checkIndeterminateSetter: setter(checkIndeterminateField)\n//         }\n//     );\n//     return result;\n// };\n"]},"metadata":{},"sourceType":"module"}