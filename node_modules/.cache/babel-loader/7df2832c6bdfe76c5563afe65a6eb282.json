{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { monitor, callMonitored } from '../domain/internalMonitoring';\nimport { computeStackTrace } from '../domain/tracekit';\nimport { toStackTraceString } from '../tools/error';\nimport { instrumentMethod } from '../tools/instrumentMethod';\nimport { Observable } from '../tools/observable';\nimport { elapsed, clocksNow, timeStampNow } from '../tools/timeUtils';\nimport { normalizeUrl } from '../tools/urlPolyfill';\nvar fetchObservable;\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable();\n  }\n\n  return fetchObservable;\n}\n\nfunction createFetchObservable() {\n  var observable = new Observable(function () {\n    if (!window.fetch) {\n      return;\n    }\n\n    var stop = instrumentMethod(window, 'fetch', function (originalFetch) {\n      return function (input, init) {\n        var responsePromise;\n        var context = callMonitored(beforeSend, null, [observable, input, init]);\n\n        if (context) {\n          responsePromise = originalFetch.call(this, context.input, context.init);\n          callMonitored(afterSend, null, [observable, responsePromise, context]);\n        } else {\n          responsePromise = originalFetch.call(this, input, init);\n        }\n\n        return responsePromise;\n      };\n    }).stop;\n    return stop;\n  });\n  return observable;\n}\n\nfunction beforeSend(observable, input, init) {\n  var method = init && init.method || typeof input === 'object' && input.method || 'GET';\n  var url = normalizeUrl(typeof input === 'object' && input.url || input);\n  var startClocks = clocksNow();\n  var context = {\n    state: 'start',\n    init: init,\n    input: input,\n    method: method,\n    startClocks: startClocks,\n    url: url\n  };\n  observable.notify(context);\n  return context;\n}\n\nfunction afterSend(observable, responsePromise, startContext) {\n  var _this = this;\n\n  var reportFetch = function (response) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var context, text, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            context = startContext;\n            context.state = 'complete';\n            context.duration = elapsed(context.startClocks.timeStamp, timeStampNow());\n            if (!('stack' in response || response instanceof Error)) return [3\n            /*break*/\n            , 1];\n            context.status = 0;\n            context.responseText = toStackTraceString(computeStackTrace(response));\n            context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR;\n            context.error = response;\n            observable.notify(context);\n            return [3\n            /*break*/\n            , 6];\n\n          case 1:\n            if (!('status' in response)) return [3\n            /*break*/\n            , 6];\n            text = void 0;\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , response.clone().text()];\n\n          case 3:\n            text = _a.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_1 = _a.sent();\n            text = \"Unable to retrieve response: \" + e_1;\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            context.response = response;\n            context.responseText = text;\n            context.responseType = response.type;\n            context.status = response.status;\n            context.isAborted = false;\n            observable.notify(context);\n            _a.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch));\n}","map":{"version":3,"sources":["../../src/browser/fetchObservable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { monitor, callMonitored } from '../domain/internalMonitoring';\nimport { computeStackTrace } from '../domain/tracekit';\nimport { toStackTraceString } from '../tools/error';\nimport { instrumentMethod } from '../tools/instrumentMethod';\nimport { Observable } from '../tools/observable';\nimport { elapsed, clocksNow, timeStampNow } from '../tools/timeUtils';\nimport { normalizeUrl } from '../tools/urlPolyfill';\nvar fetchObservable;\nexport function initFetchObservable() {\n    if (!fetchObservable) {\n        fetchObservable = createFetchObservable();\n    }\n    return fetchObservable;\n}\nfunction createFetchObservable() {\n    var observable = new Observable(function () {\n        if (!window.fetch) {\n            return;\n        }\n        var stop = instrumentMethod(window, 'fetch', function (originalFetch) {\n            return function (input, init) {\n                var responsePromise;\n                var context = callMonitored(beforeSend, null, [observable, input, init]);\n                if (context) {\n                    responsePromise = originalFetch.call(this, context.input, context.init);\n                    callMonitored(afterSend, null, [observable, responsePromise, context]);\n                }\n                else {\n                    responsePromise = originalFetch.call(this, input, init);\n                }\n                return responsePromise;\n            };\n        }).stop;\n        return stop;\n    });\n    return observable;\n}\nfunction beforeSend(observable, input, init) {\n    var method = (init && init.method) || (typeof input === 'object' && input.method) || 'GET';\n    var url = normalizeUrl((typeof input === 'object' && input.url) || input);\n    var startClocks = clocksNow();\n    var context = {\n        state: 'start',\n        init: init,\n        input: input,\n        method: method,\n        startClocks: startClocks,\n        url: url,\n    };\n    observable.notify(context);\n    return context;\n}\nfunction afterSend(observable, responsePromise, startContext) {\n    var _this = this;\n    var reportFetch = function (response) { return __awaiter(_this, void 0, void 0, function () {\n        var context, text, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    context = startContext;\n                    context.state = 'complete';\n                    context.duration = elapsed(context.startClocks.timeStamp, timeStampNow());\n                    if (!('stack' in response || response instanceof Error)) return [3 /*break*/, 1];\n                    context.status = 0;\n                    context.responseText = toStackTraceString(computeStackTrace(response));\n                    context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR;\n                    context.error = response;\n                    observable.notify(context);\n                    return [3 /*break*/, 6];\n                case 1:\n                    if (!('status' in response)) return [3 /*break*/, 6];\n                    text = void 0;\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, , 5]);\n                    return [4 /*yield*/, response.clone().text()];\n                case 3:\n                    text = _a.sent();\n                    return [3 /*break*/, 5];\n                case 4:\n                    e_1 = _a.sent();\n                    text = \"Unable to retrieve response: \" + e_1;\n                    return [3 /*break*/, 5];\n                case 5:\n                    context.response = response;\n                    context.responseText = text;\n                    context.responseType = response.type;\n                    context.status = response.status;\n                    context.isAborted = false;\n                    observable.notify(context);\n                    _a.label = 6;\n                case 6: return [2 /*return*/];\n            }\n        });\n    }); };\n    responsePromise.then(monitor(reportFetch), monitor(reportFetch));\n}\n//# sourceMappingURL=fetchObservable.js.map"]},"metadata":{},"sourceType":"module"}