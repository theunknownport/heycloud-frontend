{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, CENSORED_STRING_MARK, CENSORED_IMG_MARK } from '../../constants';\nimport { getTextContent, shouldMaskNode, reducePrivacyLevel, getNodeSelfPrivacyLevel, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH } from './privacy';\nimport { NodeType } from './types';\nimport { makeStylesheetUrlsAbsolute, getSerializedNodeId, setSerializedNodeId, getElementInputValue, makeSrcsetUrlsAbsolute, makeUrlAbsolute } from './serializationUtils';\nimport { forEach } from './utils';\nexport function serializeDocument(document, defaultPrivacyLevel) {\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializeNodeWithId(document, {\n    document: document,\n    parentNodePrivacyLevel: defaultPrivacyLevel\n  });\n}\nexport function serializeNodeWithId(node, options) {\n  var serializedNode = serializeNode(node, options);\n\n  if (!serializedNode) {\n    return null;\n  } // Try to reuse the previous id\n\n\n  var id = getSerializedNodeId(node) || generateNextId();\n  var serializedNodeWithId = serializedNode;\n  serializedNodeWithId.id = id;\n  setSerializedNodeId(node, id);\n\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id);\n  }\n\n  return serializedNodeWithId;\n}\n\nfunction serializeNode(node, options) {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node, options);\n\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node);\n\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node, options);\n\n    case node.TEXT_NODE:\n      return serializeTextNode(node, options);\n\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode();\n  }\n}\n\nexport function serializeDocumentNode(document, options) {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options)\n  };\n}\n\nfunction serializeDocumentTypeNode(documentType) {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId\n  };\n}\n/**\n * Serialzing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, otpion selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\n\n\nexport function serializeElementNode(element, options) {\n  var _a;\n\n  var tagName = getValidTagName(element.tagName);\n  var isSVG = isSVGElement(element) || undefined; // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n\n  var nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    var _b = element.getBoundingClientRect(),\n        width = _b.width,\n        height = _b.height;\n\n    return {\n      type: NodeType.Element,\n      tagName: tagName,\n      attributes: (_a = {\n        rr_width: width + \"px\",\n        rr_height: height + \"px\"\n      }, _a[PRIVACY_ATTR_NAME] = PRIVACY_ATTR_VALUE_HIDDEN, _a),\n      childNodes: [],\n      isSVG: isSVG\n    };\n  } // Ignore Elements like Script and some Link, Metas\n\n\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return;\n  }\n\n  var attributes = getAttributesForPrivacyLevel(element, nodePrivacyLevel);\n  var childNodes = [];\n\n  if (element.childNodes.length) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    var childNodesSerializationOptions = void 0;\n\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options;\n    } else {\n      childNodesSerializationOptions = __assign(__assign({}, options), {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head'\n      });\n    }\n\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions);\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName: tagName,\n    attributes: attributes,\n    childNodes: childNodes,\n    isSVG: isSVG\n  };\n}\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\n\nexport function shouldIgnoreElement(element) {\n  if (element.nodeName === 'SCRIPT') {\n    return true;\n  }\n\n  if (element.nodeName === 'LINK') {\n    var relAttribute = getLowerCaseAttribute('rel');\n    return (// Scripts\n      relAttribute === 'preload' && getLowerCaseAttribute('as') === 'script' || // Favicons\n      relAttribute === 'shortcut icon' || relAttribute === 'icon'\n    );\n  }\n\n  if (element.nodeName === 'META') {\n    var nameAttribute = getLowerCaseAttribute('name');\n    var relAttribute = getLowerCaseAttribute('rel');\n    var propertyAttribute = getLowerCaseAttribute('property');\n    return (// Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) || nameAttribute === 'application-name' || relAttribute === 'icon' || relAttribute === 'apple-touch-icon' || relAttribute === 'shortcut icon' || // Description\n      nameAttribute === 'keywords' || nameAttribute === 'description' || // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) || /^(og|twitter):/.test(nameAttribute) || nameAttribute === 'pinterest' || // Robots\n      nameAttribute === 'robots' || nameAttribute === 'googlebot' || nameAttribute === 'bingbot' || // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') || // Authorship\n      nameAttribute === 'author' || nameAttribute === 'generator' || nameAttribute === 'framework' || nameAttribute === 'publisher' || nameAttribute === 'progid' || /^article:/.test(propertyAttribute) || /^product:/.test(propertyAttribute) || // Verification\n      nameAttribute === 'google-site-verification' || nameAttribute === 'yandex-verification' || nameAttribute === 'csrf-token' || nameAttribute === 'p:domain_verify' || nameAttribute === 'verify-v1' || nameAttribute === 'verification' || nameAttribute === 'shopify-checkout-api-token'\n    );\n  }\n\n  function getLowerCaseAttribute(name) {\n    return (element.getAttribute(name) || '').toLowerCase();\n  }\n\n  return false;\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\n\nfunction serializeTextNode(textNode, options) {\n  var _a; // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n\n\n  var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n  var textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);\n\n  if (!textContent) {\n    return;\n  }\n\n  return {\n    type: NodeType.Text,\n    textContent: textContent,\n    isStyle: parentTagName === 'STYLE' ? true : undefined\n  };\n}\n\nfunction serializeCDataNode() {\n  return {\n    type: NodeType.CDATA,\n    textContent: ''\n  };\n}\n\nexport function serializeChildNodes(node, options) {\n  var result = [];\n  forEach(node.childNodes, function (childNode) {\n    var serializedChildNode = serializeNodeWithId(childNode, options);\n\n    if (serializedChildNode) {\n      result.push(serializedChildNode);\n    }\n  });\n  return result;\n}\nexport function serializeAttribute(element, nodePrivacyLevel, attributeName) {\n  var _a, _b, _c;\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null;\n  }\n\n  var attributeValue = element.getAttribute(attributeName);\n\n  if (nodePrivacyLevel === NodePrivacyLevel.MASK) {\n    var tagName = element.tagName;\n\n    switch (attributeName) {\n      // Mask Attribute text content\n      case 'title':\n      case 'alt':\n        return CENSORED_STRING_MARK;\n    } // mask image URLs\n\n\n    if (tagName === 'IMG' || tagName === 'SOURCE') {\n      if (attributeName === 'src' || attributeName === 'srcset') {\n        return CENSORED_IMG_MARK;\n      }\n    } // mask <a> URLs\n\n\n    if (tagName === 'A' && attributeName === 'href') {\n      return CENSORED_STRING_MARK;\n    } // mask data-* attributes\n\n\n    if (attributeValue && attributeName.indexOf('data-') === 0 && attributeName !== PRIVACY_ATTR_NAME) {\n      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n      return CENSORED_STRING_MARK;\n    }\n  }\n\n  if (!attributeValue || typeof attributeValue !== 'string') {\n    return attributeValue;\n  } // Minimum Fix for customer.\n\n\n  if (attributeValue.length > MAX_ATTRIBUTE_VALUE_CHAR_LENGTH && attributeValue.slice(0, 5) === 'data:') {\n    return 'data:truncated';\n  } // Rebuild absolute URLs from relative (without using <base> tag)\n\n\n  var doc = element.ownerDocument;\n\n  switch (attributeName) {\n    case 'src':\n    case 'href':\n      return makeUrlAbsolute(attributeValue, (_a = doc.location) === null || _a === void 0 ? void 0 : _a.href);\n\n    case 'srcset':\n      return makeSrcsetUrlsAbsolute(attributeValue, (_b = doc.location) === null || _b === void 0 ? void 0 : _b.href);\n\n    case 'style':\n      return makeStylesheetUrlsAbsolute(attributeValue, (_c = doc.location) === null || _c === void 0 ? void 0 : _c.href);\n\n    default:\n      return attributeValue;\n  }\n}\nvar _nextId = 1;\n\nfunction generateNextId() {\n  return _nextId++;\n}\n\nvar TAG_NAME_REGEX = /[^a-z1-6-_]/;\n\nfunction getValidTagName(tagName) {\n  var processedTagName = tagName.toLowerCase().trim();\n\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s) {\n  try {\n    var rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule) {\n  return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText;\n}\n\nfunction isCSSImportRule(rule) {\n  return 'styleSheet' in rule;\n}\n\nfunction isSVGElement(el) {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nfunction getAttributesForPrivacyLevel(element, nodePrivacyLevel) {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {};\n  }\n\n  var safeAttrs = {};\n  var tagName = getValidTagName(element.tagName);\n  var doc = element.ownerDocument;\n\n  for (var i = 0; i < element.attributes.length; i += 1) {\n    var attribute = element.attributes.item(i);\n    var attributeName = attribute.name;\n    var attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName);\n\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue;\n    }\n  }\n\n  if (element.value && (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n    var formValue = getElementInputValue(element, nodePrivacyLevel);\n\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue;\n    }\n  }\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n\n\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    var optionElement = element;\n\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected;\n    }\n  } // remote css\n\n\n  if (tagName === 'link') {\n    var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n      return s.href === element.href;\n    });\n    var cssText = getCssRulesString(stylesheet);\n\n    if (cssText && stylesheet) {\n      delete safeAttrs.rel;\n      delete safeAttrs.href;\n      safeAttrs._cssText = makeStylesheetUrlsAbsolute(cssText, stylesheet.href);\n    }\n  } // dynamic stylesheet\n\n\n  if (tagName === 'style' && element.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(element.innerText || element.textContent || '').trim().length) {\n    var cssText = getCssRulesString(element.sheet);\n\n    if (cssText) {\n      safeAttrs._cssText = makeStylesheetUrlsAbsolute(cssText, location.href);\n    }\n  }\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n\n\n  var inputElement = element;\n\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked;\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      safeAttrs.checked = CENSORED_STRING_MARK;\n    }\n  }\n  /**\n   * Serialize the media playback state\n   */\n\n\n  if (tagName === 'audio' || tagName === 'video') {\n    var mediaElement = element;\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n  }\n  /**\n   * Serialize the scroll state for each element\n   */\n\n\n  if (element.scrollLeft) {\n    safeAttrs.rr_scrollLeft = Math.round(element.scrollLeft);\n  }\n\n  if (element.scrollTop) {\n    safeAttrs.rr_scrollTop = Math.round(element.scrollTop);\n  }\n\n  return safeAttrs;\n}","map":{"version":3,"sources":["../../../src/domain/record/serialize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, CENSORED_STRING_MARK, CENSORED_IMG_MARK, } from '../../constants';\nimport { getTextContent, shouldMaskNode, reducePrivacyLevel, getNodeSelfPrivacyLevel, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH, } from './privacy';\nimport { NodeType, } from './types';\nimport { makeStylesheetUrlsAbsolute, getSerializedNodeId, setSerializedNodeId, getElementInputValue, makeSrcsetUrlsAbsolute, makeUrlAbsolute, } from './serializationUtils';\nimport { forEach } from './utils';\nexport function serializeDocument(document, defaultPrivacyLevel) {\n    // We are sure that Documents are never ignored, so this function never returns null\n    return serializeNodeWithId(document, {\n        document: document,\n        parentNodePrivacyLevel: defaultPrivacyLevel,\n    });\n}\nexport function serializeNodeWithId(node, options) {\n    var serializedNode = serializeNode(node, options);\n    if (!serializedNode) {\n        return null;\n    }\n    // Try to reuse the previous id\n    var id = getSerializedNodeId(node) || generateNextId();\n    var serializedNodeWithId = serializedNode;\n    serializedNodeWithId.id = id;\n    setSerializedNodeId(node, id);\n    if (options.serializedNodeIds) {\n        options.serializedNodeIds.add(id);\n    }\n    return serializedNodeWithId;\n}\nfunction serializeNode(node, options) {\n    switch (node.nodeType) {\n        case node.DOCUMENT_NODE:\n            return serializeDocumentNode(node, options);\n        case node.DOCUMENT_TYPE_NODE:\n            return serializeDocumentTypeNode(node);\n        case node.ELEMENT_NODE:\n            return serializeElementNode(node, options);\n        case node.TEXT_NODE:\n            return serializeTextNode(node, options);\n        case node.CDATA_SECTION_NODE:\n            return serializeCDataNode();\n    }\n}\nexport function serializeDocumentNode(document, options) {\n    return {\n        type: NodeType.Document,\n        childNodes: serializeChildNodes(document, options),\n    };\n}\nfunction serializeDocumentTypeNode(documentType) {\n    return {\n        type: NodeType.DocumentType,\n        name: documentType.name,\n        publicId: documentType.publicId,\n        systemId: documentType.systemId,\n    };\n}\n/**\n * Serialzing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, otpion selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nexport function serializeElementNode(element, options) {\n    var _a;\n    var tagName = getValidTagName(element.tagName);\n    var isSVG = isSVGElement(element) || undefined;\n    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n    // parentNodePrivacyLevel option to avoid iterating over all parents\n    var nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        var _b = element.getBoundingClientRect(), width = _b.width, height = _b.height;\n        return {\n            type: NodeType.Element,\n            tagName: tagName,\n            attributes: (_a = {\n                    rr_width: width + \"px\",\n                    rr_height: height + \"px\"\n                },\n                _a[PRIVACY_ATTR_NAME] = PRIVACY_ATTR_VALUE_HIDDEN,\n                _a),\n            childNodes: [],\n            isSVG: isSVG,\n        };\n    }\n    // Ignore Elements like Script and some Link, Metas\n    if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n        return;\n    }\n    var attributes = getAttributesForPrivacyLevel(element, nodePrivacyLevel);\n    var childNodes = [];\n    if (element.childNodes.length) {\n        // OBJECT POOLING OPTIMIZATION:\n        // We should not create a new object systematically as it could impact performances. Try to reuse\n        // the same object as much as possible, and clone it only if we need to.\n        var childNodesSerializationOptions = void 0;\n        if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n            childNodesSerializationOptions = options;\n        }\n        else {\n            childNodesSerializationOptions = __assign(__assign({}, options), { parentNodePrivacyLevel: nodePrivacyLevel, ignoreWhiteSpace: tagName === 'head' });\n        }\n        childNodes = serializeChildNodes(element, childNodesSerializationOptions);\n    }\n    return {\n        type: NodeType.Element,\n        tagName: tagName,\n        attributes: attributes,\n        childNodes: childNodes,\n        isSVG: isSVG,\n    };\n}\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element) {\n    if (element.nodeName === 'SCRIPT') {\n        return true;\n    }\n    if (element.nodeName === 'LINK') {\n        var relAttribute = getLowerCaseAttribute('rel');\n        return (\n        // Scripts\n        (relAttribute === 'preload' && getLowerCaseAttribute('as') === 'script') ||\n            // Favicons\n            relAttribute === 'shortcut icon' ||\n            relAttribute === 'icon');\n    }\n    if (element.nodeName === 'META') {\n        var nameAttribute = getLowerCaseAttribute('name');\n        var relAttribute = getLowerCaseAttribute('rel');\n        var propertyAttribute = getLowerCaseAttribute('property');\n        return (\n        // Favicons\n        /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n            nameAttribute === 'application-name' ||\n            relAttribute === 'icon' ||\n            relAttribute === 'apple-touch-icon' ||\n            relAttribute === 'shortcut icon' ||\n            // Description\n            nameAttribute === 'keywords' ||\n            nameAttribute === 'description' ||\n            // Social\n            /^(og|twitter|fb):/.test(propertyAttribute) ||\n            /^(og|twitter):/.test(nameAttribute) ||\n            nameAttribute === 'pinterest' ||\n            // Robots\n            nameAttribute === 'robots' ||\n            nameAttribute === 'googlebot' ||\n            nameAttribute === 'bingbot' ||\n            // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n            // X-Translated-By\n            element.hasAttribute('http-equiv') ||\n            // Authorship\n            nameAttribute === 'author' ||\n            nameAttribute === 'generator' ||\n            nameAttribute === 'framework' ||\n            nameAttribute === 'publisher' ||\n            nameAttribute === 'progid' ||\n            /^article:/.test(propertyAttribute) ||\n            /^product:/.test(propertyAttribute) ||\n            // Verification\n            nameAttribute === 'google-site-verification' ||\n            nameAttribute === 'yandex-verification' ||\n            nameAttribute === 'csrf-token' ||\n            nameAttribute === 'p:domain_verify' ||\n            nameAttribute === 'verify-v1' ||\n            nameAttribute === 'verification' ||\n            nameAttribute === 'shopify-checkout-api-token');\n    }\n    function getLowerCaseAttribute(name) {\n        return (element.getAttribute(name) || '').toLowerCase();\n    }\n    return false;\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode, options) {\n    var _a;\n    // The parent node may not be a html element which has a tagName attribute.\n    // So just let it be undefined which is ok in this use case.\n    var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n    var textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);\n    if (!textContent) {\n        return;\n    }\n    return {\n        type: NodeType.Text,\n        textContent: textContent,\n        isStyle: parentTagName === 'STYLE' ? true : undefined,\n    };\n}\nfunction serializeCDataNode() {\n    return {\n        type: NodeType.CDATA,\n        textContent: '',\n    };\n}\nexport function serializeChildNodes(node, options) {\n    var result = [];\n    forEach(node.childNodes, function (childNode) {\n        var serializedChildNode = serializeNodeWithId(childNode, options);\n        if (serializedChildNode) {\n            result.push(serializedChildNode);\n        }\n    });\n    return result;\n}\nexport function serializeAttribute(element, nodePrivacyLevel, attributeName) {\n    var _a, _b, _c;\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // dup condition for direct access case\n        return null;\n    }\n    var attributeValue = element.getAttribute(attributeName);\n    if (nodePrivacyLevel === NodePrivacyLevel.MASK) {\n        var tagName = element.tagName;\n        switch (attributeName) {\n            // Mask Attribute text content\n            case 'title':\n            case 'alt':\n                return CENSORED_STRING_MARK;\n        }\n        // mask image URLs\n        if (tagName === 'IMG' || tagName === 'SOURCE') {\n            if (attributeName === 'src' || attributeName === 'srcset') {\n                return CENSORED_IMG_MARK;\n            }\n        }\n        // mask <a> URLs\n        if (tagName === 'A' && attributeName === 'href') {\n            return CENSORED_STRING_MARK;\n        }\n        // mask data-* attributes\n        if (attributeValue && attributeName.indexOf('data-') === 0 && attributeName !== PRIVACY_ATTR_NAME) {\n            // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n            return CENSORED_STRING_MARK;\n        }\n    }\n    if (!attributeValue || typeof attributeValue !== 'string') {\n        return attributeValue;\n    }\n    // Minimum Fix for customer.\n    if (attributeValue.length > MAX_ATTRIBUTE_VALUE_CHAR_LENGTH && attributeValue.slice(0, 5) === 'data:') {\n        return 'data:truncated';\n    }\n    // Rebuild absolute URLs from relative (without using <base> tag)\n    var doc = element.ownerDocument;\n    switch (attributeName) {\n        case 'src':\n        case 'href':\n            return makeUrlAbsolute(attributeValue, (_a = doc.location) === null || _a === void 0 ? void 0 : _a.href);\n        case 'srcset':\n            return makeSrcsetUrlsAbsolute(attributeValue, (_b = doc.location) === null || _b === void 0 ? void 0 : _b.href);\n        case 'style':\n            return makeStylesheetUrlsAbsolute(attributeValue, (_c = doc.location) === null || _c === void 0 ? void 0 : _c.href);\n        default:\n            return attributeValue;\n    }\n}\nvar _nextId = 1;\nfunction generateNextId() {\n    return _nextId++;\n}\nvar TAG_NAME_REGEX = /[^a-z1-6-_]/;\nfunction getValidTagName(tagName) {\n    var processedTagName = tagName.toLowerCase().trim();\n    if (TAG_NAME_REGEX.test(processedTagName)) {\n        // if the tag name is odd and we cannot extract\n        // anything from the string, then we return a\n        // generic div\n        return 'div';\n    }\n    return processedTagName;\n}\nfunction getCssRulesString(s) {\n    try {\n        var rules = s.rules || s.cssRules;\n        return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n    }\n    catch (error) {\n        return null;\n    }\n}\nfunction getCssRuleString(rule) {\n    return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\nfunction getAttributesForPrivacyLevel(element, nodePrivacyLevel) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        return {};\n    }\n    var safeAttrs = {};\n    var tagName = getValidTagName(element.tagName);\n    var doc = element.ownerDocument;\n    for (var i = 0; i < element.attributes.length; i += 1) {\n        var attribute = element.attributes.item(i);\n        var attributeName = attribute.name;\n        var attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName);\n        if (attributeValue !== null) {\n            safeAttrs[attributeName] = attributeValue;\n        }\n    }\n    if (element.value &&\n        (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n        var formValue = getElementInputValue(element, nodePrivacyLevel);\n        if (formValue !== undefined) {\n            safeAttrs.value = formValue;\n        }\n    }\n    /**\n     * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n     */\n    if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n        // For privacy=`MASK`, all the values would be the same, so skip.\n        var optionElement = element;\n        if (optionElement.selected) {\n            safeAttrs.selected = optionElement.selected;\n        }\n    }\n    // remote css\n    if (tagName === 'link') {\n        var stylesheet = Array.from(doc.styleSheets).find(function (s) { return s.href === element.href; });\n        var cssText = getCssRulesString(stylesheet);\n        if (cssText && stylesheet) {\n            delete safeAttrs.rel;\n            delete safeAttrs.href;\n            safeAttrs._cssText = makeStylesheetUrlsAbsolute(cssText, stylesheet.href);\n        }\n    }\n    // dynamic stylesheet\n    if (tagName === 'style' &&\n        element.sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(element.innerText || element.textContent || '').trim().length) {\n        var cssText = getCssRulesString(element.sheet);\n        if (cssText) {\n            safeAttrs._cssText = makeStylesheetUrlsAbsolute(cssText, location.href);\n        }\n    }\n    /**\n     * Forms: input[type=checkbox,radio]\n     * The `checked` property for <input> is a little bit special:\n     * 1. el.checked is a setter that returns if truthy.\n     * 2. getAttribute returns the string value\n     * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n     * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n     */\n    var inputElement = element;\n    if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n        if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n            safeAttrs.checked = !!inputElement.checked;\n        }\n        else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n            safeAttrs.checked = CENSORED_STRING_MARK;\n        }\n    }\n    /**\n     * Serialize the media playback state\n     */\n    if (tagName === 'audio' || tagName === 'video') {\n        var mediaElement = element;\n        safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n    }\n    /**\n     * Serialize the scroll state for each element\n     */\n    if (element.scrollLeft) {\n        safeAttrs.rr_scrollLeft = Math.round(element.scrollLeft);\n    }\n    if (element.scrollTop) {\n        safeAttrs.rr_scrollTop = Math.round(element.scrollTop);\n    }\n    return safeAttrs;\n}\n//# sourceMappingURL=serialize.js.map"]},"metadata":{},"sourceType":"module"}