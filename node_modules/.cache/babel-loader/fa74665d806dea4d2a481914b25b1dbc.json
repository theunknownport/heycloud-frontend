{"ast":null,"code":"import { safeTruncate, isIE } from '@datadog/browser-core';\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\n\nvar DEFAULT_PROGRAMMATIC_ATTRIBUTE = 'data-dd-action-name';\nexport function getActionNameFromElement(element, userProgrammaticAttribute) {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  return getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ATTRIBUTE) || userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute) || getActionNameFromElementForStrategies(element, priorityStrategies) || getActionNameFromElementForStrategies(element, fallbackStrategies) || '';\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement, programmaticAttribute) {\n  var elementWithAttribute; // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(\"[\" + programmaticAttribute + \"]\");\n  } else {\n    var element = targetElement;\n\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element;\n        break;\n      }\n\n      element = element.parentElement;\n    }\n  }\n\n  if (!elementWithAttribute) {\n    return;\n  }\n\n  var name = elementWithAttribute.getAttribute(programmaticAttribute);\n  return truncate(normalizeWhitespace(name.trim()));\n}\n\nvar priorityStrategies = [// associated LABEL text\nfunction (element) {\n  // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n  // instead\n  if (supportsLabelProperty()) {\n    if ('labels' in element && element.labels && element.labels.length > 0) {\n      return getTextualContent(element.labels[0]);\n    }\n  } else if (element.id) {\n    var label = element.ownerDocument && element.ownerDocument.querySelector(\"label[for=\\\"\" + element.id.replace('\"', '\\\\\"') + \"\\\"]\");\n    return label && getTextualContent(label);\n  }\n}, // INPUT button (and associated) value\nfunction (element) {\n  if (element.nodeName === 'INPUT') {\n    var input = element;\n    var type = input.getAttribute('type');\n\n    if (type === 'button' || type === 'submit' || type === 'reset') {\n      return input.value;\n    }\n  }\n}, // BUTTON, LABEL or button-like element text\nfunction (element) {\n  if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n    return getTextualContent(element);\n  }\n}, function (element) {\n  return element.getAttribute('aria-label');\n}, // associated element text designated by the aria-labelledby attribute\nfunction (element) {\n  var labelledByAttribute = element.getAttribute('aria-labelledby');\n\n  if (labelledByAttribute) {\n    return labelledByAttribute.split(/\\s+/).map(function (id) {\n      return getElementById(element, id);\n    }).filter(function (label) {\n      return Boolean(label);\n    }).map(getTextualContent).join(' ');\n  }\n}, function (element) {\n  return element.getAttribute('alt');\n}, function (element) {\n  return element.getAttribute('name');\n}, function (element) {\n  return element.getAttribute('title');\n}, function (element) {\n  return element.getAttribute('placeholder');\n}, // SELECT first OPTION text\nfunction (element) {\n  if ('options' in element && element.options.length > 0) {\n    return getTextualContent(element.options[0]);\n  }\n}];\nvar fallbackStrategies = [function (element) {\n  return getTextualContent(element);\n}];\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\n\nvar MAX_PARENTS_TO_CONSIDER = 10;\n\nfunction getActionNameFromElementForStrategies(targetElement, strategies) {\n  var element = targetElement;\n  var recursionCounter = 0;\n\n  while (recursionCounter <= MAX_PARENTS_TO_CONSIDER && element && element.nodeName !== 'BODY' && element.nodeName !== 'HTML' && element.nodeName !== 'HEAD') {\n    for (var _i = 0, strategies_1 = strategies; _i < strategies_1.length; _i++) {\n      var strategy = strategies_1[_i];\n      var name_1 = strategy(element);\n\n      if (typeof name_1 === 'string') {\n        var trimmedName = name_1.trim();\n\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName));\n        }\n      }\n    } // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n\n\n    if (element.nodeName === 'FORM') {\n      break;\n    }\n\n    element = element.parentElement;\n    recursionCounter += 1;\n  }\n}\n\nfunction normalizeWhitespace(s) {\n  return s.replace(/\\s+/g, ' ');\n}\n\nfunction truncate(s) {\n  return s.length > 100 ? safeTruncate(s, 100) + \" [...]\" : s;\n}\n\nfunction getElementById(refElement, id) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;\n}\n\nfunction getTextualContent(element) {\n  if (element.isContentEditable) {\n    return;\n  }\n\n  if ('innerText' in element) {\n    var text = element.innerText;\n\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      var elementsTextToRemove = element.querySelectorAll('script, style'); // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n      for (var i = 0; i < elementsTextToRemove.length; i += 1) {\n        var innerText = elementsTextToRemove[i].innerText;\n\n        if (innerText.trim().length > 0) {\n          text = text.replace(innerText, '');\n        }\n      }\n    }\n\n    return text;\n  }\n\n  return element.textContent;\n}\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\n\n\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  return !isIE();\n}\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\n\n\nvar supportsLabelPropertyResult;\n\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype;\n  }\n\n  return supportsLabelPropertyResult;\n}\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\n\n\nvar supportsElementClosestResult;\n\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype;\n  }\n\n  return supportsElementClosestResult;\n}","map":{"version":3,"sources":["../../../../src/domain/rumEventsCollection/action/getActionNameFromElement.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { safeTruncate, isIE } from '@datadog/browser-core';\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nvar DEFAULT_PROGRAMMATIC_ATTRIBUTE = 'data-dd-action-name';\nexport function getActionNameFromElement(element, userProgrammaticAttribute) {\n    // Proceed to get the action name in two steps:\n    // * first, get the name programmatically, explicitly defined by the user.\n    // * then, use strategies that are known to return good results. Those strategies will be used on\n    //   the element and a few parents, but it's likely that they won't succeed at all.\n    // * if no name is found this way, use strategies returning less accurate names as a fallback.\n    //   Those are much likely to succeed.\n    return (getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ATTRIBUTE) ||\n        (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute)) ||\n        getActionNameFromElementForStrategies(element, priorityStrategies) ||\n        getActionNameFromElementForStrategies(element, fallbackStrategies) ||\n        '');\n}\nfunction getActionNameFromElementProgrammatically(targetElement, programmaticAttribute) {\n    var elementWithAttribute;\n    // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n    // without limit. It is up to the user to declare a relevant naming strategy.\n    // If available, use element.closest() to match get the attribute from the element or any of its\n    // parent.  Else fallback to a more traditional implementation.\n    if (supportsElementClosest()) {\n        elementWithAttribute = targetElement.closest(\"[\" + programmaticAttribute + \"]\");\n    }\n    else {\n        var element = targetElement;\n        while (element) {\n            if (element.hasAttribute(programmaticAttribute)) {\n                elementWithAttribute = element;\n                break;\n            }\n            element = element.parentElement;\n        }\n    }\n    if (!elementWithAttribute) {\n        return;\n    }\n    var name = elementWithAttribute.getAttribute(programmaticAttribute);\n    return truncate(normalizeWhitespace(name.trim()));\n}\nvar priorityStrategies = [\n    // associated LABEL text\n    function (element) {\n        // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n        // instead\n        if (supportsLabelProperty()) {\n            if ('labels' in element && element.labels && element.labels.length > 0) {\n                return getTextualContent(element.labels[0]);\n            }\n        }\n        else if (element.id) {\n            var label = element.ownerDocument && element.ownerDocument.querySelector(\"label[for=\\\"\" + element.id.replace('\"', '\\\\\"') + \"\\\"]\");\n            return label && getTextualContent(label);\n        }\n    },\n    // INPUT button (and associated) value\n    function (element) {\n        if (element.nodeName === 'INPUT') {\n            var input = element;\n            var type = input.getAttribute('type');\n            if (type === 'button' || type === 'submit' || type === 'reset') {\n                return input.value;\n            }\n        }\n    },\n    // BUTTON, LABEL or button-like element text\n    function (element) {\n        if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n            return getTextualContent(element);\n        }\n    },\n    function (element) { return element.getAttribute('aria-label'); },\n    // associated element text designated by the aria-labelledby attribute\n    function (element) {\n        var labelledByAttribute = element.getAttribute('aria-labelledby');\n        if (labelledByAttribute) {\n            return labelledByAttribute\n                .split(/\\s+/)\n                .map(function (id) { return getElementById(element, id); })\n                .filter(function (label) { return Boolean(label); })\n                .map(getTextualContent)\n                .join(' ');\n        }\n    },\n    function (element) { return element.getAttribute('alt'); },\n    function (element) { return element.getAttribute('name'); },\n    function (element) { return element.getAttribute('title'); },\n    function (element) { return element.getAttribute('placeholder'); },\n    // SELECT first OPTION text\n    function (element) {\n        if ('options' in element && element.options.length > 0) {\n            return getTextualContent(element.options[0]);\n        }\n    },\n];\nvar fallbackStrategies = [function (element) { return getTextualContent(element); }];\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nvar MAX_PARENTS_TO_CONSIDER = 10;\nfunction getActionNameFromElementForStrategies(targetElement, strategies) {\n    var element = targetElement;\n    var recursionCounter = 0;\n    while (recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n        element &&\n        element.nodeName !== 'BODY' &&\n        element.nodeName !== 'HTML' &&\n        element.nodeName !== 'HEAD') {\n        for (var _i = 0, strategies_1 = strategies; _i < strategies_1.length; _i++) {\n            var strategy = strategies_1[_i];\n            var name_1 = strategy(element);\n            if (typeof name_1 === 'string') {\n                var trimmedName = name_1.trim();\n                if (trimmedName) {\n                    return truncate(normalizeWhitespace(trimmedName));\n                }\n            }\n        }\n        // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n        // be reconsidered in the future.\n        if (element.nodeName === 'FORM') {\n            break;\n        }\n        element = element.parentElement;\n        recursionCounter += 1;\n    }\n}\nfunction normalizeWhitespace(s) {\n    return s.replace(/\\s+/g, ' ');\n}\nfunction truncate(s) {\n    return s.length > 100 ? safeTruncate(s, 100) + \" [...]\" : s;\n}\nfunction getElementById(refElement, id) {\n    // Use the element ownerDocument here, because tests are executed in an iframe, so\n    // document.getElementById won't work.\n    return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;\n}\nfunction getTextualContent(element) {\n    if (element.isContentEditable) {\n        return;\n    }\n    if ('innerText' in element) {\n        var text = element.innerText;\n        if (!supportsInnerTextScriptAndStyleRemoval()) {\n            // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n            // be relatively fast and work in most cases.\n            var elementsTextToRemove = element.querySelectorAll('script, style');\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (var i = 0; i < elementsTextToRemove.length; i += 1) {\n                var innerText = elementsTextToRemove[i].innerText;\n                if (innerText.trim().length > 0) {\n                    text = text.replace(innerText, '');\n                }\n            }\n        }\n        return text;\n    }\n    return element.textContent;\n}\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n    return !isIE();\n}\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nvar supportsLabelPropertyResult;\nfunction supportsLabelProperty() {\n    if (supportsLabelPropertyResult === undefined) {\n        supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype;\n    }\n    return supportsLabelPropertyResult;\n}\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nvar supportsElementClosestResult;\nfunction supportsElementClosest() {\n    if (supportsElementClosestResult === undefined) {\n        supportsElementClosestResult = 'closest' in HTMLElement.prototype;\n    }\n    return supportsElementClosestResult;\n}\n//# sourceMappingURL=getActionNameFromElement.js.map"]},"metadata":{},"sourceType":"module"}