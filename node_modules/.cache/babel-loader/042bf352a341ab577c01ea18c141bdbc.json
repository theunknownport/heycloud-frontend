{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { getOrigin, objectEntries } from '@datadog/browser-core';\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the the\n * request did not reach the server, but we the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course it might not be the case every time, but it should limit having incomplete traces a\n * bit..\n * */\n\nexport function clearTracingIfNeeded(context) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined;\n    context.spanId = undefined;\n  }\n}\nexport function startTracer(configuration, session) {\n  return {\n    clearTracingIfNeeded: clearTracingIfNeeded,\n    traceFetch: function (context) {\n      return injectHeadersIfTracingAllowed(configuration, context, session, function (tracingHeaders) {\n        var _a;\n\n        if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {\n          context.input = new Request(context.input);\n          Object.keys(tracingHeaders).forEach(function (key) {\n            ;\n            context.input.headers.append(key, tracingHeaders[key]);\n          });\n        } else {\n          context.init = __assign({}, context.init);\n          var headers_1 = [];\n\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach(function (value, key) {\n              headers_1.push([key, value]);\n            });\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach(function (header) {\n              headers_1.push(header);\n            });\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach(function (key) {\n              headers_1.push([key, context.init.headers[key]]);\n            });\n          }\n\n          context.init.headers = headers_1.concat(objectEntries(tracingHeaders));\n        }\n      });\n    },\n    traceXhr: function (context, xhr) {\n      return injectHeadersIfTracingAllowed(configuration, context, session, function (tracingHeaders) {\n        Object.keys(tracingHeaders).forEach(function (name) {\n          xhr.setRequestHeader(name, tracingHeaders[name]);\n        });\n      });\n    }\n  };\n}\n\nfunction injectHeadersIfTracingAllowed(configuration, context, session, inject) {\n  if (!isTracingSupported() || !isAllowedUrl(configuration, context.url) || !session.isTracked()) {\n    return;\n  }\n\n  context.traceId = new TraceIdentifier();\n  context.spanId = new TraceIdentifier();\n  inject(makeTracingHeaders(context.traceId, context.spanId));\n}\n\nfunction isAllowedUrl(configuration, requestUrl) {\n  var requestOrigin = getOrigin(requestUrl);\n\n  for (var _i = 0, _a = configuration.allowedTracingOrigins; _i < _a.length; _i++) {\n    var allowedOrigin = _a[_i];\n\n    if (requestOrigin === allowedOrigin || allowedOrigin instanceof RegExp && allowedOrigin.test(requestOrigin)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isTracingSupported() {\n  return getCrypto() !== undefined;\n}\n\nfunction getCrypto() {\n  return window.crypto || window.msCrypto;\n}\n\nfunction makeTracingHeaders(traceId, spanId) {\n  return {\n    'x-datadog-origin': 'rum',\n    'x-datadog-parent-id': spanId.toDecimalString(),\n    'x-datadog-sampled': '1',\n    'x-datadog-sampling-priority': '1',\n    'x-datadog-trace-id': traceId.toDecimalString()\n  };\n}\n/* eslint-disable no-bitwise */\n\n\nvar TraceIdentifier =\n/** @class */\nfunction () {\n  function TraceIdentifier() {\n    this.buffer = new Uint8Array(8);\n    getCrypto().getRandomValues(this.buffer);\n    this.buffer[0] = this.buffer[0] & 0x7f; // force 63-bit\n  }\n\n  TraceIdentifier.prototype.toString = function (radix) {\n    var high = this.readInt32(0);\n    var low = this.readInt32(4);\n    var str = '';\n\n    while (1) {\n      var mod = high % radix * 4294967296 + low;\n      high = Math.floor(high / radix);\n      low = Math.floor(mod / radix);\n      str = (mod % radix).toString(radix) + str;\n\n      if (!high && !low) {\n        break;\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Format used everywhere except the trace intake\n   */\n\n\n  TraceIdentifier.prototype.toDecimalString = function () {\n    return this.toString(10);\n  };\n\n  TraceIdentifier.prototype.readInt32 = function (offset) {\n    return this.buffer[offset] * 16777216 + (this.buffer[offset + 1] << 16) + (this.buffer[offset + 2] << 8) + this.buffer[offset + 3];\n  };\n\n  return TraceIdentifier;\n}();\n\nexport { TraceIdentifier };\n/* eslint-enable no-bitwise */","map":{"version":3,"sources":["../../../src/domain/tracing/tracer.ts"],"names":[],"mappings":";AAAA,SAAwB,SAAxB,EAAmC,aAAnC,QAAwD,uBAAxD;AAmBA;;;;;;;;;;;;;;;;AAgBK;;AACL,OAAM,SAAU,oBAAV,CAA+B,OAA/B,EAAuF;AAC3F,MAAI,OAAO,CAAC,MAAR,KAAmB,CAAnB,IAAwB,CAAC,OAAO,CAAC,SAArC,EAAgD;AAC9C,IAAA,OAAO,CAAC,OAAR,GAAkB,SAAlB;AACA,IAAA,OAAO,CAAC,MAAR,GAAiB,SAAjB;AACD;AACF;AAED,OAAM,SAAU,WAAV,CAAsB,aAAtB,EAAoD,OAApD,EAAuE;AAC3E,SAAO;AACL,IAAA,oBAAoB,EAAA,oBADf;AAEL,IAAA,UAAU,EAAE,UAAC,OAAD,EAAQ;AAClB,aAAA,6BAA6B,CAAC,aAAD,EAAgB,OAAhB,EAAyB,OAAzB,EAAkC,UAAC,cAAD,EAA+B;;;AAC5F,YAAI,OAAO,CAAC,KAAR,YAAyB,OAAzB,IAAoC,EAAA,CAAA,EAAA,GAAC,OAAO,CAAC,IAAT,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAa,EAAA,CAAE,OAAf,CAAxC,EAAgE;AAC9D,UAAA,OAAO,CAAC,KAAR,GAAgB,IAAI,OAAJ,CAAY,OAAO,CAAC,KAApB,CAAhB;AACA,UAAA,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,OAA5B,CAAoC,UAAC,GAAD,EAAI;AACtC;AAAE,YAAA,OAAO,CAAC,KAAR,CAA0B,OAA1B,CAAkC,MAAlC,CAAyC,GAAzC,EAA8C,cAAc,CAAC,GAAD,CAA5D;AACH,WAFD;AAGD,SALD,MAKO;AACL,UAAA,OAAO,CAAC,IAAR,GAAY,QAAA,CAAA,EAAA,EAAQ,OAAO,CAAC,IAAhB,CAAZ;AACA,cAAM,SAAO,GAAe,EAA5B;;AACA,cAAI,OAAO,CAAC,IAAR,CAAa,OAAb,YAAgC,OAApC,EAA6C;AAC3C,YAAA,OAAO,CAAC,IAAR,CAAa,OAAb,CAAqB,OAArB,CAA6B,UAAC,KAAD,EAAQ,GAAR,EAAW;AACtC,cAAA,SAAO,CAAC,IAAR,CAAa,CAAC,GAAD,EAAM,KAAN,CAAb;AACD,aAFD;AAGD,WAJD,MAIO,IAAI,KAAK,CAAC,OAAN,CAAc,OAAO,CAAC,IAAR,CAAa,OAA3B,CAAJ,EAAyC;AAC9C,YAAA,OAAO,CAAC,IAAR,CAAa,OAAb,CAAqB,OAArB,CAA6B,UAAC,MAAD,EAAO;AAClC,cAAA,SAAO,CAAC,IAAR,CAAa,MAAb;AACD,aAFD;AAGD,WAJM,MAIA,IAAI,OAAO,CAAC,IAAR,CAAa,OAAjB,EAA0B;AAC/B,YAAA,MAAM,CAAC,IAAP,CAAY,OAAO,CAAC,IAAR,CAAa,OAAzB,EAAkC,OAAlC,CAA0C,UAAC,GAAD,EAAI;AAC5C,cAAA,SAAO,CAAC,IAAR,CAAa,CAAC,GAAD,EAAO,OAAO,CAAC,IAAR,CAAc,OAAd,CAAiD,GAAjD,CAAP,CAAb;AACD,aAFD;AAGD;;AACD,UAAA,OAAO,CAAC,IAAR,CAAa,OAAb,GAAuB,SAAO,CAAC,MAAR,CAAe,aAAa,CAAC,cAAD,CAA5B,CAAvB;AACD;AACF,OAxB4B,CAA7B;AAwBE,KA3BC;AA4BL,IAAA,QAAQ,EAAE,UAAC,OAAD,EAAU,GAAV,EAAa;AACrB,aAAA,6BAA6B,CAAC,aAAD,EAAgB,OAAhB,EAAyB,OAAzB,EAAkC,UAAC,cAAD,EAA+B;AAC5F,QAAA,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,OAA5B,CAAoC,UAAC,IAAD,EAAK;AACvC,UAAA,GAAG,CAAC,gBAAJ,CAAqB,IAArB,EAA2B,cAAc,CAAC,IAAD,CAAzC;AACD,SAFD;AAGD,OAJ4B,CAA7B;AAIE;AAjCC,GAAP;AAmCD;;AAED,SAAS,6BAAT,CACE,aADF,EAEE,OAFF,EAGE,OAHF,EAIE,MAJF,EAIkD;AAEhD,MAAI,CAAC,kBAAkB,EAAnB,IAAyB,CAAC,YAAY,CAAC,aAAD,EAAgB,OAAO,CAAC,GAAxB,CAAtC,IAAuE,CAAC,OAAO,CAAC,SAAR,EAA5E,EAAiG;AAC/F;AACD;;AAED,EAAA,OAAO,CAAC,OAAR,GAAkB,IAAI,eAAJ,EAAlB;AACA,EAAA,OAAO,CAAC,MAAR,GAAiB,IAAI,eAAJ,EAAjB;AACA,EAAA,MAAM,CAAC,kBAAkB,CAAC,OAAO,CAAC,OAAT,EAAkB,OAAO,CAAC,MAA1B,CAAnB,CAAN;AACD;;AAED,SAAS,YAAT,CAAsB,aAAtB,EAAoD,UAApD,EAAsE;AACpE,MAAM,aAAa,GAAG,SAAS,CAAC,UAAD,CAA/B;;AACA,OAA4B,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,aAAa,CAAC,qBAA1C,EAA4B,EAAA,GAAA,EAAA,CAAA,MAA5B,EAA4B,EAAA,EAA5B,EAAiE;AAA5D,QAAM,aAAa,GAAA,EAAA,CAAA,EAAA,CAAnB;;AACH,QAAI,aAAa,KAAK,aAAlB,IAAoC,aAAa,YAAY,MAAzB,IAAmC,aAAa,CAAC,IAAd,CAAmB,aAAnB,CAA3E,EAA+G;AAC7G,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD;;AAED,OAAM,SAAU,kBAAV,GAA4B;AAChC,SAAO,SAAS,OAAO,SAAvB;AACD;;AAED,SAAS,SAAT,GAAkB;AAChB,SAAO,MAAM,CAAC,MAAP,IAAkB,MAAc,CAAC,QAAxC;AACD;;AAED,SAAS,kBAAT,CAA4B,OAA5B,EAAsD,MAAtD,EAA6E;AAC3E,SAAO;AACL,wBAAoB,KADf;AAEL,2BAAuB,MAAM,CAAC,eAAP,EAFlB;AAGL,yBAAqB,GAHhB;AAIL,mCAA+B,GAJ1B;AAKL,0BAAsB,OAAO,CAAC,eAAR;AALjB,GAAP;AAOD;AAED;;;AACA,IAAA,eAAA;AAAA;AAAA,YAAA;AAGE,WAAA,eAAA,GAAA;AAFQ,SAAA,MAAA,GAAqB,IAAI,UAAJ,CAAe,CAAf,CAArB;AAGN,IAAA,SAAS,GAAG,eAAZ,CAA4B,KAAK,MAAjC;AACA,SAAK,MAAL,CAAY,CAAZ,IAAiB,KAAK,MAAL,CAAY,CAAZ,IAAiB,IAAlC,CAFF,CAEyC;AACxC;;AAED,EAAA,eAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,KAAT,EAAsB;AACpB,QAAI,IAAI,GAAG,KAAK,SAAL,CAAe,CAAf,CAAX;AACA,QAAI,GAAG,GAAG,KAAK,SAAL,CAAe,CAAf,CAAV;AACA,QAAI,GAAG,GAAG,EAAV;;AAEA,WAAO,CAAP,EAAU;AACR,UAAM,GAAG,GAAI,IAAI,GAAG,KAAR,GAAiB,UAAjB,GAA8B,GAA1C;AAEA,MAAA,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,GAAG,KAAlB,CAAP;AACA,MAAA,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,GAAG,GAAG,KAAjB,CAAN;AACA,MAAA,GAAG,GAAG,CAAC,GAAG,GAAG,KAAP,EAAc,QAAd,CAAuB,KAAvB,IAAgC,GAAtC;;AAEA,UAAI,CAAC,IAAD,IAAS,CAAC,GAAd,EAAmB;AACjB;AACD;AACF;;AAED,WAAO,GAAP;AACD,GAlBD;AAoBA;;AAEG;;;AACH,EAAA,eAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,WAAO,KAAK,QAAL,CAAc,EAAd,CAAP;AACD,GAFD;;AAIQ,EAAA,eAAA,CAAA,SAAA,CAAA,SAAA,GAAR,UAAkB,MAAlB,EAAgC;AAC9B,WACE,KAAK,MAAL,CAAY,MAAZ,IAAsB,QAAtB,IACC,KAAK,MAAL,CAAY,MAAM,GAAG,CAArB,KAA2B,EAD5B,KAEC,KAAK,MAAL,CAAY,MAAM,GAAG,CAArB,KAA2B,CAF5B,IAGA,KAAK,MAAL,CAAY,MAAM,GAAG,CAArB,CAJF;AAMD,GAPO;;AAQV,SAAA,eAAA;AAAC,CA3CD,EAAA;;;AA4CA","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { getOrigin, objectEntries } from '@datadog/browser-core';\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the the\n * request did not reach the server, but we the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course it might not be the case every time, but it should limit having incomplete traces a\n * bit..\n * */\nexport function clearTracingIfNeeded(context) {\n    if (context.status === 0 && !context.isAborted) {\n        context.traceId = undefined;\n        context.spanId = undefined;\n    }\n}\nexport function startTracer(configuration, session) {\n    return {\n        clearTracingIfNeeded: clearTracingIfNeeded,\n        traceFetch: function (context) {\n            return injectHeadersIfTracingAllowed(configuration, context, session, function (tracingHeaders) {\n                var _a;\n                if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {\n                    context.input = new Request(context.input);\n                    Object.keys(tracingHeaders).forEach(function (key) {\n                        ;\n                        context.input.headers.append(key, tracingHeaders[key]);\n                    });\n                }\n                else {\n                    context.init = __assign({}, context.init);\n                    var headers_1 = [];\n                    if (context.init.headers instanceof Headers) {\n                        context.init.headers.forEach(function (value, key) {\n                            headers_1.push([key, value]);\n                        });\n                    }\n                    else if (Array.isArray(context.init.headers)) {\n                        context.init.headers.forEach(function (header) {\n                            headers_1.push(header);\n                        });\n                    }\n                    else if (context.init.headers) {\n                        Object.keys(context.init.headers).forEach(function (key) {\n                            headers_1.push([key, context.init.headers[key]]);\n                        });\n                    }\n                    context.init.headers = headers_1.concat(objectEntries(tracingHeaders));\n                }\n            });\n        },\n        traceXhr: function (context, xhr) {\n            return injectHeadersIfTracingAllowed(configuration, context, session, function (tracingHeaders) {\n                Object.keys(tracingHeaders).forEach(function (name) {\n                    xhr.setRequestHeader(name, tracingHeaders[name]);\n                });\n            });\n        },\n    };\n}\nfunction injectHeadersIfTracingAllowed(configuration, context, session, inject) {\n    if (!isTracingSupported() || !isAllowedUrl(configuration, context.url) || !session.isTracked()) {\n        return;\n    }\n    context.traceId = new TraceIdentifier();\n    context.spanId = new TraceIdentifier();\n    inject(makeTracingHeaders(context.traceId, context.spanId));\n}\nfunction isAllowedUrl(configuration, requestUrl) {\n    var requestOrigin = getOrigin(requestUrl);\n    for (var _i = 0, _a = configuration.allowedTracingOrigins; _i < _a.length; _i++) {\n        var allowedOrigin = _a[_i];\n        if (requestOrigin === allowedOrigin || (allowedOrigin instanceof RegExp && allowedOrigin.test(requestOrigin))) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function isTracingSupported() {\n    return getCrypto() !== undefined;\n}\nfunction getCrypto() {\n    return window.crypto || window.msCrypto;\n}\nfunction makeTracingHeaders(traceId, spanId) {\n    return {\n        'x-datadog-origin': 'rum',\n        'x-datadog-parent-id': spanId.toDecimalString(),\n        'x-datadog-sampled': '1',\n        'x-datadog-sampling-priority': '1',\n        'x-datadog-trace-id': traceId.toDecimalString(),\n    };\n}\n/* eslint-disable no-bitwise */\nvar TraceIdentifier = /** @class */ (function () {\n    function TraceIdentifier() {\n        this.buffer = new Uint8Array(8);\n        getCrypto().getRandomValues(this.buffer);\n        this.buffer[0] = this.buffer[0] & 0x7f; // force 63-bit\n    }\n    TraceIdentifier.prototype.toString = function (radix) {\n        var high = this.readInt32(0);\n        var low = this.readInt32(4);\n        var str = '';\n        while (1) {\n            var mod = (high % radix) * 4294967296 + low;\n            high = Math.floor(high / radix);\n            low = Math.floor(mod / radix);\n            str = (mod % radix).toString(radix) + str;\n            if (!high && !low) {\n                break;\n            }\n        }\n        return str;\n    };\n    /**\n     * Format used everywhere except the trace intake\n     */\n    TraceIdentifier.prototype.toDecimalString = function () {\n        return this.toString(10);\n    };\n    TraceIdentifier.prototype.readInt32 = function (offset) {\n        return (this.buffer[offset] * 16777216 +\n            (this.buffer[offset + 1] << 16) +\n            (this.buffer[offset + 2] << 8) +\n            this.buffer[offset + 3]);\n    };\n    return TraceIdentifier;\n}());\nexport { TraceIdentifier };\n/* eslint-enable no-bitwise */\n//# sourceMappingURL=tracer.js.map"]},"metadata":{},"sourceType":"module"}