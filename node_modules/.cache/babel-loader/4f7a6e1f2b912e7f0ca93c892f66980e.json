{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { display } from '../tools/display';\nimport { toStackTraceString } from '../tools/error';\nimport { assign, combine, jsonStringify } from '../tools/utils';\nimport { Batch, HttpRequest } from '../transport';\nimport { computeStackTrace } from './tracekit';\nvar StatusType;\n\n(function (StatusType) {\n  StatusType[\"info\"] = \"info\";\n  StatusType[\"error\"] = \"error\";\n})(StatusType || (StatusType = {}));\n\nvar monitoringConfiguration = {\n  maxMessagesPerPage: 0,\n  sentMessageCount: 0\n};\nvar externalContextProvider;\nexport function startInternalMonitoring(configuration) {\n  if (configuration.internalMonitoringEndpointBuilder) {\n    var batch = startMonitoringBatch(configuration);\n    assign(monitoringConfiguration, {\n      batch: batch,\n      maxMessagesPerPage: configuration.maxInternalMonitoringMessagesPerPage,\n      sentMessageCount: 0\n    });\n  }\n\n  return {\n    setExternalContextProvider: function (provider) {\n      externalContextProvider = provider;\n    }\n  };\n}\n\nfunction startMonitoringBatch(configuration) {\n  var primaryBatch = createMonitoringBatch(configuration.internalMonitoringEndpointBuilder);\n  var replicaBatch;\n\n  if (configuration.replica !== undefined) {\n    replicaBatch = createMonitoringBatch(configuration.replica.internalMonitoringEndpointBuilder);\n  }\n\n  function createMonitoringBatch(endpointBuilder) {\n    return new Batch(new HttpRequest(endpointBuilder, configuration.batchBytesLimit), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout);\n  }\n\n  function withContext(message) {\n    return combine({\n      date: new Date().getTime(),\n      view: {\n        referrer: document.referrer,\n        url: window.location.href\n      }\n    }, externalContextProvider !== undefined ? externalContextProvider() : {}, message);\n  }\n\n  return {\n    add: function (message) {\n      var contextualizedMessage = withContext(message);\n      primaryBatch.add(contextualizedMessage);\n\n      if (replicaBatch) {\n        replicaBatch.add(contextualizedMessage);\n      }\n    }\n  };\n}\n\nexport function resetInternalMonitoring() {\n  monitoringConfiguration.batch = undefined;\n}\nexport function monitored(_, __, descriptor) {\n  var originalMethod = descriptor.value;\n\n  descriptor.value = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var decorated = monitoringConfiguration.batch ? monitor(originalMethod) : originalMethod;\n    return decorated.apply(this, args);\n  };\n}\nexport function monitor(fn) {\n  return function () {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments);\n  }; // consider output type has input type\n}\nexport function callMonitored(fn, context, args) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args);\n  } catch (e) {\n    logErrorIfDebug(e);\n\n    try {\n      addErrorToMonitoringBatch(e);\n    } catch (e) {\n      logErrorIfDebug(e);\n    }\n  }\n}\nexport function addMonitoringMessage(message, context) {\n  logMessageIfDebug(message, context);\n  addToMonitoringBatch(__assign(__assign({\n    message: message\n  }, context), {\n    status: StatusType.info\n  }));\n}\nexport function addErrorToMonitoringBatch(e) {\n  addToMonitoringBatch(__assign(__assign({}, formatError(e)), {\n    status: StatusType.error\n  }));\n}\n\nfunction addToMonitoringBatch(message) {\n  if (monitoringConfiguration.batch && monitoringConfiguration.sentMessageCount < monitoringConfiguration.maxMessagesPerPage) {\n    monitoringConfiguration.sentMessageCount += 1;\n    monitoringConfiguration.batch.add(message);\n  }\n}\n\nfunction formatError(e) {\n  if (e instanceof Error) {\n    var stackTrace = computeStackTrace(e);\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(stackTrace)\n      },\n      message: stackTrace.message\n    };\n  }\n\n  return {\n    error: {\n      stack: 'Not an instance of error'\n    },\n    message: \"Uncaught \" + jsonStringify(e)\n  };\n}\n\nexport function setDebugMode(debugMode) {\n  monitoringConfiguration.debugMode = debugMode;\n}\n\nfunction logErrorIfDebug(e) {\n  if (monitoringConfiguration.debugMode) {\n    display.error('[INTERNAL ERROR]', e);\n  }\n}\n\nfunction logMessageIfDebug(message, context) {\n  if (monitoringConfiguration.debugMode) {\n    display.log('[MONITORING MESSAGE]', message, context);\n  }\n}","map":{"version":3,"sources":["../../src/domain/internalMonitoring.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { display } from '../tools/display';\nimport { toStackTraceString } from '../tools/error';\nimport { assign, combine, jsonStringify } from '../tools/utils';\nimport { Batch, HttpRequest } from '../transport';\nimport { computeStackTrace } from './tracekit';\nvar StatusType;\n(function (StatusType) {\n    StatusType[\"info\"] = \"info\";\n    StatusType[\"error\"] = \"error\";\n})(StatusType || (StatusType = {}));\nvar monitoringConfiguration = { maxMessagesPerPage: 0, sentMessageCount: 0 };\nvar externalContextProvider;\nexport function startInternalMonitoring(configuration) {\n    if (configuration.internalMonitoringEndpointBuilder) {\n        var batch = startMonitoringBatch(configuration);\n        assign(monitoringConfiguration, {\n            batch: batch,\n            maxMessagesPerPage: configuration.maxInternalMonitoringMessagesPerPage,\n            sentMessageCount: 0,\n        });\n    }\n    return {\n        setExternalContextProvider: function (provider) {\n            externalContextProvider = provider;\n        },\n    };\n}\nfunction startMonitoringBatch(configuration) {\n    var primaryBatch = createMonitoringBatch(configuration.internalMonitoringEndpointBuilder);\n    var replicaBatch;\n    if (configuration.replica !== undefined) {\n        replicaBatch = createMonitoringBatch(configuration.replica.internalMonitoringEndpointBuilder);\n    }\n    function createMonitoringBatch(endpointBuilder) {\n        return new Batch(new HttpRequest(endpointBuilder, configuration.batchBytesLimit), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout);\n    }\n    function withContext(message) {\n        return combine({\n            date: new Date().getTime(),\n            view: {\n                referrer: document.referrer,\n                url: window.location.href,\n            },\n        }, externalContextProvider !== undefined ? externalContextProvider() : {}, message);\n    }\n    return {\n        add: function (message) {\n            var contextualizedMessage = withContext(message);\n            primaryBatch.add(contextualizedMessage);\n            if (replicaBatch) {\n                replicaBatch.add(contextualizedMessage);\n            }\n        },\n    };\n}\nexport function resetInternalMonitoring() {\n    monitoringConfiguration.batch = undefined;\n}\nexport function monitored(_, __, descriptor) {\n    var originalMethod = descriptor.value;\n    descriptor.value = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var decorated = monitoringConfiguration.batch ? monitor(originalMethod) : originalMethod;\n        return decorated.apply(this, args);\n    };\n}\nexport function monitor(fn) {\n    return function () {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return callMonitored(fn, this, arguments);\n    }; // consider output type has input type\n}\nexport function callMonitored(fn, context, args) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return fn.apply(context, args);\n    }\n    catch (e) {\n        logErrorIfDebug(e);\n        try {\n            addErrorToMonitoringBatch(e);\n        }\n        catch (e) {\n            logErrorIfDebug(e);\n        }\n    }\n}\nexport function addMonitoringMessage(message, context) {\n    logMessageIfDebug(message, context);\n    addToMonitoringBatch(__assign(__assign({ message: message }, context), { status: StatusType.info }));\n}\nexport function addErrorToMonitoringBatch(e) {\n    addToMonitoringBatch(__assign(__assign({}, formatError(e)), { status: StatusType.error }));\n}\nfunction addToMonitoringBatch(message) {\n    if (monitoringConfiguration.batch &&\n        monitoringConfiguration.sentMessageCount < monitoringConfiguration.maxMessagesPerPage) {\n        monitoringConfiguration.sentMessageCount += 1;\n        monitoringConfiguration.batch.add(message);\n    }\n}\nfunction formatError(e) {\n    if (e instanceof Error) {\n        var stackTrace = computeStackTrace(e);\n        return {\n            error: {\n                kind: stackTrace.name,\n                stack: toStackTraceString(stackTrace),\n            },\n            message: stackTrace.message,\n        };\n    }\n    return {\n        error: {\n            stack: 'Not an instance of error',\n        },\n        message: \"Uncaught \" + jsonStringify(e),\n    };\n}\nexport function setDebugMode(debugMode) {\n    monitoringConfiguration.debugMode = debugMode;\n}\nfunction logErrorIfDebug(e) {\n    if (monitoringConfiguration.debugMode) {\n        display.error('[INTERNAL ERROR]', e);\n    }\n}\nfunction logMessageIfDebug(message, context) {\n    if (monitoringConfiguration.debugMode) {\n        display.log('[MONITORING MESSAGE]', message, context);\n    }\n}\n//# sourceMappingURL=internalMonitoring.js.map"]},"metadata":{},"sourceType":"module"}