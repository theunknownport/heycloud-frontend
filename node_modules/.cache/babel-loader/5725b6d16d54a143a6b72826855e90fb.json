{"ast":null,"code":"import { monitor, addErrorToMonitoringBatch, addMonitoringMessage } from '../domain/internalMonitoring';\nvar hasReportedXhrError = false;\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nvar HttpRequest =\n/** @class */\nfunction () {\n  function HttpRequest(endpointBuilder, bytesLimit) {\n    this.endpointBuilder = endpointBuilder;\n    this.bytesLimit = bytesLimit;\n  }\n\n  HttpRequest.prototype.send = function (data, size, flushReason) {\n    var url = this.endpointBuilder.build();\n    var tryBeacon = !!navigator.sendBeacon && size < this.bytesLimit;\n\n    if (tryBeacon) {\n      try {\n        var isQueued = navigator.sendBeacon(url, data);\n\n        if (isQueued) {\n          return;\n        }\n      } catch (e) {\n        reportBeaconError(e);\n      }\n    }\n\n    var transportIntrospection = function (event) {\n      var req = event === null || event === void 0 ? void 0 : event.currentTarget;\n\n      if (req.status >= 200 && req.status < 300) {\n        return;\n      }\n\n      if (!hasReportedXhrError) {\n        hasReportedXhrError = true;\n        addMonitoringMessage('XHR fallback failed', {\n          on_line: navigator.onLine,\n          size: size,\n          url: url,\n          try_beacon: tryBeacon,\n          flush_reason: flushReason,\n          event: {\n            is_trusted: event.isTrusted,\n            total: event.total,\n            loaded: event.loaded\n          },\n          request: {\n            status: req.status,\n            ready_state: req.readyState,\n            response_text: req.responseText.slice(0, 512)\n          }\n        });\n      }\n    };\n\n    var request = new XMLHttpRequest();\n    request.addEventListener('loadend', monitor(function (event) {\n      return transportIntrospection(event);\n    }));\n    request.open('POST', url, true);\n    request.send(data);\n  };\n\n  return HttpRequest;\n}();\n\nexport { HttpRequest };\nvar hasReportedBeaconError = false;\n\nfunction reportBeaconError(e) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true;\n    addErrorToMonitoringBatch(e);\n  }\n}","map":{"version":3,"sources":["../../src/transport/httpRequest.ts"],"names":[],"mappings":"AACA,SAAS,OAAT,EAAkB,yBAAlB,EAA6C,oBAA7C,QAAyE,8BAAzE;AAEA,IAAI,mBAAmB,GAAG,KAA1B;AAEA;;;;;;;AAOG;;AACH,IAAA,WAAA;AAAA;AAAA,YAAA;AACE,WAAA,WAAA,CAAoB,eAApB,EAA8D,UAA9D,EAAgF;AAA5D,SAAA,eAAA,GAAA,eAAA;AAA0C,SAAA,UAAA,GAAA,UAAA;AAAsB;;AAEpF,EAAA,WAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,IAAL,EAA8B,IAA9B,EAA4C,WAA5C,EAAgE;AAC9D,QAAM,GAAG,GAAG,KAAK,eAAL,CAAqB,KAArB,EAAZ;AACA,QAAM,SAAS,GAAG,CAAC,CAAC,SAAS,CAAC,UAAZ,IAA0B,IAAI,GAAG,KAAK,UAAxD;;AACA,QAAI,SAAJ,EAAe;AACb,UAAI;AACF,YAAM,QAAQ,GAAG,SAAS,CAAC,UAAV,CAAqB,GAArB,EAA0B,IAA1B,CAAjB;;AACA,YAAI,QAAJ,EAAc;AACZ;AACD;AACF,OALD,CAKE,OAAO,CAAP,EAAU;AACV,QAAA,iBAAiB,CAAC,CAAD,CAAjB;AACD;AACF;;AAED,QAAM,sBAAsB,GAAG,UAAC,KAAD,EAAqB;AAClD,UAAM,GAAG,GAAG,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,aAAnB;;AACA,UAAI,GAAG,CAAC,MAAJ,IAAc,GAAd,IAAqB,GAAG,CAAC,MAAJ,GAAa,GAAtC,EAA2C;AACzC;AACD;;AACD,UAAI,CAAC,mBAAL,EAA0B;AACxB,QAAA,mBAAmB,GAAG,IAAtB;AACA,QAAA,oBAAoB,CAAC,qBAAD,EAAwB;AAC1C,UAAA,OAAO,EAAE,SAAS,CAAC,MADuB;AAE1C,UAAA,IAAI,EAAA,IAFsC;AAG1C,UAAA,GAAG,EAAA,GAHuC;AAI1C,UAAA,UAAU,EAAE,SAJ8B;AAK1C,UAAA,YAAY,EAAE,WAL4B;AAM1C,UAAA,KAAK,EAAE;AACL,YAAA,UAAU,EAAE,KAAK,CAAC,SADb;AAEL,YAAA,KAAK,EAAE,KAAK,CAAC,KAFR;AAGL,YAAA,MAAM,EAAE,KAAK,CAAC;AAHT,WANmC;AAW1C,UAAA,OAAO,EAAE;AACP,YAAA,MAAM,EAAE,GAAG,CAAC,MADL;AAEP,YAAA,WAAW,EAAE,GAAG,CAAC,UAFV;AAGP,YAAA,aAAa,EAAE,GAAG,CAAC,YAAJ,CAAiB,KAAjB,CAAuB,CAAvB,EAA0B,GAA1B;AAHR;AAXiC,SAAxB,CAApB;AAiBD;AACF,KAzBD;;AA2BA,QAAM,OAAO,GAAG,IAAI,cAAJ,EAAhB;AACA,IAAA,OAAO,CAAC,gBAAR,CACE,SADF,EAEE,OAAO,CAAC,UAAC,KAAD,EAAM;AAAK,aAAA,sBAAsB,CAAtB,KAAsB,CAAtB;AAA6B,KAAzC,CAFT;AAIA,IAAA,OAAO,CAAC,IAAR,CAAa,MAAb,EAAqB,GAArB,EAA0B,IAA1B;AACA,IAAA,OAAO,CAAC,IAAR,CAAa,IAAb;AACD,GAhDD;;AAiDF,SAAA,WAAA;AAAC,CApDD,EAAA;;;AAsDA,IAAI,sBAAsB,GAAG,KAA7B;;AACA,SAAS,iBAAT,CAA2B,CAA3B,EAAqC;AACnC,MAAI,CAAC,sBAAL,EAA6B;AAC3B,IAAA,sBAAsB,GAAG,IAAzB;AACA,IAAA,yBAAyB,CAAC,CAAD,CAAzB;AACD;AACF","sourceRoot":"","sourcesContent":["import { monitor, addErrorToMonitoringBatch, addMonitoringMessage } from '../domain/internalMonitoring';\nvar hasReportedXhrError = false;\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\nvar HttpRequest = /** @class */ (function () {\n    function HttpRequest(endpointBuilder, bytesLimit) {\n        this.endpointBuilder = endpointBuilder;\n        this.bytesLimit = bytesLimit;\n    }\n    HttpRequest.prototype.send = function (data, size, flushReason) {\n        var url = this.endpointBuilder.build();\n        var tryBeacon = !!navigator.sendBeacon && size < this.bytesLimit;\n        if (tryBeacon) {\n            try {\n                var isQueued = navigator.sendBeacon(url, data);\n                if (isQueued) {\n                    return;\n                }\n            }\n            catch (e) {\n                reportBeaconError(e);\n            }\n        }\n        var transportIntrospection = function (event) {\n            var req = event === null || event === void 0 ? void 0 : event.currentTarget;\n            if (req.status >= 200 && req.status < 300) {\n                return;\n            }\n            if (!hasReportedXhrError) {\n                hasReportedXhrError = true;\n                addMonitoringMessage('XHR fallback failed', {\n                    on_line: navigator.onLine,\n                    size: size,\n                    url: url,\n                    try_beacon: tryBeacon,\n                    flush_reason: flushReason,\n                    event: {\n                        is_trusted: event.isTrusted,\n                        total: event.total,\n                        loaded: event.loaded,\n                    },\n                    request: {\n                        status: req.status,\n                        ready_state: req.readyState,\n                        response_text: req.responseText.slice(0, 512),\n                    },\n                });\n            }\n        };\n        var request = new XMLHttpRequest();\n        request.addEventListener('loadend', monitor(function (event) { return transportIntrospection(event); }));\n        request.open('POST', url, true);\n        request.send(data);\n    };\n    return HttpRequest;\n}());\nexport { HttpRequest };\nvar hasReportedBeaconError = false;\nfunction reportBeaconError(e) {\n    if (!hasReportedBeaconError) {\n        hasReportedBeaconError = true;\n        addErrorToMonitoringBatch(e);\n    }\n}\n//# sourceMappingURL=httpRequest.js.map"]},"metadata":{},"sourceType":"module"}