{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { addMonitoringMessage, monitor } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nvar nextId = 0;\n\nvar Segment =\n/** @class */\nfunction () {\n  function Segment(worker, context, creationReason, initialRecord, onWrote, onFlushed) {\n    var _this = this;\n\n    this.worker = worker;\n    this.context = context;\n    this.creationReason = creationReason;\n    this.isFlushed = false;\n    this.id = nextId++;\n    this.start = initialRecord.timestamp;\n    this.end = initialRecord.timestamp;\n    this.recordsCount = 1;\n    this.hasFullSnapshot = initialRecord.type === RecordType.FullSnapshot;\n    var viewId = this.context.view.id;\n    replayStats.addSegment(viewId);\n    replayStats.addRecord(viewId);\n    var listener = monitor(function (_a) {\n      var data = _a.data;\n\n      if ('error' in data) {\n        return;\n      }\n\n      if (data.id === _this.id) {\n        replayStats.addWroteData(viewId, data.additionalRawSize);\n\n        if ('result' in data) {\n          onFlushed(data.result, data.rawSize);\n          worker.removeEventListener('message', listener);\n        } else {\n          onWrote(data.compressedSize);\n        }\n      } else if (data.id > _this.id) {\n        // Messages should be received in the same order as they are sent, so if we receive a\n        // message with an id superior to this Segment instance id, we know that another, more\n        // recent Segment instance is being used.\n        //\n        // In theory, a \"flush\" response should have been received at this point, so the listener\n        // should already have been removed. But if something goes wrong and we didn't receive a\n        // \"flush\" response, remove the listener to avoid any leak, and send a monitor message to\n        // help investigate the issue.\n        worker.removeEventListener('message', listener);\n        addMonitoringMessage(\"Segment did not receive a 'flush' response before being replaced.\");\n      }\n    });\n    worker.addEventListener('message', listener);\n    this.worker.postMessage({\n      data: \"{\\\"records\\\":[\" + JSON.stringify(initialRecord),\n      id: this.id,\n      action: 'write'\n    });\n  }\n\n  Segment.prototype.addRecord = function (record) {\n    this.end = record.timestamp;\n    this.recordsCount += 1;\n    replayStats.addRecord(this.context.view.id);\n    this.hasFullSnapshot || (this.hasFullSnapshot = record.type === RecordType.FullSnapshot);\n    this.worker.postMessage({\n      data: \",\" + JSON.stringify(record),\n      id: this.id,\n      action: 'write'\n    });\n  };\n\n  Segment.prototype.flush = function (reason) {\n    this.worker.postMessage({\n      data: \"],\" + JSON.stringify(this.meta).slice(1) + \"\\n\",\n      id: this.id,\n      action: 'flush'\n    });\n    this.isFlushed = true;\n    this.flushReason = reason;\n  };\n\n  Object.defineProperty(Segment.prototype, \"meta\", {\n    get: function () {\n      return __assign({\n        creation_reason: this.creationReason,\n        end: this.end,\n        has_full_snapshot: this.hasFullSnapshot,\n        records_count: this.recordsCount,\n        start: this.start\n      }, this.context);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Segment;\n}();\n\nexport { Segment };","map":{"version":3,"sources":["../../../src/domain/segmentCollection/segment.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { addMonitoringMessage, monitor } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nvar nextId = 0;\nvar Segment = /** @class */ (function () {\n    function Segment(worker, context, creationReason, initialRecord, onWrote, onFlushed) {\n        var _this = this;\n        this.worker = worker;\n        this.context = context;\n        this.creationReason = creationReason;\n        this.isFlushed = false;\n        this.id = nextId++;\n        this.start = initialRecord.timestamp;\n        this.end = initialRecord.timestamp;\n        this.recordsCount = 1;\n        this.hasFullSnapshot = initialRecord.type === RecordType.FullSnapshot;\n        var viewId = this.context.view.id;\n        replayStats.addSegment(viewId);\n        replayStats.addRecord(viewId);\n        var listener = monitor(function (_a) {\n            var data = _a.data;\n            if ('error' in data) {\n                return;\n            }\n            if (data.id === _this.id) {\n                replayStats.addWroteData(viewId, data.additionalRawSize);\n                if ('result' in data) {\n                    onFlushed(data.result, data.rawSize);\n                    worker.removeEventListener('message', listener);\n                }\n                else {\n                    onWrote(data.compressedSize);\n                }\n            }\n            else if (data.id > _this.id) {\n                // Messages should be received in the same order as they are sent, so if we receive a\n                // message with an id superior to this Segment instance id, we know that another, more\n                // recent Segment instance is being used.\n                //\n                // In theory, a \"flush\" response should have been received at this point, so the listener\n                // should already have been removed. But if something goes wrong and we didn't receive a\n                // \"flush\" response, remove the listener to avoid any leak, and send a monitor message to\n                // help investigate the issue.\n                worker.removeEventListener('message', listener);\n                addMonitoringMessage(\"Segment did not receive a 'flush' response before being replaced.\");\n            }\n        });\n        worker.addEventListener('message', listener);\n        this.worker.postMessage({ data: \"{\\\"records\\\":[\" + JSON.stringify(initialRecord), id: this.id, action: 'write' });\n    }\n    Segment.prototype.addRecord = function (record) {\n        this.end = record.timestamp;\n        this.recordsCount += 1;\n        replayStats.addRecord(this.context.view.id);\n        this.hasFullSnapshot || (this.hasFullSnapshot = record.type === RecordType.FullSnapshot);\n        this.worker.postMessage({ data: \",\" + JSON.stringify(record), id: this.id, action: 'write' });\n    };\n    Segment.prototype.flush = function (reason) {\n        this.worker.postMessage({\n            data: \"],\" + JSON.stringify(this.meta).slice(1) + \"\\n\",\n            id: this.id,\n            action: 'flush',\n        });\n        this.isFlushed = true;\n        this.flushReason = reason;\n    };\n    Object.defineProperty(Segment.prototype, \"meta\", {\n        get: function () {\n            return __assign({ creation_reason: this.creationReason, end: this.end, has_full_snapshot: this.hasFullSnapshot, records_count: this.recordsCount, start: this.start }, this.context);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Segment;\n}());\nexport { Segment };\n//# sourceMappingURL=segment.js.map"]},"metadata":{},"sourceType":"module"}