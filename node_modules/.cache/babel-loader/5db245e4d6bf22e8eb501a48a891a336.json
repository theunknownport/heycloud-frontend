{"ast":null,"code":"import { monitor, noop } from '@datadog/browser-core';\nimport { getMutationObserverConstructor } from '@datadog/browser-rum-core';\nimport { NodePrivacyLevel } from '../../constants';\nimport { getNodePrivacyLevel, getTextContent } from './privacy';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode } from './serializationUtils';\nimport { serializeNodeWithId, serializeAttribute } from './serialize';\nimport { forEach } from './utils';\nimport { createMutationBatch } from './mutationBatch';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\n\nexport function startMutationObserver(controller, mutationCallback, defaultPrivacyLevel) {\n  var MutationObserver = getMutationObserverConstructor();\n\n  if (!MutationObserver) {\n    return {\n      stop: noop\n    };\n  }\n\n  var mutationBatch = createMutationBatch(function (mutations) {\n    processMutations(mutations.concat(observer.takeRecords()), mutationCallback, defaultPrivacyLevel);\n  });\n  var observer = new MutationObserver(monitor(mutationBatch.addMutations));\n  observer.observe(document, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  controller.onFlush(mutationBatch.flush);\n  return {\n    stop: function () {\n      observer.disconnect();\n      mutationBatch.stop();\n    }\n  };\n}\n/**\n * Controls how mutations are processed, allowing to flush pending mutations.\n */\n\nvar MutationController =\n/** @class */\nfunction () {\n  function MutationController() {}\n\n  MutationController.prototype.flush = function () {\n    var _a;\n\n    (_a = this.flushListener) === null || _a === void 0 ? void 0 : _a.call(this);\n  };\n\n  MutationController.prototype.onFlush = function (listener) {\n    this.flushListener = listener;\n  };\n\n  return MutationController;\n}();\n\nexport { MutationController };\n\nfunction processMutations(mutations, mutationCallback, defaultPrivacyLevel) {\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  var filteredMutations = mutations.filter(function (mutation) {\n    return document.contains(mutation.target) && nodeAndAncestorsHaveSerializedNode(mutation.target) && getNodePrivacyLevel(mutation.target, defaultPrivacyLevel) !== NodePrivacyLevel.HIDDEN;\n  });\n\n  var _a = processChildListMutations(filteredMutations.filter(function (mutation) {\n    return mutation.type === 'childList';\n  }), defaultPrivacyLevel),\n      adds = _a.adds,\n      removes = _a.removes,\n      hasBeenSerialized = _a.hasBeenSerialized;\n\n  var texts = processCharacterDataMutations(filteredMutations.filter(function (mutation) {\n    return mutation.type === 'characterData' && !hasBeenSerialized(mutation.target);\n  }), defaultPrivacyLevel);\n  var attributes = processAttributesMutations(filteredMutations.filter(function (mutation) {\n    return mutation.type === 'attributes' && !hasBeenSerialized(mutation.target);\n  }), defaultPrivacyLevel);\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return;\n  }\n\n  mutationCallback({\n    adds: adds,\n    removes: removes,\n    texts: texts,\n    attributes: attributes\n  });\n}\n\nfunction processChildListMutations(mutations, defaultPrivacyLevel) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  var addedAndMovedNodes = new Set();\n  var removedNodes = new Map();\n\n  var _loop_1 = function (mutation) {\n    forEach(mutation.addedNodes, function (node) {\n      addedAndMovedNodes.add(node);\n    });\n    forEach(mutation.removedNodes, function (node) {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target);\n      }\n\n      addedAndMovedNodes.delete(node);\n    });\n  };\n\n  for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n    var mutation = mutations_1[_i];\n\n    _loop_1(mutation);\n  } // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n\n\n  var sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes); // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n\n  var serializedNodeIds = new Set();\n  var addedNodeMutations = [];\n\n  for (var _a = 0, sortedAddedAndMovedNodes_1 = sortedAddedAndMovedNodes; _a < sortedAddedAndMovedNodes_1.length; _a++) {\n    var node = sortedAddedAndMovedNodes_1[_a];\n\n    if (hasBeenSerialized(node)) {\n      continue;\n    }\n\n    var parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, defaultPrivacyLevel);\n\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue;\n    }\n\n    var serializedNode = serializeNodeWithId(node, {\n      document: document,\n      serializedNodeIds: serializedNodeIds,\n      parentNodePrivacyLevel: parentNodePrivacyLevel\n    });\n\n    if (!serializedNode) {\n      continue;\n    }\n\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(node.parentNode),\n      node: serializedNode\n    });\n  } // Finally, we emit remove mutations.\n\n\n  var removedNodeMutations = [];\n  removedNodes.forEach(function (parent, node) {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node)\n      });\n    }\n  });\n  return {\n    adds: addedNodeMutations,\n    removes: removedNodeMutations,\n    hasBeenSerialized: hasBeenSerialized\n  };\n\n  function hasBeenSerialized(node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node));\n  }\n\n  function getNextSibling(node) {\n    var nextSibling = node.nextSibling;\n\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling);\n      }\n\n      nextSibling = nextSibling.nextSibling;\n    }\n\n    return null;\n  }\n}\n\nfunction processCharacterDataMutations(mutations, defaultPrivacyLevel) {\n  var _a;\n\n  var textMutations = []; // Deduplicate mutations based on their target node\n\n  var handledNodes = new Set();\n  var filteredMutations = mutations.filter(function (mutation) {\n    if (handledNodes.has(mutation.target)) {\n      return false;\n    }\n\n    handledNodes.add(mutation.target);\n    return true;\n  }); // Emit mutations\n\n  for (var _i = 0, filteredMutations_1 = filteredMutations; _i < filteredMutations_1.length; _i++) {\n    var mutation = filteredMutations_1[_i];\n    var value = mutation.target.textContent;\n\n    if (value === mutation.oldValue) {\n      continue;\n    }\n\n    var parentNodePrivacyLevel = getNodePrivacyLevel(mutation.target.parentNode, defaultPrivacyLevel);\n\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue;\n    }\n\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null\n    });\n  }\n\n  return textMutations;\n}\n\nfunction processAttributesMutations(mutations, defaultPrivacyLevel) {\n  var attributeMutations = []; // Deduplicate mutations based on their target node and changed attribute\n\n  var handledElements = new Map();\n  var filteredMutations = mutations.filter(function (mutation) {\n    var handledAttributes = handledElements.get(mutation.target);\n\n    if (handledAttributes === null || handledAttributes === void 0 ? void 0 : handledAttributes.has(mutation.attributeName)) {\n      return false;\n    }\n\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName]));\n    } else {\n      handledAttributes.add(mutation.attributeName);\n    }\n\n    return true;\n  }); // Emit mutations\n\n  var emittedMutations = new Map();\n\n  for (var _i = 0, filteredMutations_2 = filteredMutations; _i < filteredMutations_2.length; _i++) {\n    var mutation = filteredMutations_2[_i];\n    var uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n\n    if (uncensoredValue === mutation.oldValue) {\n      continue;\n    }\n\n    var privacyLevel = getNodePrivacyLevel(mutation.target, defaultPrivacyLevel);\n    var attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName);\n    var transformedValue = void 0;\n\n    if (mutation.attributeName === 'value') {\n      var inputValue = getElementInputValue(mutation.target, privacyLevel);\n\n      if (inputValue === undefined) {\n        continue;\n      }\n\n      transformedValue = inputValue;\n    } else if (attributeValue && typeof attributeValue === 'string') {\n      transformedValue = attributeValue;\n    } else {\n      transformedValue = null;\n    }\n\n    var emittedMutation = emittedMutations.get(mutation.target);\n\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {}\n      };\n      attributeMutations.push(emittedMutation);\n      emittedMutations.set(mutation.target, emittedMutation);\n    }\n\n    emittedMutation.attributes[mutation.attributeName] = transformedValue;\n  }\n\n  return attributeMutations;\n}\n\nexport function sortAddedAndMovedNodes(nodes) {\n  nodes.sort(function (a, b) {\n    var position = a.compareDocumentPosition(b);\n    /* eslint-disable no-bitwise */\n\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1;\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1;\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1;\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1;\n    }\n    /* eslint-enable no-bitwise */\n\n\n    return 0;\n  });\n}","map":{"version":3,"sources":["../../../src/domain/record/mutationObserver.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { monitor, noop } from '@datadog/browser-core';\nimport { getMutationObserverConstructor } from '@datadog/browser-rum-core';\nimport { NodePrivacyLevel } from '../../constants';\nimport { getNodePrivacyLevel, getTextContent } from './privacy';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode, } from './serializationUtils';\nimport { serializeNodeWithId, serializeAttribute } from './serialize';\nimport { forEach } from './utils';\nimport { createMutationBatch } from './mutationBatch';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function startMutationObserver(controller, mutationCallback, defaultPrivacyLevel) {\n    var MutationObserver = getMutationObserverConstructor();\n    if (!MutationObserver) {\n        return { stop: noop };\n    }\n    var mutationBatch = createMutationBatch(function (mutations) {\n        processMutations(mutations.concat(observer.takeRecords()), mutationCallback, defaultPrivacyLevel);\n    });\n    var observer = new MutationObserver(monitor(mutationBatch.addMutations));\n    observer.observe(document, {\n        attributeOldValue: true,\n        attributes: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true,\n    });\n    controller.onFlush(mutationBatch.flush);\n    return {\n        stop: function () {\n            observer.disconnect();\n            mutationBatch.stop();\n        },\n    };\n}\n/**\n * Controls how mutations are processed, allowing to flush pending mutations.\n */\nvar MutationController = /** @class */ (function () {\n    function MutationController() {\n    }\n    MutationController.prototype.flush = function () {\n        var _a;\n        (_a = this.flushListener) === null || _a === void 0 ? void 0 : _a.call(this);\n    };\n    MutationController.prototype.onFlush = function (listener) {\n        this.flushListener = listener;\n    };\n    return MutationController;\n}());\nexport { MutationController };\nfunction processMutations(mutations, mutationCallback, defaultPrivacyLevel) {\n    // Discard any mutation with a 'target' node that:\n    // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n    // part of a mutation occurring in a parent Node\n    // * should be hidden or ignored\n    var filteredMutations = mutations.filter(function (mutation) {\n        return document.contains(mutation.target) &&\n            nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n            getNodePrivacyLevel(mutation.target, defaultPrivacyLevel) !== NodePrivacyLevel.HIDDEN;\n    });\n    var _a = processChildListMutations(filteredMutations.filter(function (mutation) { return mutation.type === 'childList'; }), defaultPrivacyLevel), adds = _a.adds, removes = _a.removes, hasBeenSerialized = _a.hasBeenSerialized;\n    var texts = processCharacterDataMutations(filteredMutations.filter(function (mutation) {\n        return mutation.type === 'characterData' && !hasBeenSerialized(mutation.target);\n    }), defaultPrivacyLevel);\n    var attributes = processAttributesMutations(filteredMutations.filter(function (mutation) {\n        return mutation.type === 'attributes' && !hasBeenSerialized(mutation.target);\n    }), defaultPrivacyLevel);\n    if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n        return;\n    }\n    mutationCallback({\n        adds: adds,\n        removes: removes,\n        texts: texts,\n        attributes: attributes,\n    });\n}\nfunction processChildListMutations(mutations, defaultPrivacyLevel) {\n    // First, we iterate over mutations to collect:\n    //\n    // * nodes that have been added in the document and not removed by a subsequent mutation\n    // * nodes that have been removed from the document but were not added in a previous mutation\n    //\n    // For this second category, we also collect their previous parent (mutation.target) because we'll\n    // need it to emit a 'remove' mutation.\n    //\n    // Those two categories may overlap: if a node moved from a position to another, it is reported as\n    // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n    // the node will be in both sets.\n    var addedAndMovedNodes = new Set();\n    var removedNodes = new Map();\n    var _loop_1 = function (mutation) {\n        forEach(mutation.addedNodes, function (node) {\n            addedAndMovedNodes.add(node);\n        });\n        forEach(mutation.removedNodes, function (node) {\n            if (!addedAndMovedNodes.has(node)) {\n                removedNodes.set(node, mutation.target);\n            }\n            addedAndMovedNodes.delete(node);\n        });\n    };\n    for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n        var mutation = mutations_1[_i];\n        _loop_1(mutation);\n    }\n    // Then, we sort nodes that are still in the document by topological order, for two reasons:\n    //\n    // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n    // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n    // a precedent node.\n    //\n    // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n    // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n    // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n    // already serialized and have an id.\n    var sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n    sortAddedAndMovedNodes(sortedAddedAndMovedNodes);\n    // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n    // node ids in a set to be able to skip subsequent related mutations.\n    var serializedNodeIds = new Set();\n    var addedNodeMutations = [];\n    for (var _a = 0, sortedAddedAndMovedNodes_1 = sortedAddedAndMovedNodes; _a < sortedAddedAndMovedNodes_1.length; _a++) {\n        var node = sortedAddedAndMovedNodes_1[_a];\n        if (hasBeenSerialized(node)) {\n            continue;\n        }\n        var parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, defaultPrivacyLevel);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        var serializedNode = serializeNodeWithId(node, {\n            document: document,\n            serializedNodeIds: serializedNodeIds,\n            parentNodePrivacyLevel: parentNodePrivacyLevel,\n        });\n        if (!serializedNode) {\n            continue;\n        }\n        addedNodeMutations.push({\n            nextId: getNextSibling(node),\n            parentId: getSerializedNodeId(node.parentNode),\n            node: serializedNode,\n        });\n    }\n    // Finally, we emit remove mutations.\n    var removedNodeMutations = [];\n    removedNodes.forEach(function (parent, node) {\n        if (hasSerializedNode(node)) {\n            removedNodeMutations.push({\n                parentId: getSerializedNodeId(parent),\n                id: getSerializedNodeId(node),\n            });\n        }\n    });\n    return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized: hasBeenSerialized };\n    function hasBeenSerialized(node) {\n        return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node));\n    }\n    function getNextSibling(node) {\n        var nextSibling = node.nextSibling;\n        while (nextSibling) {\n            if (hasSerializedNode(nextSibling)) {\n                return getSerializedNodeId(nextSibling);\n            }\n            nextSibling = nextSibling.nextSibling;\n        }\n        return null;\n    }\n}\nfunction processCharacterDataMutations(mutations, defaultPrivacyLevel) {\n    var _a;\n    var textMutations = [];\n    // Deduplicate mutations based on their target node\n    var handledNodes = new Set();\n    var filteredMutations = mutations.filter(function (mutation) {\n        if (handledNodes.has(mutation.target)) {\n            return false;\n        }\n        handledNodes.add(mutation.target);\n        return true;\n    });\n    // Emit mutations\n    for (var _i = 0, filteredMutations_1 = filteredMutations; _i < filteredMutations_1.length; _i++) {\n        var mutation = filteredMutations_1[_i];\n        var value = mutation.target.textContent;\n        if (value === mutation.oldValue) {\n            continue;\n        }\n        var parentNodePrivacyLevel = getNodePrivacyLevel(mutation.target.parentNode, defaultPrivacyLevel);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        textMutations.push({\n            id: getSerializedNodeId(mutation.target),\n            // TODO: pass a valid \"ignoreWhiteSpace\" argument\n            value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null,\n        });\n    }\n    return textMutations;\n}\nfunction processAttributesMutations(mutations, defaultPrivacyLevel) {\n    var attributeMutations = [];\n    // Deduplicate mutations based on their target node and changed attribute\n    var handledElements = new Map();\n    var filteredMutations = mutations.filter(function (mutation) {\n        var handledAttributes = handledElements.get(mutation.target);\n        if (handledAttributes === null || handledAttributes === void 0 ? void 0 : handledAttributes.has(mutation.attributeName)) {\n            return false;\n        }\n        if (!handledAttributes) {\n            handledElements.set(mutation.target, new Set([mutation.attributeName]));\n        }\n        else {\n            handledAttributes.add(mutation.attributeName);\n        }\n        return true;\n    });\n    // Emit mutations\n    var emittedMutations = new Map();\n    for (var _i = 0, filteredMutations_2 = filteredMutations; _i < filteredMutations_2.length; _i++) {\n        var mutation = filteredMutations_2[_i];\n        var uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n        if (uncensoredValue === mutation.oldValue) {\n            continue;\n        }\n        var privacyLevel = getNodePrivacyLevel(mutation.target, defaultPrivacyLevel);\n        var attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName);\n        var transformedValue = void 0;\n        if (mutation.attributeName === 'value') {\n            var inputValue = getElementInputValue(mutation.target, privacyLevel);\n            if (inputValue === undefined) {\n                continue;\n            }\n            transformedValue = inputValue;\n        }\n        else if (attributeValue && typeof attributeValue === 'string') {\n            transformedValue = attributeValue;\n        }\n        else {\n            transformedValue = null;\n        }\n        var emittedMutation = emittedMutations.get(mutation.target);\n        if (!emittedMutation) {\n            emittedMutation = {\n                id: getSerializedNodeId(mutation.target),\n                attributes: {},\n            };\n            attributeMutations.push(emittedMutation);\n            emittedMutations.set(mutation.target, emittedMutation);\n        }\n        emittedMutation.attributes[mutation.attributeName] = transformedValue;\n    }\n    return attributeMutations;\n}\nexport function sortAddedAndMovedNodes(nodes) {\n    nodes.sort(function (a, b) {\n        var position = a.compareDocumentPosition(b);\n        /* eslint-disable no-bitwise */\n        if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return -1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n            return -1;\n        }\n        /* eslint-enable no-bitwise */\n        return 0;\n    });\n}\n//# sourceMappingURL=mutationObserver.js.map"]},"metadata":{},"sourceType":"module"}