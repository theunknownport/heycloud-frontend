{"ast":null,"code":"import { Point, Segment } from '../../geometry';\nimport { last, round } from '../../util';\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\nvar X = \"x\";\nvar Y = \"y\";\nexport function pointsToCurve(pointsIn, closed) {\n  var points = pointsIn.slice(0);\n  var segments = [];\n  var length = points.length;\n\n  if (length > 2) {\n    removeDuplicates(0, points);\n    length = points.length;\n  }\n\n  if (length < 2 || length === 2 && points[0].equals(points[1])) {\n    return segments;\n  }\n\n  var p0 = points[0];\n  var p1 = points[1];\n  var p2 = points[2];\n  segments.push(new Segment(p0));\n\n  while (p0.equals(points[length - 1])) {\n    closed = true;\n    points.pop();\n    length--;\n  }\n\n  if (length === 2) {\n    var tangent = getTangent(p0, p1, X, Y);\n    last(segments).controlOut(firstControlPoint(tangent, p0, p1, X, Y));\n    segments.push(new Segment(p1, secondControlPoint(tangent, p0, p1, X, Y)));\n    return segments;\n  }\n\n  var initialControlPoint, lastControlPoint;\n\n  if (closed) {\n    p0 = points[length - 1];\n    p1 = points[0];\n    p2 = points[1];\n    var controlPoints = getControlPoints(p0, p1, p2);\n    initialControlPoint = controlPoints[1];\n    lastControlPoint = controlPoints[0];\n  } else {\n    var tangent$1 = getTangent(p0, p1, X, Y);\n    initialControlPoint = firstControlPoint(tangent$1, p0, p1, X, Y);\n  }\n\n  var cp0 = initialControlPoint;\n\n  for (var idx = 0; idx <= length - 3; idx++) {\n    removeDuplicates(idx, points);\n    length = points.length;\n\n    if (idx + 3 <= length) {\n      p0 = points[idx];\n      p1 = points[idx + 1];\n      p2 = points[idx + 2];\n      var controlPoints$1 = getControlPoints(p0, p1, p2);\n      last(segments).controlOut(cp0);\n      cp0 = controlPoints$1[1];\n      var cp1 = controlPoints$1[0];\n      segments.push(new Segment(p1, cp1));\n    }\n  }\n\n  if (closed) {\n    p0 = points[length - 2];\n    p1 = points[length - 1];\n    p2 = points[0];\n    var controlPoints$2 = getControlPoints(p0, p1, p2);\n    last(segments).controlOut(cp0);\n    segments.push(new Segment(p1, controlPoints$2[0]));\n    last(segments).controlOut(controlPoints$2[1]);\n    segments.push(new Segment(p2, lastControlPoint));\n  } else {\n    var tangent$2 = getTangent(p1, p2, X, Y);\n    last(segments).controlOut(cp0);\n    segments.push(new Segment(p2, secondControlPoint(tangent$2, p1, p2, X, Y)));\n  }\n\n  return segments;\n}\nexport function pointsToClosedCurve(pointsIn) {\n  return pointsToCurve(pointsIn, true);\n}\nexport function removeDuplicates(idx, points) {\n  while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n    points.splice(idx + 1, 1);\n  }\n}\nexport function invertAxis(p0, p1, p2) {\n  var invertAxis = false;\n\n  if (p0.x === p1.x) {\n    invertAxis = true;\n  } else if (p1.x === p2.x) {\n    if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n      invertAxis = true;\n    }\n  } else {\n    var fn = lineFunction(p0, p1);\n    var y2 = calculateFunction(fn, p2.x);\n\n    if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n      invertAxis = true;\n    }\n  }\n\n  return invertAxis;\n}\nexport function isLine(p0, p1, p2) {\n  var fn = lineFunction(p0, p1);\n  var y2 = calculateFunction(fn, p2.x);\n  return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n}\nexport function lineFunction(p1, p2) {\n  var a = (p2.y - p1.y) / (p2.x - p1.x);\n  var b = p1.y - a * p1.x;\n  return [b, a];\n}\nexport function getControlPoints(p0, p1, p2) {\n  var xField = X;\n  var yField = Y;\n  var restrict = false;\n  var switchOrientation = false;\n  var tangent;\n\n  if (isLine(p0, p1, p2)) {\n    tangent = getTangent(p0, p1, X, Y);\n  } else {\n    var monotonic = {\n      x: isMonotonicByField(p0, p1, p2, X),\n      y: isMonotonicByField(p0, p1, p2, Y)\n    };\n\n    if (monotonic.x && monotonic.y) {\n      tangent = getTangent(p0, p2, X, Y);\n      restrict = true;\n    } else {\n      if (invertAxis(p0, p1, p2)) {\n        xField = Y;\n        yField = X;\n      }\n\n      if (monotonic[xField]) {\n        tangent = 0;\n      } else {\n        var sign;\n\n        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n          sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n        } else {\n          sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n        }\n\n        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n        switchOrientation = true;\n      }\n    }\n  }\n\n  var secondCP = secondControlPoint(tangent, p0, p1, xField, yField);\n\n  if (switchOrientation) {\n    var oldXField = xField;\n    xField = yField;\n    yField = oldXField;\n  }\n\n  var firstCP = firstControlPoint(tangent, p1, p2, xField, yField);\n\n  if (restrict) {\n    restrictControlPoint(p0, p1, secondCP, tangent);\n    restrictControlPoint(p1, p2, firstCP, tangent);\n  }\n\n  return [secondCP, firstCP];\n}\nexport function restrictControlPoint(p1, p2, cp, tangent) {\n  if (p1.y < p2.y) {\n    if (p2.y < cp.y) {\n      cp.x = p1.x + (p2.y - p1.y) / tangent;\n      cp.y = p2.y;\n    } else if (cp.y < p1.y) {\n      cp.x = p2.x - (p2.y - p1.y) / tangent;\n      cp.y = p1.y;\n    }\n  } else {\n    if (cp.y < p2.y) {\n      cp.x = p1.x - (p1.y - p2.y) / tangent;\n      cp.y = p2.y;\n    } else if (p1.y < cp.y) {\n      cp.x = p2.x + (p1.y - p2.y) / tangent;\n      cp.y = p1.y;\n    }\n  }\n}\nexport function getTangent(p0, p1, xField, yField) {\n  var x = p1[xField] - p0[xField];\n  var y = p1[yField] - p0[yField];\n  var tangent;\n\n  if (x === 0) {\n    tangent = 0;\n  } else {\n    tangent = y / x;\n  }\n\n  return tangent;\n}\nexport function isMonotonicByField(p0, p1, p2, field) {\n  return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n}\nexport function firstControlPoint(tangent, p0, p3, xField, yField) {\n  var t1 = p0[xField];\n  var t2 = p3[xField];\n  var distance = (t2 - t1) * WEIGHT;\n  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n}\nexport function secondControlPoint(tangent, p0, p3, xField, yField) {\n  var t1 = p0[xField];\n  var t2 = p3[xField];\n  var distance = (t2 - t1) * WEIGHT;\n  return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n}\nexport function point(xValue, yValue, xField, yField) {\n  var controlPoint = new Point();\n  controlPoint[xField] = xValue;\n  controlPoint[yField] = yValue;\n  return controlPoint;\n}\nexport function calculateFunction(fn, x) {\n  var length = fn.length;\n  var result = 0;\n\n  for (var i = 0; i < length; i++) {\n    result += Math.pow(x, i) * fn[i];\n  }\n\n  return result;\n}\nexport function numberSign(value) {\n  return value <= 0 ? -1 : 1;\n}","map":{"version":3,"sources":["C:/Projects/React/heycloud-frontent-2/node_modules/@progress/kendo-drawing/dist/es/shapes/utils/points-to-curve.js"],"names":["Point","Segment","last","round","WEIGHT","EXTREMUM_ALLOWED_DEVIATION","X","Y","pointsToCurve","pointsIn","closed","points","slice","segments","length","removeDuplicates","equals","p0","p1","p2","push","pop","tangent","getTangent","controlOut","firstControlPoint","secondControlPoint","initialControlPoint","lastControlPoint","controlPoints","getControlPoints","tangent$1","cp0","idx","controlPoints$1","cp1","controlPoints$2","tangent$2","pointsToClosedCurve","splice","invertAxis","x","y","fn","lineFunction","y2","calculateFunction","isLine","a","b","xField","yField","restrict","switchOrientation","monotonic","isMonotonicByField","sign","numberSign","secondCP","oldXField","firstCP","restrictControlPoint","cp","field","p3","t1","t2","distance","point","xValue","yValue","controlPoint","result","i","Math","pow","value"],"mappings":"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","sourcesContent":["import { Point, Segment } from '../../geometry';\nimport { last, round } from '../../util';\n\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\nvar X = \"x\";\nvar Y = \"y\";\n\nexport function pointsToCurve(pointsIn, closed) {\n    var points = pointsIn.slice(0);\n    var segments = [];\n    var length = points.length;\n\n    if (length > 2) {\n        removeDuplicates(0, points);\n        length = points.length;\n    }\n\n    if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n        return segments;\n    }\n\n    var p0 = points[0];\n    var p1 = points[1];\n    var p2 = points[2];\n\n    segments.push(new Segment(p0));\n\n    while (p0.equals(points[length - 1])) {\n        closed = true;\n        points.pop();\n        length--;\n    }\n\n    if (length === 2) {\n        var tangent = getTangent(p0,p1, X, Y);\n\n        last(segments).controlOut(\n            firstControlPoint(tangent, p0, p1, X, Y)\n        );\n\n        segments.push(new Segment(\n            p1,\n            secondControlPoint(tangent, p0, p1, X, Y)\n        ));\n\n        return segments;\n    }\n\n    var initialControlPoint, lastControlPoint;\n\n    if (closed) {\n        p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n        var controlPoints = getControlPoints(p0, p1, p2);\n        initialControlPoint = controlPoints[1];\n        lastControlPoint = controlPoints[0];\n    } else {\n        var tangent$1 = getTangent(p0, p1, X,Y);\n        initialControlPoint = firstControlPoint(tangent$1, p0, p1, X, Y);\n    }\n\n    var cp0 = initialControlPoint;\n    for (var idx = 0; idx <= length - 3; idx++) {\n        removeDuplicates(idx, points);\n        length = points.length;\n        if (idx + 3 <= length) {\n            p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n            var controlPoints$1 = getControlPoints(p0,p1,p2);\n\n            last(segments).controlOut(cp0);\n            cp0 = controlPoints$1[1];\n\n            var cp1 = controlPoints$1[0];\n            segments.push(new Segment(p1, cp1));\n        }\n    }\n\n    if (closed) {\n        p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n        var controlPoints$2 = getControlPoints(p0, p1, p2);\n\n        last(segments).controlOut(cp0);\n        segments.push(new Segment(\n            p1,\n            controlPoints$2[0]\n        ));\n\n        last(segments).controlOut(controlPoints$2[1]);\n        segments.push(new Segment(\n            p2,\n            lastControlPoint\n        ));\n    } else {\n        var tangent$2 = getTangent(p1, p2, X, Y);\n\n        last(segments).controlOut(cp0);\n        segments.push(new Segment(\n            p2,\n            secondControlPoint(tangent$2, p1, p2, X, Y)\n        ));\n    }\n\n    return segments;\n}\n\nexport function pointsToClosedCurve(pointsIn) {\n    return pointsToCurve(pointsIn, true);\n}\n\nexport function removeDuplicates(idx, points) {\n    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n        points.splice(idx + 1, 1);\n    }\n}\n\nexport function invertAxis(p0, p1, p2) {\n    var invertAxis = false;\n\n    if (p0.x === p1.x) {\n        invertAxis = true;\n    } else if (p1.x === p2.x) {\n        if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n            invertAxis = true;\n        }\n    } else {\n        var fn = lineFunction(p0,p1);\n        var y2 = calculateFunction(fn, p2.x);\n        if (!(p0.y <= p1.y && p2.y <= y2) &&\n            !(p1.y <= p0.y && p2.y >= y2)) {\n            invertAxis = true;\n        }\n    }\n\n    return invertAxis;\n}\n\nexport function isLine(p0, p1, p2) {\n    var fn = lineFunction(p0, p1);\n    var y2 = calculateFunction(fn, p2.x);\n\n    return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n}\n\nexport function lineFunction(p1, p2) {\n    var a = (p2.y - p1.y) / (p2.x - p1.x);\n    var b = p1.y - a * p1.x;\n\n    return [ b, a ];\n}\n\nexport function getControlPoints(p0, p1, p2) {\n    var xField = X;\n    var yField = Y;\n    var restrict = false;\n    var switchOrientation = false;\n    var tangent;\n\n    if (isLine(p0, p1, p2)) {\n        tangent = getTangent(p0, p1, X, Y);\n    } else {\n        var monotonic = {\n            x: isMonotonicByField(p0, p1, p2, X),\n            y: isMonotonicByField(p0, p1, p2, Y)\n        };\n\n        if (monotonic.x && monotonic.y) {\n            tangent = getTangent(p0, p2, X, Y);\n            restrict = true;\n        } else {\n            if (invertAxis(p0, p1, p2)) {\n                xField = Y;\n                yField = X;\n            }\n\n            if (monotonic[xField]) {\n                tangent = 0;\n            } else {\n                var sign;\n                if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                    (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                    sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                } else {\n                    sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                }\n\n                tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                switchOrientation = true;\n            }\n        }\n    }\n\n    var secondCP = secondControlPoint(tangent, p0, p1, xField, yField);\n\n    if (switchOrientation) {\n        var oldXField = xField;\n        xField = yField;\n        yField = oldXField;\n    }\n\n    var firstCP = firstControlPoint(tangent, p1, p2, xField, yField);\n\n    if (restrict) {\n        restrictControlPoint(p0, p1, secondCP, tangent);\n        restrictControlPoint(p1, p2, firstCP, tangent);\n    }\n\n    return [ secondCP, firstCP ];\n}\n\nexport function restrictControlPoint(p1, p2, cp, tangent) {\n    if (p1.y < p2.y) {\n        if (p2.y < cp.y) {\n            cp.x = p1.x + (p2.y - p1.y) / tangent;\n            cp.y = p2.y;\n        } else if (cp.y < p1.y) {\n            cp.x = p2.x - (p2.y - p1.y) / tangent;\n            cp.y = p1.y;\n        }\n    } else {\n        if (cp.y < p2.y) {\n            cp.x = p1.x - (p1.y - p2.y) / tangent;\n            cp.y = p2.y;\n        } else if (p1.y < cp.y) {\n            cp.x = p2.x + (p1.y - p2.y) / tangent;\n            cp.y = p1.y;\n        }\n    }\n}\n\nexport function getTangent(p0, p1, xField, yField) {\n    var x = p1[xField] - p0[xField];\n    var y = p1[yField] - p0[yField];\n    var tangent;\n\n    if (x === 0) {\n        tangent = 0;\n    } else {\n        tangent = y / x;\n    }\n\n    return tangent;\n}\n\nexport function isMonotonicByField(p0, p1, p2, field) {\n    return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                (p2[field] < p1[field] && p1[field] < p0[field]);\n}\n\nexport function firstControlPoint(tangent, p0, p3, xField, yField) {\n    var t1 = p0[xField];\n    var t2 = p3[xField];\n    var distance = (t2 - t1) * WEIGHT;\n\n    return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n}\n\nexport function secondControlPoint(tangent, p0, p3, xField, yField) {\n    var t1 = p0[xField];\n    var t2 = p3[xField];\n    var distance = (t2 - t1) * WEIGHT;\n\n    return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n}\n\nexport function point(xValue, yValue, xField, yField) {\n    var controlPoint = new Point();\n    controlPoint[xField] = xValue;\n    controlPoint[yField] = yValue;\n\n    return controlPoint;\n}\n\nexport function calculateFunction(fn, x) {\n    var length = fn.length;\n    var result = 0;\n\n    for (var i = 0; i < length; i++) {\n        result += Math.pow(x,i) * fn[i];\n    }\n    return result;\n}\n\nexport function numberSign(value) {\n    return value <= 0 ? -1 : 1;\n}\n"]},"metadata":{},"sourceType":"module"}