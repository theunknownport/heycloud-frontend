{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { monitor } from '../domain/internalMonitoring';\nimport { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod';\nimport { Observable } from '../tools/observable';\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/timeUtils';\nimport { normalizeUrl } from '../tools/urlPolyfill';\nvar xhrObservable;\nexport function initXhrObservable() {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable();\n  }\n\n  return xhrObservable;\n}\n\nfunction createXhrObservable() {\n  var observable = new Observable(function () {\n    var stopInstrumentingStart = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr\n    }).stop;\n    var stopInstrumentingSend = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before: function () {\n        sendXhr.call(this, observable);\n      }\n    }).stop;\n    var stopInstrumentingAbort = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr\n    }).stop;\n    return function () {\n      stopInstrumentingStart();\n      stopInstrumentingSend();\n      stopInstrumentingAbort();\n    };\n  });\n  return observable;\n}\n\nfunction openXhr(method, url) {\n  // WARN: since this data structure is tied to the instance, it is shared by both logs and rum\n  // and can be used by different code versions depending on customer setup\n  // so it should stay compatible with older versions\n  this._datadog_xhr = {\n    state: 'open',\n    method: method,\n    url: normalizeUrl(url)\n  };\n}\n\nfunction sendXhr(observable) {\n  var _this = this;\n\n  if (!this._datadog_xhr) {\n    return;\n  }\n\n  var startContext = this._datadog_xhr;\n  startContext.state = 'start';\n  startContext.startTime = relativeNow();\n  startContext.startClocks = clocksNow();\n  startContext.isAborted = false;\n  startContext.xhr = this;\n  var hasBeenReported = false;\n  var stopInstrumentingOnReadyStateChange = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before: function () {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd();\n      }\n    }\n  }).stop;\n  var onEnd = monitor(function () {\n    _this.removeEventListener('loadend', onEnd);\n\n    stopInstrumentingOnReadyStateChange();\n\n    if (hasBeenReported) {\n      return;\n    }\n\n    hasBeenReported = true;\n    var completeContext = _this._datadog_xhr;\n    completeContext.state = 'complete';\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());\n    completeContext.responseText = _this.response;\n    completeContext.status = _this.status;\n    observable.notify(__assign({}, completeContext));\n  });\n  this.addEventListener('loadend', onEnd);\n  observable.notify(startContext);\n}\n\nfunction abortXhr() {\n  if (this._datadog_xhr) {\n    this._datadog_xhr.isAborted = true;\n  }\n}","map":{"version":3,"sources":["../../src/browser/xhrObservable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { monitor } from '../domain/internalMonitoring';\nimport { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod';\nimport { Observable } from '../tools/observable';\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/timeUtils';\nimport { normalizeUrl } from '../tools/urlPolyfill';\nvar xhrObservable;\nexport function initXhrObservable() {\n    if (!xhrObservable) {\n        xhrObservable = createXhrObservable();\n    }\n    return xhrObservable;\n}\nfunction createXhrObservable() {\n    var observable = new Observable(function () {\n        var stopInstrumentingStart = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n            before: openXhr,\n        }).stop;\n        var stopInstrumentingSend = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n            before: function () {\n                sendXhr.call(this, observable);\n            },\n        }).stop;\n        var stopInstrumentingAbort = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n            before: abortXhr,\n        }).stop;\n        return function () {\n            stopInstrumentingStart();\n            stopInstrumentingSend();\n            stopInstrumentingAbort();\n        };\n    });\n    return observable;\n}\nfunction openXhr(method, url) {\n    // WARN: since this data structure is tied to the instance, it is shared by both logs and rum\n    // and can be used by different code versions depending on customer setup\n    // so it should stay compatible with older versions\n    this._datadog_xhr = {\n        state: 'open',\n        method: method,\n        url: normalizeUrl(url),\n    };\n}\nfunction sendXhr(observable) {\n    var _this = this;\n    if (!this._datadog_xhr) {\n        return;\n    }\n    var startContext = this._datadog_xhr;\n    startContext.state = 'start';\n    startContext.startTime = relativeNow();\n    startContext.startClocks = clocksNow();\n    startContext.isAborted = false;\n    startContext.xhr = this;\n    var hasBeenReported = false;\n    var stopInstrumentingOnReadyStateChange = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n        before: function () {\n            if (this.readyState === XMLHttpRequest.DONE) {\n                // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n                // application during a future event. For example, Angular is calling .abort() on\n                // completed requests during a onreadystatechange event, so the status becomes '0'\n                // before the request is collected.\n                onEnd();\n            }\n        },\n    }).stop;\n    var onEnd = monitor(function () {\n        _this.removeEventListener('loadend', onEnd);\n        stopInstrumentingOnReadyStateChange();\n        if (hasBeenReported) {\n            return;\n        }\n        hasBeenReported = true;\n        var completeContext = _this._datadog_xhr;\n        completeContext.state = 'complete';\n        completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());\n        completeContext.responseText = _this.response;\n        completeContext.status = _this.status;\n        observable.notify(__assign({}, completeContext));\n    });\n    this.addEventListener('loadend', onEnd);\n    observable.notify(startContext);\n}\nfunction abortXhr() {\n    if (this._datadog_xhr) {\n        this._datadog_xhr.isAborted = true;\n    }\n}\n//# sourceMappingURL=xhrObservable.js.map"]},"metadata":{},"sourceType":"module"}