{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { addEventListeners, elapsed, ONE_MINUTE } from '@datadog/browser-core';\nimport { LifeCycleEventType } from '../../lifeCycle';\nimport { trackFirstHidden } from './trackFirstHidden'; // Discard LCP and FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\n\nexport var TIMING_MAXIMUM_DELAY = 10 * ONE_MINUTE;\nexport function trackInitialViewTimings(lifeCycle, callback) {\n  var timings;\n\n  function setTimings(newTimings) {\n    timings = __assign(__assign({}, timings), newTimings);\n    callback(timings);\n  }\n\n  var stopNavigationTracking = trackNavigationTimings(lifeCycle, setTimings).stop;\n  var stopFCPTracking = trackFirstContentfulPaintTiming(lifeCycle, function (firstContentfulPaint) {\n    return setTimings({\n      firstContentfulPaint: firstContentfulPaint\n    });\n  }).stop;\n  var stopLCPTracking = trackLargestContentfulPaintTiming(lifeCycle, window, function (largestContentfulPaint) {\n    setTimings({\n      largestContentfulPaint: largestContentfulPaint\n    });\n  }, function (lcpDiscardReason) {\n    setTimings({\n      lcpDiscardReason: lcpDiscardReason\n    });\n  }).stop;\n  var stopFIDTracking = trackFirstInputTimings(lifeCycle, function (_a) {\n    var firstInputDelay = _a.firstInputDelay,\n        firstInputTime = _a.firstInputTime;\n    setTimings({\n      firstInputDelay: firstInputDelay,\n      firstInputTime: firstInputTime\n    });\n  }).stop;\n  return {\n    stop: function () {\n      stopNavigationTracking();\n      stopFCPTracking();\n      stopLCPTracking();\n      stopFIDTracking();\n    }\n  };\n}\nexport function trackNavigationTimings(lifeCycle, callback) {\n  var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n    if (entry.entryType === 'navigation') {\n      callback({\n        domComplete: entry.domComplete,\n        domContentLoaded: entry.domContentLoadedEventEnd,\n        domInteractive: entry.domInteractive,\n        loadEvent: entry.loadEventEnd\n      });\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}\nexport function trackFirstContentfulPaintTiming(lifeCycle, callback) {\n  var firstHidden = trackFirstHidden();\n  var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n    if (entry.entryType === 'paint' && entry.name === 'first-contentful-paint' && entry.startTime < firstHidden.timeStamp && entry.startTime < TIMING_MAXIMUM_DELAY) {\n      callback(entry.startTime);\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts\n */\n\nexport function trackLargestContentfulPaintTiming(lifeCycle, emitter, callback, discardCallback) {\n  var firstHidden = trackFirstHidden(); // Ignore entries that come after the first user interaction.  According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n\n  var firstInteractionTimestamp = Infinity;\n  var stopEventListener = addEventListeners(emitter, [\"pointerdown\"\n  /* POINTER_DOWN */\n  , \"keydown\"\n  /* KEY_DOWN */\n  ], function (event) {\n    firstInteractionTimestamp = event.timeStamp;\n  }, {\n    capture: true,\n    once: true\n  }).stop;\n  var isFirstLCP = true;\n  var unsubscribeLifeCycle = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n    if (entry.entryType !== 'largest-contentful-paint') {\n      return;\n    }\n\n    if (entry.startTime < firstInteractionTimestamp && entry.startTime < firstHidden.timeStamp && entry.startTime < TIMING_MAXIMUM_DELAY) {\n      callback(entry.startTime);\n    } else if (isFirstLCP) {\n      var reason = entry.startTime >= firstInteractionTimestamp ? 'interaction' : entry.startTime >= firstHidden.timeStamp ? 'hidden' : entry.startTime >= TIMING_MAXIMUM_DELAY ? 'maximum delay' : 'N/A';\n      discardCallback(reason);\n    }\n\n    isFirstLCP = false;\n  }).unsubscribe;\n  return {\n    stop: function () {\n      stopEventListener();\n      unsubscribeLifeCycle();\n    }\n  };\n}\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\n\nexport function trackFirstInputTimings(lifeCycle, callback) {\n  var firstHidden = trackFirstHidden();\n  var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n    if (entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp) {\n      var firstInputDelay = elapsed(entry.startTime, entry.processingStart);\n      callback({\n        // Ensure firstInputDelay to be positive, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n        firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : 0,\n        firstInputTime: entry.startTime\n      });\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}","map":{"version":3,"sources":["../../../../src/domain/rumEventsCollection/view/trackInitialViewTimings.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { addEventListeners, elapsed, ONE_MINUTE, } from '@datadog/browser-core';\nimport { LifeCycleEventType } from '../../lifeCycle';\nimport { trackFirstHidden } from './trackFirstHidden';\n// Discard LCP and FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport var TIMING_MAXIMUM_DELAY = 10 * ONE_MINUTE;\nexport function trackInitialViewTimings(lifeCycle, callback) {\n    var timings;\n    function setTimings(newTimings) {\n        timings = __assign(__assign({}, timings), newTimings);\n        callback(timings);\n    }\n    var stopNavigationTracking = trackNavigationTimings(lifeCycle, setTimings).stop;\n    var stopFCPTracking = trackFirstContentfulPaintTiming(lifeCycle, function (firstContentfulPaint) {\n        return setTimings({ firstContentfulPaint: firstContentfulPaint });\n    }).stop;\n    var stopLCPTracking = trackLargestContentfulPaintTiming(lifeCycle, window, function (largestContentfulPaint) {\n        setTimings({\n            largestContentfulPaint: largestContentfulPaint,\n        });\n    }, function (lcpDiscardReason) {\n        setTimings({\n            lcpDiscardReason: lcpDiscardReason,\n        });\n    }).stop;\n    var stopFIDTracking = trackFirstInputTimings(lifeCycle, function (_a) {\n        var firstInputDelay = _a.firstInputDelay, firstInputTime = _a.firstInputTime;\n        setTimings({\n            firstInputDelay: firstInputDelay,\n            firstInputTime: firstInputTime,\n        });\n    }).stop;\n    return {\n        stop: function () {\n            stopNavigationTracking();\n            stopFCPTracking();\n            stopLCPTracking();\n            stopFIDTracking();\n        },\n    };\n}\nexport function trackNavigationTimings(lifeCycle, callback) {\n    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n        if (entry.entryType === 'navigation') {\n            callback({\n                domComplete: entry.domComplete,\n                domContentLoaded: entry.domContentLoadedEventEnd,\n                domInteractive: entry.domInteractive,\n                loadEvent: entry.loadEventEnd,\n            });\n        }\n    }).unsubscribe;\n    return { stop: stop };\n}\nexport function trackFirstContentfulPaintTiming(lifeCycle, callback) {\n    var firstHidden = trackFirstHidden();\n    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n        if (entry.entryType === 'paint' &&\n            entry.name === 'first-contentful-paint' &&\n            entry.startTime < firstHidden.timeStamp &&\n            entry.startTime < TIMING_MAXIMUM_DELAY) {\n            callback(entry.startTime);\n        }\n    }).unsubscribe;\n    return { stop: stop };\n}\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts\n */\nexport function trackLargestContentfulPaintTiming(lifeCycle, emitter, callback, discardCallback) {\n    var firstHidden = trackFirstHidden();\n    // Ignore entries that come after the first user interaction.  According to the documentation, the\n    // browser should not send largest-contentful-paint entries after a user interact with the page,\n    // but the web-vitals reference implementation uses this as a safeguard.\n    var firstInteractionTimestamp = Infinity;\n    var stopEventListener = addEventListeners(emitter, [\"pointerdown\" /* POINTER_DOWN */, \"keydown\" /* KEY_DOWN */], function (event) {\n        firstInteractionTimestamp = event.timeStamp;\n    }, { capture: true, once: true }).stop;\n    var isFirstLCP = true;\n    var unsubscribeLifeCycle = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n        if (entry.entryType !== 'largest-contentful-paint') {\n            return;\n        }\n        if (entry.startTime < firstInteractionTimestamp &&\n            entry.startTime < firstHidden.timeStamp &&\n            entry.startTime < TIMING_MAXIMUM_DELAY) {\n            callback(entry.startTime);\n        }\n        else if (isFirstLCP) {\n            var reason = entry.startTime >= firstInteractionTimestamp\n                ? 'interaction'\n                : entry.startTime >= firstHidden.timeStamp\n                    ? 'hidden'\n                    : entry.startTime >= TIMING_MAXIMUM_DELAY\n                        ? 'maximum delay'\n                        : 'N/A';\n            discardCallback(reason);\n        }\n        isFirstLCP = false;\n    }).unsubscribe;\n    return {\n        stop: function () {\n            stopEventListener();\n            unsubscribeLifeCycle();\n        },\n    };\n}\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInputTimings(lifeCycle, callback) {\n    var firstHidden = trackFirstHidden();\n    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n        if (entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp) {\n            var firstInputDelay = elapsed(entry.startTime, entry.processingStart);\n            callback({\n                // Ensure firstInputDelay to be positive, see\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n                firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : 0,\n                firstInputTime: entry.startTime,\n            });\n        }\n    }).unsubscribe;\n    return {\n        stop: stop,\n    };\n}\n//# sourceMappingURL=trackInitialViewTimings.js.map"]},"metadata":{},"sourceType":"module"}