{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { display } from '../tools/display';\nimport { addEventListener, jsonStringify, noop, objectValues } from '../tools/utils';\nimport { monitor } from '../domain/internalMonitoring'; // https://en.wikipedia.org/wiki/UTF-8\n\nvar HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/;\n\nvar Batch =\n/** @class */\nfunction () {\n  function Batch(request, maxSize, bytesLimit, maxMessageSize, flushTimeout, beforeUnloadCallback) {\n    if (beforeUnloadCallback === void 0) {\n      beforeUnloadCallback = noop;\n    }\n\n    this.request = request;\n    this.maxSize = maxSize;\n    this.bytesLimit = bytesLimit;\n    this.maxMessageSize = maxMessageSize;\n    this.flushTimeout = flushTimeout;\n    this.beforeUnloadCallback = beforeUnloadCallback;\n    this.pushOnlyBuffer = [];\n    this.upsertBuffer = {};\n    this.bufferBytesSize = 0;\n    this.bufferMessageCount = 0;\n    this.flushOnVisibilityHidden();\n    this.flushPeriodically();\n  }\n\n  Batch.prototype.add = function (message) {\n    this.addOrUpdate(message);\n  };\n\n  Batch.prototype.upsert = function (message, key) {\n    this.addOrUpdate(message, key);\n  };\n\n  Batch.prototype.flush = function (reason) {\n    if (this.bufferMessageCount !== 0) {\n      var messages = __spreadArrays(this.pushOnlyBuffer, objectValues(this.upsertBuffer));\n\n      this.request.send(messages.join('\\n'), this.bufferBytesSize, reason);\n      this.pushOnlyBuffer = [];\n      this.upsertBuffer = {};\n      this.bufferBytesSize = 0;\n      this.bufferMessageCount = 0;\n    }\n  };\n\n  Batch.prototype.sizeInBytes = function (candidate) {\n    // Accurate byte size computations can degrade performances when there is a lot of events to process\n    if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n      return candidate.length;\n    }\n\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(candidate).length;\n    }\n\n    return new Blob([candidate]).size;\n  };\n\n  Batch.prototype.addOrUpdate = function (message, key) {\n    var _a = this.process(message),\n        processedMessage = _a.processedMessage,\n        messageBytesSize = _a.messageBytesSize;\n\n    if (messageBytesSize >= this.maxMessageSize) {\n      display.warn(\"Discarded a message whose size was bigger than the maximum allowed size \" + this.maxMessageSize + \"KB.\");\n      return;\n    }\n\n    if (this.hasMessageFor(key)) {\n      this.remove(key);\n    }\n\n    if (this.willReachedBytesLimitWith(messageBytesSize)) {\n      this.flush('willReachedBytesLimitWith');\n    }\n\n    this.push(processedMessage, messageBytesSize, key);\n\n    if (this.isFull()) {\n      this.flush('isFull');\n    }\n  };\n\n  Batch.prototype.process = function (message) {\n    var processedMessage = jsonStringify(message);\n    var messageBytesSize = this.sizeInBytes(processedMessage);\n    return {\n      processedMessage: processedMessage,\n      messageBytesSize: messageBytesSize\n    };\n  };\n\n  Batch.prototype.push = function (processedMessage, messageBytesSize, key) {\n    if (this.bufferMessageCount > 0) {\n      // \\n separator at serialization\n      this.bufferBytesSize += 1;\n    }\n\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage;\n    } else {\n      this.pushOnlyBuffer.push(processedMessage);\n    }\n\n    this.bufferBytesSize += messageBytesSize;\n    this.bufferMessageCount += 1;\n  };\n\n  Batch.prototype.remove = function (key) {\n    var removedMessage = this.upsertBuffer[key];\n    delete this.upsertBuffer[key];\n    var messageBytesSize = this.sizeInBytes(removedMessage);\n    this.bufferBytesSize -= messageBytesSize;\n    this.bufferMessageCount -= 1;\n\n    if (this.bufferMessageCount > 0) {\n      this.bufferBytesSize -= 1;\n    }\n  };\n\n  Batch.prototype.hasMessageFor = function (key) {\n    return key !== undefined && this.upsertBuffer[key] !== undefined;\n  };\n\n  Batch.prototype.willReachedBytesLimitWith = function (messageBytesSize) {\n    // byte of the separator at the end of the message\n    return this.bufferBytesSize + messageBytesSize + 1 >= this.bytesLimit;\n  };\n\n  Batch.prototype.isFull = function () {\n    return this.bufferMessageCount === this.maxSize || this.bufferBytesSize >= this.bytesLimit;\n  };\n\n  Batch.prototype.flushPeriodically = function () {\n    var _this = this;\n\n    setTimeout(monitor(function () {\n      _this.flush('flushPeriodically');\n\n      _this.flushPeriodically();\n    }), this.flushTimeout);\n  };\n\n  Batch.prototype.flushOnVisibilityHidden = function () {\n    var _this = this;\n    /**\n     * With sendBeacon, requests are guaranteed to be successfully sent during document unload\n     */\n    // @ts-ignore this function is not always defined\n\n\n    if (navigator.sendBeacon) {\n      /**\n       * beforeunload is called before visibilitychange\n       * register first to be sure to be called before flush on beforeunload\n       * caveat: unload can still be canceled by another listener\n       */\n      addEventListener(window, \"beforeunload\"\n      /* BEFORE_UNLOAD */\n      , this.beforeUnloadCallback);\n      /**\n       * Only event that guarantee to fire on mobile devices when the page transitions to background state\n       * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n       */\n\n      addEventListener(document, \"visibilitychange\"\n      /* VISIBILITY_CHANGE */\n      , function () {\n        if (document.visibilityState === 'hidden') {\n          _this.flush(\"visibilitychange\"\n          /* VISIBILITY_CHANGE */\n          );\n        }\n      });\n      /**\n       * Safari does not support yet to send a request during:\n       * - a visibility change during doc unload (cf: https://bugs.webkit.org/show_bug.cgi?id=194897)\n       * - a page hide transition (cf: https://bugs.webkit.org/show_bug.cgi?id=188329)\n       */\n\n      addEventListener(window, \"beforeunload\"\n      /* BEFORE_UNLOAD */\n      , function () {\n        return _this.flush(\"beforeunload\"\n        /* BEFORE_UNLOAD */\n        );\n      });\n    }\n  };\n\n  return Batch;\n}();\n\nexport { Batch };","map":{"version":3,"sources":["../../src/transport/batch.ts"],"names":[],"mappings":";AAAA,SAAS,OAAT,QAAwB,kBAAxB;AAEA,SAAS,gBAAT,EAAsC,aAAtC,EAAqD,IAArD,EAA2D,YAA3D,QAA+E,gBAA/E;AACA,SAAS,OAAT,QAAwB,8BAAxB,C,CAGA;;AACA,IAAM,0BAA0B,GAAG,kBAAnC;;AAEA,IAAA,KAAA;AAAA;AAAA,YAAA;AAME,WAAA,KAAA,CACU,OADV,EAEU,OAFV,EAGU,UAHV,EAIU,cAJV,EAKU,YALV,EAMU,oBANV,EAMiD;AAAvC,QAAA,oBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,oBAAA,GAAA,IAAA;AAAuC;;AALvC,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,oBAAA,GAAA,oBAAA;AAXF,SAAA,cAAA,GAA2B,EAA3B;AACA,SAAA,YAAA,GAA0C,EAA1C;AACA,SAAA,eAAA,GAAkB,CAAlB;AACA,SAAA,kBAAA,GAAqB,CAArB;AAUN,SAAK,uBAAL;AACA,SAAK,iBAAL;AACD;;AAED,EAAA,KAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,OAAJ,EAAoB;AAClB,SAAK,WAAL,CAAiB,OAAjB;AACD,GAFD;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,OAAP,EAAyB,GAAzB,EAAoC;AAClC,SAAK,WAAL,CAAiB,OAAjB,EAA0B,GAA1B;AACD,GAFD;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,MAAN,EAAqB;AACnB,QAAI,KAAK,kBAAL,KAA4B,CAAhC,EAAmC;AACjC,UAAM,QAAQ,GAAA,cAAA,CAAO,KAAK,cAAZ,EAA+B,YAAY,CAAC,KAAK,YAAN,CAA3C,CAAd;;AACA,WAAK,OAAL,CAAa,IAAb,CAAkB,QAAQ,CAAC,IAAT,CAAc,IAAd,CAAlB,EAAuC,KAAK,eAA5C,EAA6D,MAA7D;AACA,WAAK,cAAL,GAAsB,EAAtB;AACA,WAAK,YAAL,GAAoB,EAApB;AACA,WAAK,eAAL,GAAuB,CAAvB;AACA,WAAK,kBAAL,GAA0B,CAA1B;AACD;AACF,GATD;;AAWA,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,SAAZ,EAA6B;AAC3B;AACA,QAAI,CAAC,0BAA0B,CAAC,IAA3B,CAAgC,SAAhC,CAAL,EAAiD;AAC/C,aAAO,SAAS,CAAC,MAAjB;AACD;;AAED,QAAI,MAAM,CAAC,WAAP,KAAuB,SAA3B,EAAsC;AACpC,aAAO,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,SAAzB,EAAoC,MAA3C;AACD;;AAED,WAAO,IAAI,IAAJ,CAAS,CAAC,SAAD,CAAT,EAAsB,IAA7B;AACD,GAXD;;AAaQ,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,OAApB,EAAsC,GAAtC,EAAkD;AAC1C,QAAA,EAAA,GAAyC,KAAK,OAAL,CAAa,OAAb,CAAzC;AAAA,QAAE,gBAAgB,GAAA,EAAA,CAAA,gBAAlB;AAAA,QAAoB,gBAAgB,GAAA,EAAA,CAAA,gBAApC;;AACN,QAAI,gBAAgB,IAAI,KAAK,cAA7B,EAA6C;AAC3C,MAAA,OAAO,CAAC,IAAR,CAAa,6EAA2E,KAAK,cAAhF,GAA8F,KAA3G;AACA;AACD;;AACD,QAAI,KAAK,aAAL,CAAmB,GAAnB,CAAJ,EAA6B;AAC3B,WAAK,MAAL,CAAY,GAAZ;AACD;;AACD,QAAI,KAAK,yBAAL,CAA+B,gBAA/B,CAAJ,EAAsD;AACpD,WAAK,KAAL,CAAW,2BAAX;AACD;;AACD,SAAK,IAAL,CAAU,gBAAV,EAA4B,gBAA5B,EAA8C,GAA9C;;AACA,QAAI,KAAK,MAAL,EAAJ,EAAmB;AACjB,WAAK,KAAL,CAAW,QAAX;AACD;AACF,GAhBO;;AAkBA,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAR,UAAgB,OAAhB,EAAgC;AAC9B,QAAM,gBAAgB,GAAG,aAAa,CAAC,OAAD,CAAtC;AACA,QAAM,gBAAgB,GAAG,KAAK,WAAL,CAAiB,gBAAjB,CAAzB;AACA,WAAO;AAAE,MAAA,gBAAgB,EAAA,gBAAlB;AAAoB,MAAA,gBAAgB,EAAA;AAApC,KAAP;AACD,GAJO;;AAMA,EAAA,KAAA,CAAA,SAAA,CAAA,IAAA,GAAR,UAAa,gBAAb,EAAuC,gBAAvC,EAAiE,GAAjE,EAA6E;AAC3E,QAAI,KAAK,kBAAL,GAA0B,CAA9B,EAAiC;AAC/B;AACA,WAAK,eAAL,IAAwB,CAAxB;AACD;;AACD,QAAI,GAAG,KAAK,SAAZ,EAAuB;AACrB,WAAK,YAAL,CAAkB,GAAlB,IAAyB,gBAAzB;AACD,KAFD,MAEO;AACL,WAAK,cAAL,CAAoB,IAApB,CAAyB,gBAAzB;AACD;;AACD,SAAK,eAAL,IAAwB,gBAAxB;AACA,SAAK,kBAAL,IAA2B,CAA3B;AACD,GAZO;;AAcA,EAAA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAR,UAAe,GAAf,EAA0B;AACxB,QAAM,cAAc,GAAG,KAAK,YAAL,CAAkB,GAAlB,CAAvB;AACA,WAAO,KAAK,YAAL,CAAkB,GAAlB,CAAP;AACA,QAAM,gBAAgB,GAAG,KAAK,WAAL,CAAiB,cAAjB,CAAzB;AACA,SAAK,eAAL,IAAwB,gBAAxB;AACA,SAAK,kBAAL,IAA2B,CAA3B;;AACA,QAAI,KAAK,kBAAL,GAA0B,CAA9B,EAAiC;AAC/B,WAAK,eAAL,IAAwB,CAAxB;AACD;AACF,GATO;;AAWA,EAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,GAAtB,EAAkC;AAChC,WAAO,GAAG,KAAK,SAAR,IAAqB,KAAK,YAAL,CAAkB,GAAlB,MAA2B,SAAvD;AACD,GAFO;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,gBAAlC,EAA0D;AACxD;AACA,WAAO,KAAK,eAAL,GAAuB,gBAAvB,GAA0C,CAA1C,IAA+C,KAAK,UAA3D;AACD,GAHO;;AAKA,EAAA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAR,YAAA;AACE,WAAO,KAAK,kBAAL,KAA4B,KAAK,OAAjC,IAA4C,KAAK,eAAL,IAAwB,KAAK,UAAhF;AACD,GAFO;;AAIA,EAAA,KAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,IAAA,UAAU,CACR,OAAO,CAAC,YAAA;AACN,MAAA,KAAI,CAAC,KAAL,CAAW,mBAAX;;AACA,MAAA,KAAI,CAAC,iBAAL;AACD,KAHM,CADC,EAKR,KAAK,YALG,CAAV;AAOD,GARO;;AAUA,EAAA,KAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;AACE;;AAEG;AACH;;;AACA,QAAI,SAAS,CAAC,UAAd,EAA0B;AACxB;;;;AAIG;AACH,MAAA,gBAAgB,CAAC,MAAD,EAAO;AAAA;AAAP,QAAkC,KAAK,oBAAvC,CAAhB;AAEA;;;AAGG;;AACH,MAAA,gBAAgB,CAAC,QAAD,EAAS;AAAA;AAAT,QAAwC,YAAA;AACtD,YAAI,QAAQ,CAAC,eAAT,KAA6B,QAAjC,EAA2C;AACzC,UAAA,KAAI,CAAC,KAAL,CAAU;AAAA;AAAV;AACD;AACF,OAJe,CAAhB;AAKA;;;;AAIG;;AACH,MAAA,gBAAgB,CAAC,MAAD,EAAO;AAAA;AAAP,QAAkC,YAAA;AAAM,eAAA,KAAI,CAAC,KAAL,CAAU;AAAV;AAAA,SAAA;AAAmC,OAA3E,CAAhB;AACD;AACF,GA7BO;;AA8BV,SAAA,KAAA;AAAC,CAxJD,EAAA","sourceRoot":"","sourcesContent":["import { __spreadArrays } from \"tslib\";\nimport { display } from '../tools/display';\nimport { addEventListener, jsonStringify, noop, objectValues } from '../tools/utils';\nimport { monitor } from '../domain/internalMonitoring';\n// https://en.wikipedia.org/wiki/UTF-8\nvar HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/;\nvar Batch = /** @class */ (function () {\n    function Batch(request, maxSize, bytesLimit, maxMessageSize, flushTimeout, beforeUnloadCallback) {\n        if (beforeUnloadCallback === void 0) { beforeUnloadCallback = noop; }\n        this.request = request;\n        this.maxSize = maxSize;\n        this.bytesLimit = bytesLimit;\n        this.maxMessageSize = maxMessageSize;\n        this.flushTimeout = flushTimeout;\n        this.beforeUnloadCallback = beforeUnloadCallback;\n        this.pushOnlyBuffer = [];\n        this.upsertBuffer = {};\n        this.bufferBytesSize = 0;\n        this.bufferMessageCount = 0;\n        this.flushOnVisibilityHidden();\n        this.flushPeriodically();\n    }\n    Batch.prototype.add = function (message) {\n        this.addOrUpdate(message);\n    };\n    Batch.prototype.upsert = function (message, key) {\n        this.addOrUpdate(message, key);\n    };\n    Batch.prototype.flush = function (reason) {\n        if (this.bufferMessageCount !== 0) {\n            var messages = __spreadArrays(this.pushOnlyBuffer, objectValues(this.upsertBuffer));\n            this.request.send(messages.join('\\n'), this.bufferBytesSize, reason);\n            this.pushOnlyBuffer = [];\n            this.upsertBuffer = {};\n            this.bufferBytesSize = 0;\n            this.bufferMessageCount = 0;\n        }\n    };\n    Batch.prototype.sizeInBytes = function (candidate) {\n        // Accurate byte size computations can degrade performances when there is a lot of events to process\n        if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n            return candidate.length;\n        }\n        if (window.TextEncoder !== undefined) {\n            return new TextEncoder().encode(candidate).length;\n        }\n        return new Blob([candidate]).size;\n    };\n    Batch.prototype.addOrUpdate = function (message, key) {\n        var _a = this.process(message), processedMessage = _a.processedMessage, messageBytesSize = _a.messageBytesSize;\n        if (messageBytesSize >= this.maxMessageSize) {\n            display.warn(\"Discarded a message whose size was bigger than the maximum allowed size \" + this.maxMessageSize + \"KB.\");\n            return;\n        }\n        if (this.hasMessageFor(key)) {\n            this.remove(key);\n        }\n        if (this.willReachedBytesLimitWith(messageBytesSize)) {\n            this.flush('willReachedBytesLimitWith');\n        }\n        this.push(processedMessage, messageBytesSize, key);\n        if (this.isFull()) {\n            this.flush('isFull');\n        }\n    };\n    Batch.prototype.process = function (message) {\n        var processedMessage = jsonStringify(message);\n        var messageBytesSize = this.sizeInBytes(processedMessage);\n        return { processedMessage: processedMessage, messageBytesSize: messageBytesSize };\n    };\n    Batch.prototype.push = function (processedMessage, messageBytesSize, key) {\n        if (this.bufferMessageCount > 0) {\n            // \\n separator at serialization\n            this.bufferBytesSize += 1;\n        }\n        if (key !== undefined) {\n            this.upsertBuffer[key] = processedMessage;\n        }\n        else {\n            this.pushOnlyBuffer.push(processedMessage);\n        }\n        this.bufferBytesSize += messageBytesSize;\n        this.bufferMessageCount += 1;\n    };\n    Batch.prototype.remove = function (key) {\n        var removedMessage = this.upsertBuffer[key];\n        delete this.upsertBuffer[key];\n        var messageBytesSize = this.sizeInBytes(removedMessage);\n        this.bufferBytesSize -= messageBytesSize;\n        this.bufferMessageCount -= 1;\n        if (this.bufferMessageCount > 0) {\n            this.bufferBytesSize -= 1;\n        }\n    };\n    Batch.prototype.hasMessageFor = function (key) {\n        return key !== undefined && this.upsertBuffer[key] !== undefined;\n    };\n    Batch.prototype.willReachedBytesLimitWith = function (messageBytesSize) {\n        // byte of the separator at the end of the message\n        return this.bufferBytesSize + messageBytesSize + 1 >= this.bytesLimit;\n    };\n    Batch.prototype.isFull = function () {\n        return this.bufferMessageCount === this.maxSize || this.bufferBytesSize >= this.bytesLimit;\n    };\n    Batch.prototype.flushPeriodically = function () {\n        var _this = this;\n        setTimeout(monitor(function () {\n            _this.flush('flushPeriodically');\n            _this.flushPeriodically();\n        }), this.flushTimeout);\n    };\n    Batch.prototype.flushOnVisibilityHidden = function () {\n        var _this = this;\n        /**\n         * With sendBeacon, requests are guaranteed to be successfully sent during document unload\n         */\n        // @ts-ignore this function is not always defined\n        if (navigator.sendBeacon) {\n            /**\n             * beforeunload is called before visibilitychange\n             * register first to be sure to be called before flush on beforeunload\n             * caveat: unload can still be canceled by another listener\n             */\n            addEventListener(window, \"beforeunload\" /* BEFORE_UNLOAD */, this.beforeUnloadCallback);\n            /**\n             * Only event that guarantee to fire on mobile devices when the page transitions to background state\n             * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n             */\n            addEventListener(document, \"visibilitychange\" /* VISIBILITY_CHANGE */, function () {\n                if (document.visibilityState === 'hidden') {\n                    _this.flush(\"visibilitychange\" /* VISIBILITY_CHANGE */);\n                }\n            });\n            /**\n             * Safari does not support yet to send a request during:\n             * - a visibility change during doc unload (cf: https://bugs.webkit.org/show_bug.cgi?id=194897)\n             * - a page hide transition (cf: https://bugs.webkit.org/show_bug.cgi?id=188329)\n             */\n            addEventListener(window, \"beforeunload\" /* BEFORE_UNLOAD */, function () { return _this.flush(\"beforeunload\" /* BEFORE_UNLOAD */); });\n        }\n    };\n    return Batch;\n}());\nexport { Batch };\n//# sourceMappingURL=batch.js.map"]},"metadata":{},"sourceType":"module"}