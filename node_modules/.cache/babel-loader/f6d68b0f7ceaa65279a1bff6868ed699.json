{"ast":null,"code":"import { report } from './report';\nvar UNKNOWN_FUNCTION = '?';\n/**\n * computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n * ```js\n * s = computeStackTraceOfCaller([depth])\n * s = computeStackTrace(exception) // consider using report instead (see below)\n * ```\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with report,\n * which builds on top of computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n * Tracing example:\n * ```js\n *     function trace(message) {\n *         let stackInfo = computeStackTrace.ofCaller();\n *         let data = message + \"\\n\";\n *         for(let i in stackInfo.stack) {\n *             let item = stackInfo.stack[i];\n *             data += (item.func || '[anonymous]') + \"() in \" + item.url + \":\" + (item.line || '0') + \"\\n\";\n *         }\n *         if (window.console)\n *             console.info(data);\n *         else\n *             alert(data);\n *     }\n * ```\n * @memberof TraceKit\n * @namespace\n */\n\n/**\n * Computes a stack trace for an exception.\n * @param {Error} ex\n * @param {(string|number)=} depth\n * @memberof computeStackTrace\n */\n\nexport function computeStackTrace(ex, depth) {\n  var stack;\n  var normalizedDepth = depth === undefined ? 0 : +depth;\n\n  try {\n    // This must be tried first because Opera 10 *destroys*\n    // its stacktrace property if you try to access the stack\n    // property first!!\n    stack = computeStackTraceFromStacktraceProp(ex);\n\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromStackProp(ex);\n\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromOperaMultiLineMessage(ex);\n\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceByWalkingCallerChain(ex, normalizedDepth + 1);\n\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack: []\n  };\n}\nvar debug = false; // Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.columnNumber = 69\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?StackTrace} Stack trace information.\n * @memberof computeStackTrace\n */\n\nexport function computeStackTraceFromStackProp(ex) {\n  var stacktrace = tryToGetString(ex, 'stack');\n\n  if (!stacktrace) {\n    return;\n  } // eslint-disable-next-line  max-len\n\n\n  var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i; // eslint-disable-next-line  max-len\n\n  var gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i; // eslint-disable-next-line  max-len\n\n  var winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i; // Used to additionally parse URL/line/column from eval frames\n\n  var isEval;\n  var geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n  var chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n  var lines = stacktrace.split('\\n');\n  var stack = [];\n  var submatch;\n  var parts;\n  var element;\n\n  for (var i = 0, j = lines.length; i < j; i += 1) {\n    if (chrome.exec(lines[i])) {\n      parts = chrome.exec(lines[i]);\n      var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n      isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n      submatch = chromeEval.exec(parts[2]);\n\n      if (isEval && submatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = submatch[1]; // url\n\n        parts[3] = submatch[2]; // line\n\n        parts[4] = submatch[3]; // column\n      }\n\n      element = {\n        args: isNative ? [parts[2]] : [],\n        column: parts[4] ? +parts[4] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: parts[3] ? +parts[3] : undefined,\n        url: !isNative ? parts[2] : undefined\n      };\n    } else if (winjs.exec(lines[i])) {\n      parts = winjs.exec(lines[i]);\n      element = {\n        args: [],\n        column: parts[4] ? +parts[4] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: +parts[3],\n        url: parts[2]\n      };\n    } else if (gecko.exec(lines[i])) {\n      parts = gecko.exec(lines[i]);\n      isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n      submatch = geckoEval.exec(parts[3]);\n\n      if (isEval && submatch) {\n        // throw out eval line/column and use top-most line number\n        parts[3] = submatch[1];\n        parts[4] = submatch[2];\n        parts[5] = undefined; // no column when eval\n      } else if (i === 0 && !parts[5] && !isUndefined(ex.columnNumber)) {\n        // FireFox uses this awesome columnNumber property for its top frame\n        // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n        // so adding 1\n        // NOTE: this hack doesn't work if top-most frame is eval\n        stack[0].column = ex.columnNumber + 1;\n      }\n\n      element = {\n        args: parts[2] ? parts[2].split(',') : [],\n        column: parts[5] ? +parts[5] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: parts[4] ? +parts[4] : undefined,\n        url: parts[3]\n      };\n    } else {\n      continue;\n    }\n\n    if (!element.func && element.line) {\n      element.func = UNKNOWN_FUNCTION;\n    }\n\n    stack.push(element);\n  }\n\n  if (!stack.length) {\n    return;\n  }\n\n  return {\n    stack: stack,\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name')\n  };\n}\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10+ uses this property.\n * @param {Error} ex\n * @return {?StackTrace} Stack trace information.\n * @memberof computeStackTrace\n */\n\nfunction computeStackTraceFromStacktraceProp(ex) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = tryToGetString(ex, 'stacktrace');\n\n  if (!stacktrace) {\n    return;\n  }\n\n  var opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i; // eslint-disable-next-line  max-len\n\n  var opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i;\n  var lines = stacktrace.split('\\n');\n  var stack = [];\n  var parts;\n\n  for (var line = 0; line < lines.length; line += 2) {\n    var element = void 0;\n\n    if (opera10Regex.exec(lines[line])) {\n      parts = opera10Regex.exec(lines[line]);\n      element = {\n        args: [],\n        column: undefined,\n        func: parts[3],\n        line: +parts[1],\n        url: parts[2]\n      };\n    } else if (opera11Regex.exec(lines[line])) {\n      parts = opera11Regex.exec(lines[line]);\n      element = {\n        args: parts[5] ? parts[5].split(',') : [],\n        column: +parts[2],\n        func: parts[3] || parts[4],\n        line: +parts[1],\n        url: parts[6]\n      };\n    }\n\n    if (element) {\n      if (!element.func && element.line) {\n        element.func = UNKNOWN_FUNCTION;\n      }\n\n      element.context = [lines[line + 1]];\n      stack.push(element);\n    }\n  }\n\n  if (!stack.length) {\n    return;\n  }\n\n  return {\n    stack: stack,\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name')\n  };\n}\n/**\n * NOT TESTED.\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?StackTrace} Stack information.\n * @memberof computeStackTrace\n */\n\n\nfunction computeStackTraceFromOperaMultiLineMessage(ex) {\n  // TODO: Clean this function up\n  // Opera includes a stack trace into the exception message. An example is:\n  //\n  // Statement on line 3: Undefined variable: undefinedFunc\n  // Backtrace:\n  //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js:\n  //   In function zzz\n  //         undefinedFunc(a);\n  //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:\n  //   In function yyy\n  //           zzz(x, y, z);\n  //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:\n  //   In function xxx\n  //           yyy(a, a, a);\n  //   Line 1 of function script\n  //     try { xxx('hi'); return false; } catch(ex) { report(ex); }\n  //   ...\n  var message = tryToGetString(ex, 'message');\n\n  if (!message) {\n    return;\n  }\n\n  var lines = message.split('\\n');\n\n  if (lines.length < 4) {\n    return;\n  }\n\n  var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i;\n  var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i;\n  var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i;\n  var stack = [];\n  var scripts = window && window.document && window.document.getElementsByTagName('script');\n  var inlineScriptBlocks = [];\n  var parts;\n\n  for (var s in scripts) {\n    if (has(scripts, s) && !scripts[s].src) {\n      inlineScriptBlocks.push(scripts[s]);\n    }\n  }\n\n  for (var line = 2; line < lines.length; line += 2) {\n    var item = void 0;\n\n    if (lineRE1.exec(lines[line])) {\n      parts = lineRE1.exec(lines[line]);\n      item = {\n        args: [],\n        column: undefined,\n        func: parts[3],\n        line: +parts[1],\n        url: parts[2]\n      };\n    } else if (lineRE2.exec(lines[line])) {\n      parts = lineRE2.exec(lines[line]);\n      item = {\n        args: [],\n        column: undefined,\n        func: parts[4],\n        line: +parts[1],\n        url: parts[3]\n      };\n    } else if (lineRE3.exec(lines[line])) {\n      parts = lineRE3.exec(lines[line]);\n      var url = window.location.href.replace(/#.*$/, '');\n      item = {\n        url: url,\n        args: [],\n        column: undefined,\n        func: '',\n        line: +parts[1]\n      };\n    }\n\n    if (item) {\n      if (!item.func) {\n        item.func = UNKNOWN_FUNCTION;\n      }\n\n      item.context = [lines[line + 1]];\n      stack.push(item);\n    }\n  }\n\n  if (!stack.length) {\n    return; // could not parse multiline exception message as Opera stack trace\n  }\n\n  return {\n    stack: stack,\n    message: lines[0],\n    name: tryToGetString(ex, 'name')\n  };\n}\n/**\n * Adds information about the first frame to incomplete stack traces.\n * Safari and IE require this to get complete data on the first frame.\n * @param {StackTrace} stackInfo Stack trace information from\n * one of the compute* methods.\n * @param {string=} url The URL of the script that caused an error.\n * @param {(number|string)=} lineNo The line number of the script that\n * caused an error.\n * @param {string=} message The error generated by the browser, which\n * hopefully contains the name of the object that caused the error.\n * @return {boolean} Whether or not the stack information was\n * augmented.\n * @memberof computeStackTrace\n */\n\n\nexport function augmentStackTraceWithInitialElement(stackInfo, url, lineNo) {\n  var initial = {\n    url: url,\n    line: lineNo ? +lineNo : undefined\n  };\n\n  if (initial.url && initial.line) {\n    stackInfo.incomplete = false;\n    var stack = stackInfo.stack;\n\n    if (stack.length > 0) {\n      if (stack[0].url === initial.url) {\n        if (stack[0].line === initial.line) {\n          return false; // already in stack trace\n        }\n\n        if (!stack[0].line && stack[0].func === initial.func) {\n          stack[0].line = initial.line;\n          stack[0].context = initial.context;\n          return false;\n        }\n      }\n    }\n\n    stack.unshift(initial);\n    stackInfo.partial = true;\n    return true;\n  }\n\n  stackInfo.incomplete = true;\n  return false;\n}\n/**\n * Computes stack trace information by walking the arguments.caller\n * chain at the time the exception occurred. This will cause earlier\n * frames to be missed but is the only way to get any stack trace in\n * Safari and IE. The top frame is restored by\n * {@link augmentStackTraceWithInitialElement}.\n * @param {Error} ex\n * @param {number} depth\n * @return {StackTrace} Stack trace information.\n * @memberof computeStackTrace\n */\n\nfunction computeStackTraceByWalkingCallerChain(ex, depth) {\n  var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i;\n  var stack = [];\n  var funcs = {};\n  var recursion = false;\n  var parts;\n  var item;\n\n  for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n    if (curr === computeStackTrace || curr === report) {\n      continue;\n    }\n\n    item = {\n      args: [],\n      column: undefined,\n      func: UNKNOWN_FUNCTION,\n      line: undefined,\n      url: undefined\n    };\n    parts = functionName.exec(curr.toString());\n\n    if (curr.name) {\n      item.func = curr.name;\n    } else if (parts) {\n      item.func = parts[1];\n    }\n\n    if (typeof item.func === 'undefined') {\n      item.func = parts ? parts.input.substring(0, parts.input.indexOf('{')) : undefined;\n    }\n\n    if (funcs[curr.toString()]) {\n      recursion = true;\n    } else {\n      funcs[curr.toString()] = true;\n    }\n\n    stack.push(item);\n  }\n\n  if (depth) {\n    stack.splice(0, depth);\n  }\n\n  var result = {\n    stack: stack,\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name')\n  };\n  augmentStackTraceWithInitialElement(result, tryToGetString(ex, 'sourceURL') || tryToGetString(ex, 'fileName'), tryToGetString(ex, 'line') || tryToGetString(ex, 'lineNumber'));\n  return result;\n}\n\nfunction tryToGetString(candidate, property) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined;\n  }\n\n  var value = candidate[property];\n  return typeof value === 'string' ? value : undefined;\n}\n/**\n * Logs a stacktrace starting from the previous call and working down.\n * @param {(number|string)=} depth How many frames deep to trace.\n * @return {StackTrace} Stack trace information.\n * @memberof computeStackTrace\n */\n\n\nexport function computeStackTraceOfCaller(depth) {\n  var currentDepth = (depth === undefined ? 0 : +depth) + 1; // \"+ 1\" because \"ofCaller\" should drop one frame\n\n  try {\n    throw new Error();\n  } catch (ex) {\n    return computeStackTrace(ex, currentDepth + 1);\n  }\n}\n/**\n * A better form of hasOwnProperty<br/>\n * Example: `has(MainHostObject, property) === true/false`\n *\n * @param {Object} object to check property\n * @param {string} key to check\n * @return {Boolean} true if the object has the key and it is not inherited\n */\n\nfunction has(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n/**\n * Returns true if the parameter is undefined<br/>\n * Example: `isUndefined(val) === true/false`\n *\n * @param {*} what Value to check\n * @return {Boolean} true if undefined and false otherwise\n */\n\n\nfunction isUndefined(what) {\n  return typeof what === 'undefined';\n}","map":{"version":3,"sources":["../../../src/domain/tracekit/computeStackTrace.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { report } from './report';\nvar UNKNOWN_FUNCTION = '?';\n/**\n * computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n * ```js\n * s = computeStackTraceOfCaller([depth])\n * s = computeStackTrace(exception) // consider using report instead (see below)\n * ```\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with report,\n * which builds on top of computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n * Tracing example:\n * ```js\n *     function trace(message) {\n *         let stackInfo = computeStackTrace.ofCaller();\n *         let data = message + \"\\n\";\n *         for(let i in stackInfo.stack) {\n *             let item = stackInfo.stack[i];\n *             data += (item.func || '[anonymous]') + \"() in \" + item.url + \":\" + (item.line || '0') + \"\\n\";\n *         }\n *         if (window.console)\n *             console.info(data);\n *         else\n *             alert(data);\n *     }\n * ```\n * @memberof TraceKit\n * @namespace\n */\n/**\n * Computes a stack trace for an exception.\n * @param {Error} ex\n * @param {(string|number)=} depth\n * @memberof computeStackTrace\n */\nexport function computeStackTrace(ex, depth) {\n    var stack;\n    var normalizedDepth = depth === undefined ? 0 : +depth;\n    try {\n        // This must be tried first because Opera 10 *destroys*\n        // its stacktrace property if you try to access the stack\n        // property first!!\n        stack = computeStackTraceFromStacktraceProp(ex);\n        if (stack) {\n            return stack;\n        }\n    }\n    catch (e) {\n        if (debug) {\n            throw e;\n        }\n    }\n    try {\n        stack = computeStackTraceFromStackProp(ex);\n        if (stack) {\n            return stack;\n        }\n    }\n    catch (e) {\n        if (debug) {\n            throw e;\n        }\n    }\n    try {\n        stack = computeStackTraceFromOperaMultiLineMessage(ex);\n        if (stack) {\n            return stack;\n        }\n    }\n    catch (e) {\n        if (debug) {\n            throw e;\n        }\n    }\n    try {\n        stack = computeStackTraceByWalkingCallerChain(ex, normalizedDepth + 1);\n        if (stack) {\n            return stack;\n        }\n    }\n    catch (e) {\n        if (debug) {\n            throw e;\n        }\n    }\n    return {\n        message: tryToGetString(ex, 'message'),\n        name: tryToGetString(ex, 'name'),\n        stack: [],\n    };\n}\nvar debug = false;\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.columnNumber = 69\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?StackTrace} Stack trace information.\n * @memberof computeStackTrace\n */\nexport function computeStackTraceFromStackProp(ex) {\n    var stacktrace = tryToGetString(ex, 'stack');\n    if (!stacktrace) {\n        return;\n    }\n    // eslint-disable-next-line  max-len\n    var chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n    // eslint-disable-next-line  max-len\n    var gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\n    // eslint-disable-next-line  max-len\n    var winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n    // Used to additionally parse URL/line/column from eval frames\n    var isEval;\n    var geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n    var chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n    var lines = stacktrace.split('\\n');\n    var stack = [];\n    var submatch;\n    var parts;\n    var element;\n    for (var i = 0, j = lines.length; i < j; i += 1) {\n        if (chrome.exec(lines[i])) {\n            parts = chrome.exec(lines[i]);\n            var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n            isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n            submatch = chromeEval.exec(parts[2]);\n            if (isEval && submatch) {\n                // throw out eval line/column and use top-most line/column number\n                parts[2] = submatch[1]; // url\n                parts[3] = submatch[2]; // line\n                parts[4] = submatch[3]; // column\n            }\n            element = {\n                args: isNative ? [parts[2]] : [],\n                column: parts[4] ? +parts[4] : undefined,\n                func: parts[1] || UNKNOWN_FUNCTION,\n                line: parts[3] ? +parts[3] : undefined,\n                url: !isNative ? parts[2] : undefined,\n            };\n        }\n        else if (winjs.exec(lines[i])) {\n            parts = winjs.exec(lines[i]);\n            element = {\n                args: [],\n                column: parts[4] ? +parts[4] : undefined,\n                func: parts[1] || UNKNOWN_FUNCTION,\n                line: +parts[3],\n                url: parts[2],\n            };\n        }\n        else if (gecko.exec(lines[i])) {\n            parts = gecko.exec(lines[i]);\n            isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n            submatch = geckoEval.exec(parts[3]);\n            if (isEval && submatch) {\n                // throw out eval line/column and use top-most line number\n                parts[3] = submatch[1];\n                parts[4] = submatch[2];\n                parts[5] = undefined; // no column when eval\n            }\n            else if (i === 0 && !parts[5] && !isUndefined(ex.columnNumber)) {\n                // FireFox uses this awesome columnNumber property for its top frame\n                // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n                // so adding 1\n                // NOTE: this hack doesn't work if top-most frame is eval\n                stack[0].column = ex.columnNumber + 1;\n            }\n            element = {\n                args: parts[2] ? parts[2].split(',') : [],\n                column: parts[5] ? +parts[5] : undefined,\n                func: parts[1] || UNKNOWN_FUNCTION,\n                line: parts[4] ? +parts[4] : undefined,\n                url: parts[3],\n            };\n        }\n        else {\n            continue;\n        }\n        if (!element.func && element.line) {\n            element.func = UNKNOWN_FUNCTION;\n        }\n        stack.push(element);\n    }\n    if (!stack.length) {\n        return;\n    }\n    return {\n        stack: stack,\n        message: tryToGetString(ex, 'message'),\n        name: tryToGetString(ex, 'name'),\n    };\n}\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10+ uses this property.\n * @param {Error} ex\n * @return {?StackTrace} Stack trace information.\n * @memberof computeStackTrace\n */\nfunction computeStackTraceFromStacktraceProp(ex) {\n    // Access and store the stacktrace property before doing ANYTHING\n    // else to it because Opera is not very good at providing it\n    // reliably in other circumstances.\n    var stacktrace = tryToGetString(ex, 'stacktrace');\n    if (!stacktrace) {\n        return;\n    }\n    var opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n    // eslint-disable-next-line  max-len\n    var opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i;\n    var lines = stacktrace.split('\\n');\n    var stack = [];\n    var parts;\n    for (var line = 0; line < lines.length; line += 2) {\n        var element = void 0;\n        if (opera10Regex.exec(lines[line])) {\n            parts = opera10Regex.exec(lines[line]);\n            element = {\n                args: [],\n                column: undefined,\n                func: parts[3],\n                line: +parts[1],\n                url: parts[2],\n            };\n        }\n        else if (opera11Regex.exec(lines[line])) {\n            parts = opera11Regex.exec(lines[line]);\n            element = {\n                args: parts[5] ? parts[5].split(',') : [],\n                column: +parts[2],\n                func: parts[3] || parts[4],\n                line: +parts[1],\n                url: parts[6],\n            };\n        }\n        if (element) {\n            if (!element.func && element.line) {\n                element.func = UNKNOWN_FUNCTION;\n            }\n            element.context = [lines[line + 1]];\n            stack.push(element);\n        }\n    }\n    if (!stack.length) {\n        return;\n    }\n    return {\n        stack: stack,\n        message: tryToGetString(ex, 'message'),\n        name: tryToGetString(ex, 'name'),\n    };\n}\n/**\n * NOT TESTED.\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?StackTrace} Stack information.\n * @memberof computeStackTrace\n */\nfunction computeStackTraceFromOperaMultiLineMessage(ex) {\n    // TODO: Clean this function up\n    // Opera includes a stack trace into the exception message. An example is:\n    //\n    // Statement on line 3: Undefined variable: undefinedFunc\n    // Backtrace:\n    //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js:\n    //   In function zzz\n    //         undefinedFunc(a);\n    //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:\n    //   In function yyy\n    //           zzz(x, y, z);\n    //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:\n    //   In function xxx\n    //           yyy(a, a, a);\n    //   Line 1 of function script\n    //     try { xxx('hi'); return false; } catch(ex) { report(ex); }\n    //   ...\n    var message = tryToGetString(ex, 'message');\n    if (!message) {\n        return;\n    }\n    var lines = message.split('\\n');\n    if (lines.length < 4) {\n        return;\n    }\n    var lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i;\n    var lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i;\n    var lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i;\n    var stack = [];\n    var scripts = window && window.document && window.document.getElementsByTagName('script');\n    var inlineScriptBlocks = [];\n    var parts;\n    for (var s in scripts) {\n        if (has(scripts, s) && !scripts[s].src) {\n            inlineScriptBlocks.push(scripts[s]);\n        }\n    }\n    for (var line = 2; line < lines.length; line += 2) {\n        var item = void 0;\n        if (lineRE1.exec(lines[line])) {\n            parts = lineRE1.exec(lines[line]);\n            item = {\n                args: [],\n                column: undefined,\n                func: parts[3],\n                line: +parts[1],\n                url: parts[2],\n            };\n        }\n        else if (lineRE2.exec(lines[line])) {\n            parts = lineRE2.exec(lines[line]);\n            item = {\n                args: [],\n                column: undefined,\n                func: parts[4],\n                line: +parts[1],\n                url: parts[3],\n            };\n        }\n        else if (lineRE3.exec(lines[line])) {\n            parts = lineRE3.exec(lines[line]);\n            var url = window.location.href.replace(/#.*$/, '');\n            item = {\n                url: url,\n                args: [],\n                column: undefined,\n                func: '',\n                line: +parts[1],\n            };\n        }\n        if (item) {\n            if (!item.func) {\n                item.func = UNKNOWN_FUNCTION;\n            }\n            item.context = [lines[line + 1]];\n            stack.push(item);\n        }\n    }\n    if (!stack.length) {\n        return; // could not parse multiline exception message as Opera stack trace\n    }\n    return {\n        stack: stack,\n        message: lines[0],\n        name: tryToGetString(ex, 'name'),\n    };\n}\n/**\n * Adds information about the first frame to incomplete stack traces.\n * Safari and IE require this to get complete data on the first frame.\n * @param {StackTrace} stackInfo Stack trace information from\n * one of the compute* methods.\n * @param {string=} url The URL of the script that caused an error.\n * @param {(number|string)=} lineNo The line number of the script that\n * caused an error.\n * @param {string=} message The error generated by the browser, which\n * hopefully contains the name of the object that caused the error.\n * @return {boolean} Whether or not the stack information was\n * augmented.\n * @memberof computeStackTrace\n */\nexport function augmentStackTraceWithInitialElement(stackInfo, url, lineNo) {\n    var initial = {\n        url: url,\n        line: lineNo ? +lineNo : undefined,\n    };\n    if (initial.url && initial.line) {\n        stackInfo.incomplete = false;\n        var stack = stackInfo.stack;\n        if (stack.length > 0) {\n            if (stack[0].url === initial.url) {\n                if (stack[0].line === initial.line) {\n                    return false; // already in stack trace\n                }\n                if (!stack[0].line && stack[0].func === initial.func) {\n                    stack[0].line = initial.line;\n                    stack[0].context = initial.context;\n                    return false;\n                }\n            }\n        }\n        stack.unshift(initial);\n        stackInfo.partial = true;\n        return true;\n    }\n    stackInfo.incomplete = true;\n    return false;\n}\n/**\n * Computes stack trace information by walking the arguments.caller\n * chain at the time the exception occurred. This will cause earlier\n * frames to be missed but is the only way to get any stack trace in\n * Safari and IE. The top frame is restored by\n * {@link augmentStackTraceWithInitialElement}.\n * @param {Error} ex\n * @param {number} depth\n * @return {StackTrace} Stack trace information.\n * @memberof computeStackTrace\n */\nfunction computeStackTraceByWalkingCallerChain(ex, depth) {\n    var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i;\n    var stack = [];\n    var funcs = {};\n    var recursion = false;\n    var parts;\n    var item;\n    for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n        if (curr === computeStackTrace || curr === report) {\n            continue;\n        }\n        item = {\n            args: [],\n            column: undefined,\n            func: UNKNOWN_FUNCTION,\n            line: undefined,\n            url: undefined,\n        };\n        parts = functionName.exec(curr.toString());\n        if (curr.name) {\n            item.func = curr.name;\n        }\n        else if (parts) {\n            item.func = parts[1];\n        }\n        if (typeof item.func === 'undefined') {\n            item.func = parts ? parts.input.substring(0, parts.input.indexOf('{')) : undefined;\n        }\n        if (funcs[curr.toString()]) {\n            recursion = true;\n        }\n        else {\n            funcs[curr.toString()] = true;\n        }\n        stack.push(item);\n    }\n    if (depth) {\n        stack.splice(0, depth);\n    }\n    var result = {\n        stack: stack,\n        message: tryToGetString(ex, 'message'),\n        name: tryToGetString(ex, 'name'),\n    };\n    augmentStackTraceWithInitialElement(result, tryToGetString(ex, 'sourceURL') || tryToGetString(ex, 'fileName'), tryToGetString(ex, 'line') || tryToGetString(ex, 'lineNumber'));\n    return result;\n}\nfunction tryToGetString(candidate, property) {\n    if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n        return undefined;\n    }\n    var value = candidate[property];\n    return typeof value === 'string' ? value : undefined;\n}\n/**\n * Logs a stacktrace starting from the previous call and working down.\n * @param {(number|string)=} depth How many frames deep to trace.\n * @return {StackTrace} Stack trace information.\n * @memberof computeStackTrace\n */\nexport function computeStackTraceOfCaller(depth) {\n    var currentDepth = (depth === undefined ? 0 : +depth) + 1; // \"+ 1\" because \"ofCaller\" should drop one frame\n    try {\n        throw new Error();\n    }\n    catch (ex) {\n        return computeStackTrace(ex, currentDepth + 1);\n    }\n}\n/**\n * A better form of hasOwnProperty<br/>\n * Example: `has(MainHostObject, property) === true/false`\n *\n * @param {Object} object to check property\n * @param {string} key to check\n * @return {Boolean} true if the object has the key and it is not inherited\n */\nfunction has(object, key) {\n    return Object.prototype.hasOwnProperty.call(object, key);\n}\n/**\n * Returns true if the parameter is undefined<br/>\n * Example: `isUndefined(val) === true/false`\n *\n * @param {*} what Value to check\n * @return {Boolean} true if undefined and false otherwise\n */\nfunction isUndefined(what) {\n    return typeof what === 'undefined';\n}\n//# sourceMappingURL=computeStackTrace.js.map"]},"metadata":{},"sourceType":"module"}