{"ast":null,"code":"import { noop, round, ONE_SECOND } from '@datadog/browser-core';\nimport { supportPerformanceTimingEvent } from '../../../browser/performanceCollection';\nimport { ViewLoadingType } from '../../../rawRumEvent.types';\nimport { LifeCycleEventType } from '../../lifeCycle';\nimport { trackEventCounts } from '../../trackEventCounts';\nimport { waitIdlePage } from '../../waitIdlePage';\nexport function trackViewMetrics(lifeCycle, domMutationObservable, scheduleViewUpdate, loadingType) {\n  var viewMetrics = {\n    eventCounts: {\n      errorCount: 0,\n      longTaskCount: 0,\n      resourceCount: 0,\n      userActionCount: 0\n    }\n  };\n  var stopEventCountsTracking = trackEventCounts(lifeCycle, function (newEventCounts) {\n    viewMetrics.eventCounts = newEventCounts;\n    scheduleViewUpdate();\n  }).stop;\n\n  var _a = trackLoadingTime(loadingType, function (newLoadingTime) {\n    viewMetrics.loadingTime = newLoadingTime;\n    scheduleViewUpdate();\n  }),\n      setActivityLoadingTime = _a.setActivityLoadingTime,\n      setLoadEvent = _a.setLoadEvent;\n\n  var stopActivityLoadingTimeTracking = trackActivityLoadingTime(lifeCycle, domMutationObservable, setActivityLoadingTime).stop;\n  var stopCLSTracking;\n\n  if (isLayoutShiftSupported()) {\n    viewMetrics.cumulativeLayoutShift = 0;\n    stopCLSTracking = trackCumulativeLayoutShift(lifeCycle, function (cumulativeLayoutShift) {\n      viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift;\n      scheduleViewUpdate();\n    }).stop;\n  } else {\n    stopCLSTracking = noop;\n  }\n\n  return {\n    stop: function () {\n      stopEventCountsTracking();\n      stopActivityLoadingTimeTracking();\n      stopCLSTracking();\n    },\n    setLoadEvent: setLoadEvent,\n    viewMetrics: viewMetrics\n  };\n}\n\nfunction trackLoadingTime(loadType, callback) {\n  var isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD;\n  var isWaitingForActivityLoadingTime = true;\n  var loadingTimeCandidates = [];\n\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      callback(Math.max.apply(Math, loadingTimeCandidates));\n    }\n  }\n\n  return {\n    setLoadEvent: function (loadEvent) {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false;\n        loadingTimeCandidates.push(loadEvent);\n        invokeCallbackIfAllCandidatesAreReceived();\n      }\n    },\n    setActivityLoadingTime: function (activityLoadingTime) {\n      if (isWaitingForActivityLoadingTime) {\n        isWaitingForActivityLoadingTime = false;\n\n        if (activityLoadingTime !== undefined) {\n          loadingTimeCandidates.push(activityLoadingTime);\n        }\n\n        invokeCallbackIfAllCandidatesAreReceived();\n      }\n    }\n  };\n}\n\nfunction trackActivityLoadingTime(lifeCycle, domMutationObservable, callback) {\n  return waitIdlePage(lifeCycle, domMutationObservable, function (event) {\n    if (event.hadActivity) {\n      callback(event.duration);\n    } else {\n      callback(undefined);\n    }\n  });\n}\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\n\n\nfunction trackCumulativeLayoutShift(lifeCycle, callback) {\n  var maxClsValue = 0;\n  var window = slidingSessionWindow();\n  var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n    if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n      window.update(entry);\n\n      if (window.value() > maxClsValue) {\n        maxClsValue = window.value();\n        callback(round(maxClsValue, 4));\n      }\n    }\n  }).unsubscribe;\n  return {\n    stop: stop\n  };\n}\n\nfunction slidingSessionWindow() {\n  var value = 0;\n  var startTime;\n  var endTime;\n  return {\n    update: function (entry) {\n      var shouldCreateNewWindow = startTime === undefined || entry.startTime - endTime >= ONE_SECOND || entry.startTime - startTime >= 5 * ONE_SECOND;\n\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime;\n        value = entry.value;\n      } else {\n        value += entry.value;\n        endTime = entry.startTime;\n      }\n    },\n    value: function () {\n      return value;\n    }\n  };\n}\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\n\n\nfunction isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent('layout-shift');\n}","map":{"version":3,"sources":["../../../../src/domain/rumEventsCollection/view/trackViewMetrics.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { noop, round, ONE_SECOND } from '@datadog/browser-core';\nimport { supportPerformanceTimingEvent } from '../../../browser/performanceCollection';\nimport { ViewLoadingType } from '../../../rawRumEvent.types';\nimport { LifeCycleEventType } from '../../lifeCycle';\nimport { trackEventCounts } from '../../trackEventCounts';\nimport { waitIdlePage } from '../../waitIdlePage';\nexport function trackViewMetrics(lifeCycle, domMutationObservable, scheduleViewUpdate, loadingType) {\n    var viewMetrics = {\n        eventCounts: {\n            errorCount: 0,\n            longTaskCount: 0,\n            resourceCount: 0,\n            userActionCount: 0,\n        },\n    };\n    var stopEventCountsTracking = trackEventCounts(lifeCycle, function (newEventCounts) {\n        viewMetrics.eventCounts = newEventCounts;\n        scheduleViewUpdate();\n    }).stop;\n    var _a = trackLoadingTime(loadingType, function (newLoadingTime) {\n        viewMetrics.loadingTime = newLoadingTime;\n        scheduleViewUpdate();\n    }), setActivityLoadingTime = _a.setActivityLoadingTime, setLoadEvent = _a.setLoadEvent;\n    var stopActivityLoadingTimeTracking = trackActivityLoadingTime(lifeCycle, domMutationObservable, setActivityLoadingTime).stop;\n    var stopCLSTracking;\n    if (isLayoutShiftSupported()) {\n        viewMetrics.cumulativeLayoutShift = 0;\n        (stopCLSTracking = trackCumulativeLayoutShift(lifeCycle, function (cumulativeLayoutShift) {\n            viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift;\n            scheduleViewUpdate();\n        }).stop);\n    }\n    else {\n        stopCLSTracking = noop;\n    }\n    return {\n        stop: function () {\n            stopEventCountsTracking();\n            stopActivityLoadingTimeTracking();\n            stopCLSTracking();\n        },\n        setLoadEvent: setLoadEvent,\n        viewMetrics: viewMetrics,\n    };\n}\nfunction trackLoadingTime(loadType, callback) {\n    var isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD;\n    var isWaitingForActivityLoadingTime = true;\n    var loadingTimeCandidates = [];\n    function invokeCallbackIfAllCandidatesAreReceived() {\n        if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n            callback(Math.max.apply(Math, loadingTimeCandidates));\n        }\n    }\n    return {\n        setLoadEvent: function (loadEvent) {\n            if (isWaitingForLoadEvent) {\n                isWaitingForLoadEvent = false;\n                loadingTimeCandidates.push(loadEvent);\n                invokeCallbackIfAllCandidatesAreReceived();\n            }\n        },\n        setActivityLoadingTime: function (activityLoadingTime) {\n            if (isWaitingForActivityLoadingTime) {\n                isWaitingForActivityLoadingTime = false;\n                if (activityLoadingTime !== undefined) {\n                    loadingTimeCandidates.push(activityLoadingTime);\n                }\n                invokeCallbackIfAllCandidatesAreReceived();\n            }\n        },\n    };\n}\nfunction trackActivityLoadingTime(lifeCycle, domMutationObservable, callback) {\n    return waitIdlePage(lifeCycle, domMutationObservable, function (event) {\n        if (event.hadActivity) {\n            callback(event.duration);\n        }\n        else {\n            callback(undefined);\n        }\n    });\n}\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nfunction trackCumulativeLayoutShift(lifeCycle, callback) {\n    var maxClsValue = 0;\n    var window = slidingSessionWindow();\n    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n        if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n            window.update(entry);\n            if (window.value() > maxClsValue) {\n                maxClsValue = window.value();\n                callback(round(maxClsValue, 4));\n            }\n        }\n    }).unsubscribe;\n    return {\n        stop: stop,\n    };\n}\nfunction slidingSessionWindow() {\n    var value = 0;\n    var startTime;\n    var endTime;\n    return {\n        update: function (entry) {\n            var shouldCreateNewWindow = startTime === undefined ||\n                entry.startTime - endTime >= ONE_SECOND ||\n                entry.startTime - startTime >= 5 * ONE_SECOND;\n            if (shouldCreateNewWindow) {\n                startTime = endTime = entry.startTime;\n                value = entry.value;\n            }\n            else {\n                value += entry.value;\n                endTime = entry.startTime;\n            }\n        },\n        value: function () { return value; },\n    };\n}\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nfunction isLayoutShiftSupported() {\n    return supportPerformanceTimingEvent('layout-shift');\n}\n//# sourceMappingURL=trackViewMetrics.js.map"]},"metadata":{},"sourceType":"module"}