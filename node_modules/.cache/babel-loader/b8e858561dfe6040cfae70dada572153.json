{"ast":null,"code":"import { callMonitored } from '../domain/internalMonitoring';\nimport { computeStackTrace } from '../domain/tracekit';\nimport { jsonStringify, noop } from './utils';\nexport var ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source'\n};\nexport var ErrorHandling;\n\n(function (ErrorHandling) {\n  ErrorHandling[\"HANDLED\"] = \"handled\";\n  ErrorHandling[\"UNHANDLED\"] = \"unhandled\";\n})(ErrorHandling || (ErrorHandling = {}));\n\nexport function formatUnknownError(stackTrace, errorObject, nonErrorPrefix, handlingStack) {\n  if (!stackTrace || stackTrace.message === undefined && !(errorObject instanceof Error)) {\n    return {\n      message: nonErrorPrefix + \" \" + jsonStringify(errorObject),\n      stack: 'No stack, consider using an instance of Error',\n      handlingStack: handlingStack,\n      type: stackTrace && stackTrace.name\n    };\n  }\n\n  return {\n    message: stackTrace.message || 'Empty message',\n    stack: toStackTraceString(stackTrace),\n    handlingStack: handlingStack,\n    type: stackTrace.name\n  };\n}\nexport function toStackTraceString(stack) {\n  var result = formatErrorMessage(stack);\n  stack.stack.forEach(function (frame) {\n    var func = frame.func === '?' ? '<anonymous>' : frame.func;\n    var args = frame.args && frame.args.length > 0 ? \"(\" + frame.args.join(', ') + \")\" : '';\n    var line = frame.line ? \":\" + frame.line : '';\n    var column = frame.line && frame.column ? \":\" + frame.column : '';\n    result += \"\\n  at \" + func + args + \" @ \" + frame.url + line + column;\n  });\n  return result;\n}\nexport function formatErrorMessage(stack) {\n  return (stack.name || 'Error') + \": \" + stack.message;\n}\n/**\n Creates a stacktrace without SDK internal frames.\n \n Constraints:\n - Has to be called at the utmost position of the call stack.\n - No internal monitoring should encapsulate the function, that is why we need to use callMonitored inside of it.\n */\n\nexport function createHandlingStack() {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  var internalFramesToSkip = 2;\n  var error = new Error();\n  var formattedStack; // IE needs to throw the error to fill in the stack trace\n\n  if (!error.stack) {\n    try {\n      throw error;\n    } catch (e) {\n      noop();\n    }\n  }\n\n  callMonitored(function () {\n    var stackTrace = computeStackTrace(error);\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);\n    formattedStack = toStackTraceString(stackTrace);\n  });\n  return formattedStack;\n}","map":{"version":3,"sources":["../../src/tools/error.ts"],"names":[],"mappings":"AAAA,SAAS,aAAT,QAA8B,8BAA9B;AACA,SAAS,iBAAT,QAA8C,oBAA9C;AAEA,SAAS,aAAT,EAAwB,IAAxB,QAAoC,SAApC;AAkBA,OAAO,IAAM,WAAW,GAAG;AACzB,EAAA,KAAK,EAAE,OADkB;AAEzB,EAAA,OAAO,EAAE,SAFgB;AAGzB,EAAA,MAAM,EAAE,QAHiB;AAIzB,EAAA,MAAM,EAAE,QAJiB;AAKzB,EAAA,OAAO,EAAE,SALgB;AAMzB,EAAA,MAAM,EAAE;AANiB,CAApB;AASP,OAAA,IAAY,aAAZ;;AAAA,CAAA,UAAY,aAAZ,EAAyB;AACvB,EAAA,aAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,aAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACD,CAHD,EAAY,aAAa,KAAb,aAAa,GAAA,EAAA,CAAzB;;AAQA,OAAM,SAAU,kBAAV,CACJ,UADI,EAEJ,WAFI,EAGJ,cAHI,EAIJ,aAJI,EAIkB;AAEtB,MAAI,CAAC,UAAD,IAAgB,UAAU,CAAC,OAAX,KAAuB,SAAvB,IAAoC,EAAE,WAAW,YAAY,KAAzB,CAAxD,EAA0F;AACxF,WAAO;AACL,MAAA,OAAO,EAAK,cAAc,GAAA,GAAd,GAAkB,aAAa,CAAC,WAAD,CADtC;AAEL,MAAA,KAAK,EAAE,+CAFF;AAGL,MAAA,aAAa,EAAA,aAHR;AAIL,MAAA,IAAI,EAAE,UAAU,IAAI,UAAU,CAAC;AAJ1B,KAAP;AAMD;;AAED,SAAO;AACL,IAAA,OAAO,EAAE,UAAU,CAAC,OAAX,IAAsB,eAD1B;AAEL,IAAA,KAAK,EAAE,kBAAkB,CAAC,UAAD,CAFpB;AAGL,IAAA,aAAa,EAAA,aAHR;AAIL,IAAA,IAAI,EAAE,UAAU,CAAC;AAJZ,GAAP;AAMD;AAED,OAAM,SAAU,kBAAV,CAA6B,KAA7B,EAA8C;AAClD,MAAI,MAAM,GAAG,kBAAkB,CAAC,KAAD,CAA/B;AACA,EAAA,KAAK,CAAC,KAAN,CAAY,OAAZ,CAAoB,UAAC,KAAD,EAAM;AACxB,QAAM,IAAI,GAAG,KAAK,CAAC,IAAN,KAAe,GAAf,GAAqB,aAArB,GAAqC,KAAK,CAAC,IAAxD;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,IAAN,IAAc,KAAK,CAAC,IAAN,CAAW,MAAX,GAAoB,CAAlC,GAAsC,MAAI,KAAK,CAAC,IAAN,CAAW,IAAX,CAAgB,IAAhB,CAAJ,GAAyB,GAA/D,GAAqE,EAAlF;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,IAAN,GAAa,MAAI,KAAK,CAAC,IAAvB,GAAgC,EAA7C;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,IAAN,IAAc,KAAK,CAAC,MAApB,GAA6B,MAAI,KAAK,CAAC,MAAvC,GAAkD,EAAjE;AACA,IAAA,MAAM,IAAI,YAAU,IAAV,GAAkB,IAAlB,GAAsB,KAAtB,GAA4B,KAAK,CAAC,GAAlC,GAAyC,IAAzC,GAAgD,MAA1D;AACD,GAND;AAOA,SAAO,MAAP;AACD;AAED,OAAM,SAAU,kBAAV,CAA6B,KAA7B,EAA8C;AAClD,SAAO,CAAG,KAAK,CAAC,IAAN,IAAc,OAAjB,IAAwB,IAAxB,GAA6B,KAAK,CAAC,OAA1C;AACD;AAED;;;;;;AAMG;;AACH,OAAM,SAAU,mBAAV,GAA6B;AACjC;;;;;AAKG;AACH,MAAM,oBAAoB,GAAG,CAA7B;AACA,MAAM,KAAK,GAAG,IAAI,KAAJ,EAAd;AACA,MAAI,cAAJ,CATiC,CAWjC;;AACA,MAAI,CAAC,KAAK,CAAC,KAAX,EAAkB;AAChB,QAAI;AACF,YAAM,KAAN;AACD,KAFD,CAEE,OAAO,CAAP,EAAU;AACV,MAAA,IAAI;AACL;AACF;;AAED,EAAA,aAAa,CAAC,YAAA;AACZ,QAAM,UAAU,GAAG,iBAAiB,CAAC,KAAD,CAApC;AACA,IAAA,UAAU,CAAC,KAAX,GAAmB,UAAU,CAAC,KAAX,CAAiB,KAAjB,CAAuB,oBAAvB,CAAnB;AACA,IAAA,cAAc,GAAG,kBAAkB,CAAC,UAAD,CAAnC;AACD,GAJY,CAAb;AAMA,SAAO,cAAP;AACD","sourceRoot":"","sourcesContent":["import { callMonitored } from '../domain/internalMonitoring';\nimport { computeStackTrace } from '../domain/tracekit';\nimport { jsonStringify, noop } from './utils';\nexport var ErrorSource = {\n    AGENT: 'agent',\n    CONSOLE: 'console',\n    CUSTOM: 'custom',\n    LOGGER: 'logger',\n    NETWORK: 'network',\n    SOURCE: 'source',\n};\nexport var ErrorHandling;\n(function (ErrorHandling) {\n    ErrorHandling[\"HANDLED\"] = \"handled\";\n    ErrorHandling[\"UNHANDLED\"] = \"unhandled\";\n})(ErrorHandling || (ErrorHandling = {}));\nexport function formatUnknownError(stackTrace, errorObject, nonErrorPrefix, handlingStack) {\n    if (!stackTrace || (stackTrace.message === undefined && !(errorObject instanceof Error))) {\n        return {\n            message: nonErrorPrefix + \" \" + jsonStringify(errorObject),\n            stack: 'No stack, consider using an instance of Error',\n            handlingStack: handlingStack,\n            type: stackTrace && stackTrace.name,\n        };\n    }\n    return {\n        message: stackTrace.message || 'Empty message',\n        stack: toStackTraceString(stackTrace),\n        handlingStack: handlingStack,\n        type: stackTrace.name,\n    };\n}\nexport function toStackTraceString(stack) {\n    var result = formatErrorMessage(stack);\n    stack.stack.forEach(function (frame) {\n        var func = frame.func === '?' ? '<anonymous>' : frame.func;\n        var args = frame.args && frame.args.length > 0 ? \"(\" + frame.args.join(', ') + \")\" : '';\n        var line = frame.line ? \":\" + frame.line : '';\n        var column = frame.line && frame.column ? \":\" + frame.column : '';\n        result += \"\\n  at \" + func + args + \" @ \" + frame.url + line + column;\n    });\n    return result;\n}\nexport function formatErrorMessage(stack) {\n    return (stack.name || 'Error') + \": \" + stack.message;\n}\n/**\n Creates a stacktrace without SDK internal frames.\n \n Constraints:\n - Has to be called at the utmost position of the call stack.\n - No internal monitoring should encapsulate the function, that is why we need to use callMonitored inside of it.\n */\nexport function createHandlingStack() {\n    /**\n     * Skip the two internal frames:\n     * - SDK API (console.error, ...)\n     * - this function\n     * in order to keep only the user calls\n     */\n    var internalFramesToSkip = 2;\n    var error = new Error();\n    var formattedStack;\n    // IE needs to throw the error to fill in the stack trace\n    if (!error.stack) {\n        try {\n            throw error;\n        }\n        catch (e) {\n            noop();\n        }\n    }\n    callMonitored(function () {\n        var stackTrace = computeStackTrace(error);\n        stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);\n        formattedStack = toStackTraceString(stackTrace);\n    });\n    return formattedStack;\n}\n//# sourceMappingURL=error.js.map"]},"metadata":{},"sourceType":"module"}