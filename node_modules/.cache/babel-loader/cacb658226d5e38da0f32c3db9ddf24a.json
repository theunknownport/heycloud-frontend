{"ast":null,"code":"import { toValidEntry } from './resourceUtils';\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n * - Browsers generate a timing entry for OPTIONS request\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - if a single timing match, return the timing\n * - if two following timings match (OPTIONS request), return the timing for the actual request\n * - otherwise we can't decide, return undefined\n */\n\nexport function matchRequestTiming(request) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return;\n  }\n\n  var sameNameEntries = performance.getEntriesByName(request.url, 'resource');\n\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return;\n  }\n\n  var candidates = sameNameEntries.map(function (entry) {\n    return entry.toJSON();\n  }).filter(toValidEntry).filter(function (entry) {\n    return isBetween(entry, request.startClocks.relative, endTime({\n      startTime: request.startClocks.relative,\n      duration: request.duration\n    }));\n  });\n\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n\n  if (candidates.length === 2 && firstCanBeOptionRequest(candidates)) {\n    return candidates[1];\n  }\n\n  return;\n}\n\nfunction firstCanBeOptionRequest(correspondingEntries) {\n  return endTime(correspondingEntries[0]) <= correspondingEntries[1].startTime;\n}\n\nfunction endTime(timing) {\n  // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n  return timing.startTime + timing.duration;\n}\n\nfunction isBetween(timing, start, end) {\n  var errorMargin = 1; // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n\n  return timing.startTime >= start - errorMargin && endTime(timing) <= end + errorMargin;\n}","map":{"version":3,"sources":["../../../../src/domain/rumEventsCollection/resource/matchRequestTiming.ts"],"names":[],"mappings":"AAGA,SAAS,YAAT,QAA6B,iBAA7B;AAOA;;;;;;;;;;;;;AAaG;;AACH,OAAM,SAAU,kBAAV,CAA6B,OAA7B,EAA0D;AAC9D,MAAI,CAAC,WAAD,IAAgB,EAAE,sBAAsB,WAAxB,CAApB,EAA0D;AACxD;AACD;;AACD,MAAM,eAAe,GAAG,WAAW,CAAC,gBAAZ,CAA6B,OAAO,CAAC,GAArC,EAA0C,UAA1C,CAAxB;;AAEA,MAAI,CAAC,eAAe,CAAC,MAAjB,IAA2B,EAAE,YAAY,eAAe,CAAC,CAAD,CAA7B,CAA/B,EAAkE;AAChE;AACD;;AAED,MAAM,UAAU,GAAG,eAAe,CAC/B,GADgB,CACZ,UAAC,KAAD,EAAM;AAAK,WAAA,KAAK,CAAL,MAAA,EAAA;AAA8C,GAD7C,EAEhB,MAFgB,CAET,YAFS,EAGhB,MAHgB,CAGT,UAAC,KAAD,EAAM;AACZ,WAAA,SAAS,CACP,KADO,EAEP,OAAO,CAAC,WAAR,CAAoB,QAFb,EAGP,OAAO,CAAC;AAAE,MAAA,SAAS,EAAE,OAAO,CAAC,WAAR,CAAoB,QAAjC;AAA2C,MAAA,QAAQ,EAAE,OAAO,CAAC;AAA7D,KAAD,CAHA,CAAT;AAIC,GARc,CAAnB;;AAWA,MAAI,UAAU,CAAC,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,WAAO,UAAU,CAAC,CAAD,CAAjB;AACD;;AAED,MAAI,UAAU,CAAC,MAAX,KAAsB,CAAtB,IAA2B,uBAAuB,CAAC,UAAD,CAAtD,EAAoE;AAClE,WAAO,UAAU,CAAC,CAAD,CAAjB;AACD;;AAED;AACD;;AAED,SAAS,uBAAT,CAAiC,oBAAjC,EAAqF;AACnF,SAAO,OAAO,CAAC,oBAAoB,CAAC,CAAD,CAArB,CAAP,IAAoC,oBAAoB,CAAC,CAAD,CAApB,CAAwB,SAAnE;AACD;;AAED,SAAS,OAAT,CAAiB,MAAjB,EAA+B;AAC7B;AACA,SAAQ,MAAM,CAAC,SAAP,GAAmB,MAAM,CAAC,QAAlC;AACD;;AAED,SAAS,SAAT,CAAmB,MAAnB,EAAmC,KAAnC,EAAwD,GAAxD,EAAyE;AACvE,MAAM,WAAW,GAAG,CAApB,CADuE,CAEvE;;AACA,SAAO,MAAM,CAAC,SAAP,IAAoB,KAAK,GAAG,WAA5B,IAA2C,OAAO,CAAC,MAAD,CAAP,IAAmB,GAAG,GAAG,WAA3E;AACD","sourceRoot":"","sourcesContent":["import { toValidEntry } from './resourceUtils';\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n * - Browsers generate a timing entry for OPTIONS request\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - if a single timing match, return the timing\n * - if two following timings match (OPTIONS request), return the timing for the actual request\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request) {\n    if (!performance || !('getEntriesByName' in performance)) {\n        return;\n    }\n    var sameNameEntries = performance.getEntriesByName(request.url, 'resource');\n    if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n        return;\n    }\n    var candidates = sameNameEntries\n        .map(function (entry) { return entry.toJSON(); })\n        .filter(toValidEntry)\n        .filter(function (entry) {\n        return isBetween(entry, request.startClocks.relative, endTime({ startTime: request.startClocks.relative, duration: request.duration }));\n    });\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    if (candidates.length === 2 && firstCanBeOptionRequest(candidates)) {\n        return candidates[1];\n    }\n    return;\n}\nfunction firstCanBeOptionRequest(correspondingEntries) {\n    return endTime(correspondingEntries[0]) <= correspondingEntries[1].startTime;\n}\nfunction endTime(timing) {\n    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n    return (timing.startTime + timing.duration);\n}\nfunction isBetween(timing, start, end) {\n    var errorMargin = 1;\n    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n    return timing.startTime >= start - errorMargin && endTime(timing) <= end + errorMargin;\n}\n//# sourceMappingURL=matchRequestTiming.js.map"]},"metadata":{},"sourceType":"module"}