{"ast":null,"code":"import { elapsed, monitor, Observable, timeStampNow } from '@datadog/browser-core';\nimport { LifeCycleEventType } from './lifeCycle'; // Delay to wait for a page activity to validate the tracking process\n\nexport var PAGE_ACTIVITY_VALIDATION_DELAY = 100; // Delay to wait after a page activity to end the tracking process\n\nexport var PAGE_ACTIVITY_END_DELAY = 100;\n/**\n * Wait for the next idle page time\n *\n * Detection lifecycle:\n * ```\n *                           Wait idle page\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\n\nexport function waitIdlePage(lifeCycle, domMutationObservable, idlePageCallback, maxDuration) {\n  var pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable);\n  return doWaitIdlePage(pageActivityObservable, idlePageCallback, maxDuration);\n}\nexport function doWaitIdlePage(pageActivityObservable, idlePageCallback, maxDuration) {\n  var idleTimeoutId;\n  var hasCompleted = false;\n  var startTime = timeStampNow();\n  var validationTimeoutId = setTimeout(monitor(function () {\n    return complete({\n      hadActivity: false\n    });\n  }), PAGE_ACTIVITY_VALIDATION_DELAY);\n  var maxDurationTimeoutId = maxDuration && setTimeout(monitor(function () {\n    return complete({\n      hadActivity: true,\n      duration: elapsed(startTime, timeStampNow())\n    });\n  }), maxDuration);\n  var pageActivitySubscription = pageActivityObservable.subscribe(function (_a) {\n    var isBusy = _a.isBusy;\n    clearTimeout(validationTimeoutId);\n    clearTimeout(idleTimeoutId);\n    var lastChangeTime = timeStampNow();\n\n    if (!isBusy) {\n      idleTimeoutId = setTimeout(monitor(function () {\n        return complete({\n          hadActivity: true,\n          duration: elapsed(startTime, lastChangeTime)\n        });\n      }), PAGE_ACTIVITY_END_DELAY);\n    }\n  });\n\n  var stop = function () {\n    hasCompleted = true;\n    clearTimeout(validationTimeoutId);\n    clearTimeout(idleTimeoutId);\n    clearTimeout(maxDurationTimeoutId);\n    pageActivitySubscription.unsubscribe();\n  };\n\n  function complete(event) {\n    if (hasCompleted) {\n      return;\n    }\n\n    stop();\n    idlePageCallback(event);\n  }\n\n  return {\n    stop: stop\n  };\n}\nexport function createPageActivityObservable(lifeCycle, domMutationObservable) {\n  var observable = new Observable(function () {\n    var subscriptions = [];\n    var firstRequestIndex;\n    var pendingRequestsCount = 0;\n    subscriptions.push(domMutationObservable.subscribe(function () {\n      return notifyPageActivity(pendingRequestsCount);\n    }), lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n      if (entry.entryType !== 'resource') {\n        return;\n      }\n\n      notifyPageActivity(pendingRequestsCount);\n    }), lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, function (startEvent) {\n      if (firstRequestIndex === undefined) {\n        firstRequestIndex = startEvent.requestIndex;\n      }\n\n      notifyPageActivity(++pendingRequestsCount);\n    }), lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, function (request) {\n      // If the request started before the tracking start, ignore it\n      if (firstRequestIndex === undefined || request.requestIndex < firstRequestIndex) {\n        return;\n      }\n\n      notifyPageActivity(--pendingRequestsCount);\n    }));\n    return function () {\n      return subscriptions.forEach(function (s) {\n        return s.unsubscribe();\n      });\n    };\n  });\n\n  function notifyPageActivity(pendingRequestsCount) {\n    observable.notify({\n      isBusy: pendingRequestsCount > 0\n    });\n  }\n\n  return observable;\n}","map":{"version":3,"sources":["../../src/domain/waitIdlePage.ts"],"names":[],"mappings":"AAAA,SAAmB,OAAnB,EAA4B,OAA5B,EAAqC,UAArC,EAA+D,YAA/D,QAAmF,uBAAnF;AACA,SAAoB,kBAApB,QAA8C,aAA9C,C,CAEA;;AACA,OAAO,IAAM,8BAA8B,GAAG,GAAvC,C,CACP;;AACA,OAAO,IAAM,uBAAuB,GAAG,GAAhC;AAQP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BG;;AACH,OAAM,SAAU,YAAV,CACJ,SADI,EAEJ,qBAFI,EAGJ,gBAHI,EAIJ,WAJI,EAIgB;AAEpB,MAAM,sBAAsB,GAAG,4BAA4B,CAAC,SAAD,EAAY,qBAAZ,CAA3D;AACA,SAAO,cAAc,CAAC,sBAAD,EAAyB,gBAAzB,EAA2C,WAA3C,CAArB;AACD;AAED,OAAM,SAAU,cAAV,CACJ,sBADI,EAEJ,gBAFI,EAGJ,WAHI,EAGgB;AAEpB,MAAI,aAAJ;AACA,MAAI,YAAY,GAAG,KAAnB;AACA,MAAM,SAAS,GAAG,YAAY,EAA9B;AAEA,MAAM,mBAAmB,GAAG,UAAU,CACpC,OAAO,CAAC,YAAA;AAAM,WAAA,QAAQ,CAAC;AAAE,MAAA,WAAW,EAAtB;AAAS,KAAD,CAAR;AAAgC,GAAvC,CAD6B,EAEpC,8BAFoC,CAAtC;AAIA,MAAM,oBAAoB,GACxB,WAAW,IACX,UAAU,CACR,OAAO,CAAC,YAAA;AAAM,WAAA,QAAQ,CAAC;AAAE,MAAA,WAAW,EAAE,IAAf;AAAqB,MAAA,QAAQ,EAAE,OAAO,CAAC,SAAD,EAAY,YAA3D,EAA+C;AAAtC,KAAD,CAAR;AAA6E,GAApF,CADC,EAER,WAFQ,CAFZ;AAOA,MAAM,wBAAwB,GAAG,sBAAsB,CAAC,SAAvB,CAAiC,UAAC,EAAD,EAAW;QAAR,MAAM,GAAA,EAAA,CAAA,M;AACzE,IAAA,YAAY,CAAC,mBAAD,CAAZ;AACA,IAAA,YAAY,CAAC,aAAD,CAAZ;AACA,QAAM,cAAc,GAAG,YAAY,EAAnC;;AACA,QAAI,CAAC,MAAL,EAAa;AACX,MAAA,aAAa,GAAG,UAAU,CACxB,OAAO,CAAC,YAAA;AAAM,eAAA,QAAQ,CAAC;AAAE,UAAA,WAAW,EAAE,IAAf;AAAqB,UAAA,QAAQ,EAAE,OAAO,CAAC,SAAD,EAA/C,cAA+C;AAAtC,SAAD,CAAR;AAA6E,OAApF,CADiB,EAExB,uBAFwB,CAA1B;AAID;AACF,GAVgC,CAAjC;;AAYA,MAAM,IAAI,GAAG,YAAA;AACX,IAAA,YAAY,GAAG,IAAf;AACA,IAAA,YAAY,CAAC,mBAAD,CAAZ;AACA,IAAA,YAAY,CAAC,aAAD,CAAZ;AACA,IAAA,YAAY,CAAC,oBAAD,CAAZ;AACA,IAAA,wBAAwB,CAAC,WAAzB;AACD,GAND;;AAQA,WAAS,QAAT,CAAkB,KAAlB,EAAsC;AACpC,QAAI,YAAJ,EAAkB;AAChB;AACD;;AACD,IAAA,IAAI;AACJ,IAAA,gBAAgB,CAAC,KAAD,CAAhB;AACD;;AACD,SAAO;AAAE,IAAA,IAAI,EAAA;AAAN,GAAP;AACD;AAED,OAAM,SAAU,4BAAV,CACJ,SADI,EAEJ,qBAFI,EAEmC;AAEvC,MAAM,UAAU,GAAG,IAAI,UAAJ,CAAkC,YAAA;AACnD,QAAM,aAAa,GAAmB,EAAtC;AACA,QAAI,iBAAJ;AACA,QAAI,oBAAoB,GAAG,CAA3B;AAEA,IAAA,aAAa,CAAC,IAAd,CACE,qBAAqB,CAAC,SAAtB,CAAgC,YAAA;AAAM,aAAA,kBAAkB,CAAlB,oBAAkB,CAAlB;AAAwC,KAA9E,CADF,EAEE,SAAS,CAAC,SAAV,CAAoB,kBAAkB,CAAC,2BAAvC,EAAoE,UAAC,KAAD,EAAM;AACxE,UAAI,KAAK,CAAC,SAAN,KAAoB,UAAxB,EAAoC;AAClC;AACD;;AAED,MAAA,kBAAkB,CAAC,oBAAD,CAAlB;AACD,KAND,CAFF,EASE,SAAS,CAAC,SAAV,CAAoB,kBAAkB,CAAC,eAAvC,EAAwD,UAAC,UAAD,EAAW;AACjE,UAAI,iBAAiB,KAAK,SAA1B,EAAqC;AACnC,QAAA,iBAAiB,GAAG,UAAU,CAAC,YAA/B;AACD;;AAED,MAAA,kBAAkB,CAAC,EAAE,oBAAH,CAAlB;AACD,KAND,CATF,EAgBE,SAAS,CAAC,SAAV,CAAoB,kBAAkB,CAAC,iBAAvC,EAA0D,UAAC,OAAD,EAAQ;AAChE;AACA,UAAI,iBAAiB,KAAK,SAAtB,IAAmC,OAAO,CAAC,YAAR,GAAuB,iBAA9D,EAAiF;AAC/E;AACD;;AACD,MAAA,kBAAkB,CAAC,EAAE,oBAAH,CAAlB;AACD,KAND,CAhBF;AAyBA,WAAO,YAAA;AAAM,aAAA,aAAa,CAAC,OAAd,CAAsB,UAAC,CAAD,EAAE;AAAK,eAAA,CAAC,CAAD,WAAA,EAAA;AAA7B,OAAA,CAAA;AAA6C,KAA1D;AACD,GA/BkB,CAAnB;;AAiCA,WAAS,kBAAT,CAA4B,oBAA5B,EAAwD;AACtD,IAAA,UAAU,CAAC,MAAX,CAAkB;AAAE,MAAA,MAAM,EAAE,oBAAoB,GAAG;AAAjC,KAAlB;AACD;;AAED,SAAO,UAAP;AACD","sourceRoot":"","sourcesContent":["import { elapsed, monitor, Observable, timeStampNow } from '@datadog/browser-core';\nimport { LifeCycleEventType } from './lifeCycle';\n// Delay to wait for a page activity to validate the tracking process\nexport var PAGE_ACTIVITY_VALIDATION_DELAY = 100;\n// Delay to wait after a page activity to end the tracking process\nexport var PAGE_ACTIVITY_END_DELAY = 100;\n/**\n * Wait for the next idle page time\n *\n * Detection lifecycle:\n * ```\n *                           Wait idle page\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitIdlePage(lifeCycle, domMutationObservable, idlePageCallback, maxDuration) {\n    var pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable);\n    return doWaitIdlePage(pageActivityObservable, idlePageCallback, maxDuration);\n}\nexport function doWaitIdlePage(pageActivityObservable, idlePageCallback, maxDuration) {\n    var idleTimeoutId;\n    var hasCompleted = false;\n    var startTime = timeStampNow();\n    var validationTimeoutId = setTimeout(monitor(function () { return complete({ hadActivity: false }); }), PAGE_ACTIVITY_VALIDATION_DELAY);\n    var maxDurationTimeoutId = maxDuration &&\n        setTimeout(monitor(function () { return complete({ hadActivity: true, duration: elapsed(startTime, timeStampNow()) }); }), maxDuration);\n    var pageActivitySubscription = pageActivityObservable.subscribe(function (_a) {\n        var isBusy = _a.isBusy;\n        clearTimeout(validationTimeoutId);\n        clearTimeout(idleTimeoutId);\n        var lastChangeTime = timeStampNow();\n        if (!isBusy) {\n            idleTimeoutId = setTimeout(monitor(function () { return complete({ hadActivity: true, duration: elapsed(startTime, lastChangeTime) }); }), PAGE_ACTIVITY_END_DELAY);\n        }\n    });\n    var stop = function () {\n        hasCompleted = true;\n        clearTimeout(validationTimeoutId);\n        clearTimeout(idleTimeoutId);\n        clearTimeout(maxDurationTimeoutId);\n        pageActivitySubscription.unsubscribe();\n    };\n    function complete(event) {\n        if (hasCompleted) {\n            return;\n        }\n        stop();\n        idlePageCallback(event);\n    }\n    return { stop: stop };\n}\nexport function createPageActivityObservable(lifeCycle, domMutationObservable) {\n    var observable = new Observable(function () {\n        var subscriptions = [];\n        var firstRequestIndex;\n        var pendingRequestsCount = 0;\n        subscriptions.push(domMutationObservable.subscribe(function () { return notifyPageActivity(pendingRequestsCount); }), lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {\n            if (entry.entryType !== 'resource') {\n                return;\n            }\n            notifyPageActivity(pendingRequestsCount);\n        }), lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, function (startEvent) {\n            if (firstRequestIndex === undefined) {\n                firstRequestIndex = startEvent.requestIndex;\n            }\n            notifyPageActivity(++pendingRequestsCount);\n        }), lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, function (request) {\n            // If the request started before the tracking start, ignore it\n            if (firstRequestIndex === undefined || request.requestIndex < firstRequestIndex) {\n                return;\n            }\n            notifyPageActivity(--pendingRequestsCount);\n        }));\n        return function () { return subscriptions.forEach(function (s) { return s.unsubscribe(); }); };\n    });\n    function notifyPageActivity(pendingRequestsCount) {\n        observable.notify({ isBusy: pendingRequestsCount > 0 });\n    }\n    return observable;\n}\n//# sourceMappingURL=waitIdlePage.js.map"]},"metadata":{},"sourceType":"module"}