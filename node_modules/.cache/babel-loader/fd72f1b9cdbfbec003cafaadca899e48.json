{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { addMonitoringMessage, elapsed, getPathName, includes, isValidUrl, ResourceType, toServerDuration } from '@datadog/browser-core';\nexport var FAKE_INITIAL_DOCUMENT = 'initial_document';\nvar RESOURCE_TYPES = [[ResourceType.DOCUMENT, function (initiatorType) {\n  return FAKE_INITIAL_DOCUMENT === initiatorType;\n}], [ResourceType.XHR, function (initiatorType) {\n  return 'xmlhttprequest' === initiatorType;\n}], [ResourceType.FETCH, function (initiatorType) {\n  return 'fetch' === initiatorType;\n}], [ResourceType.BEACON, function (initiatorType) {\n  return 'beacon' === initiatorType;\n}], [ResourceType.CSS, function (_, path) {\n  return /\\.css$/i.test(path);\n}], [ResourceType.JS, function (_, path) {\n  return /\\.js$/i.test(path);\n}], [ResourceType.IMAGE, function (initiatorType, path) {\n  return includes(['image', 'img', 'icon'], initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null;\n}], [ResourceType.FONT, function (_, path) {\n  return /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null;\n}], [ResourceType.MEDIA, function (initiatorType, path) {\n  return includes(['audio', 'video'], initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null;\n}]];\nexport function computeResourceKind(timing) {\n  var url = timing.name;\n\n  if (!isValidUrl(url)) {\n    addMonitoringMessage(\"Failed to construct URL for \\\"\" + timing.name + \"\\\"\");\n    return ResourceType.OTHER;\n  }\n\n  var path = getPathName(url);\n\n  for (var _i = 0, RESOURCE_TYPES_1 = RESOURCE_TYPES; _i < RESOURCE_TYPES_1.length; _i++) {\n    var _a = RESOURCE_TYPES_1[_i],\n        type = _a[0],\n        isType = _a[1];\n\n    if (isType(timing.initiatorType, path)) {\n      return type;\n    }\n  }\n\n  return ResourceType.OTHER;\n}\n\nfunction areInOrder() {\n  var numbers = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    numbers[_i] = arguments[_i];\n  }\n\n  for (var i = 1; i < numbers.length; i += 1) {\n    if (numbers[i - 1] > numbers[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isRequestKind(timing) {\n  return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch';\n}\nexport function computePerformanceResourceDuration(entry) {\n  var duration = entry.duration,\n      startTime = entry.startTime,\n      responseEnd = entry.responseEnd; // Safari duration is always 0 on timings blocked by cross origin policies.\n\n  if (duration === 0 && startTime < responseEnd) {\n    return toServerDuration(elapsed(startTime, responseEnd));\n  }\n\n  return toServerDuration(duration);\n}\nexport function computePerformanceResourceDetails(entry) {\n  var validEntry = toValidEntry(entry);\n\n  if (!validEntry) {\n    return undefined;\n  }\n\n  var startTime = validEntry.startTime,\n      fetchStart = validEntry.fetchStart,\n      redirectStart = validEntry.redirectStart,\n      redirectEnd = validEntry.redirectEnd,\n      domainLookupStart = validEntry.domainLookupStart,\n      domainLookupEnd = validEntry.domainLookupEnd,\n      connectStart = validEntry.connectStart,\n      secureConnectionStart = validEntry.secureConnectionStart,\n      connectEnd = validEntry.connectEnd,\n      requestStart = validEntry.requestStart,\n      responseStart = validEntry.responseStart,\n      responseEnd = validEntry.responseEnd;\n  var details = {\n    download: formatTiming(startTime, responseStart, responseEnd),\n    first_byte: formatTiming(startTime, requestStart, responseStart)\n  }; // Make sure a connection occurred\n\n  if (connectEnd !== fetchStart) {\n    details.connect = formatTiming(startTime, connectStart, connectEnd); // Make sure a secure connection occurred\n\n    if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {\n      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);\n    }\n  } // Make sure a domain lookup occurred\n\n\n  if (domainLookupEnd !== fetchStart) {\n    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);\n  }\n\n  if (hasRedirection(entry)) {\n    details.redirect = formatTiming(startTime, redirectStart, redirectEnd);\n  }\n\n  return details;\n}\nexport function toValidEntry(entry) {\n  // Ensure timings are in the right order. On top of filtering out potential invalid\n  // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n  // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n  // it.\n  if (!areInOrder(entry.startTime, entry.fetchStart, entry.domainLookupStart, entry.domainLookupEnd, entry.connectStart, entry.connectEnd, entry.requestStart, entry.responseStart, entry.responseEnd)) {\n    return undefined;\n  }\n\n  if (!hasRedirection(entry)) {\n    return entry;\n  }\n\n  var redirectStart = entry.redirectStart,\n      redirectEnd = entry.redirectEnd; // Firefox doesn't provide redirect timings on cross origin requests.\n  // Provide a default for those.\n\n  if (redirectStart < entry.startTime) {\n    redirectStart = entry.startTime;\n  }\n\n  if (redirectEnd < entry.startTime) {\n    redirectEnd = entry.fetchStart;\n  } // Make sure redirect timings are in order\n\n\n  if (!areInOrder(entry.startTime, redirectStart, redirectEnd, entry.fetchStart)) {\n    return undefined;\n  }\n\n  return __assign(__assign({}, entry), {\n    redirectEnd: redirectEnd,\n    redirectStart: redirectStart\n  });\n}\n\nfunction hasRedirection(entry) {\n  // The only time fetchStart is different than startTime is if a redirection occurred.\n  return entry.fetchStart !== entry.startTime;\n}\n\nfunction formatTiming(origin, start, end) {\n  return {\n    duration: toServerDuration(elapsed(start, end)),\n    start: toServerDuration(elapsed(origin, start))\n  };\n}\n\nexport function computeSize(entry) {\n  // Make sure a request actually occurred\n  if (entry.startTime < entry.responseStart) {\n    return entry.decodedBodySize;\n  }\n\n  return undefined;\n}\nexport function isAllowedRequestUrl(configuration, url) {\n  return url && !configuration.isIntakeUrl(url);\n}","map":{"version":3,"sources":["../../../../src/domain/rumEventsCollection/resource/resourceUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { addMonitoringMessage, elapsed, getPathName, includes, isValidUrl, ResourceType, toServerDuration, } from '@datadog/browser-core';\nexport var FAKE_INITIAL_DOCUMENT = 'initial_document';\nvar RESOURCE_TYPES = [\n    [ResourceType.DOCUMENT, function (initiatorType) { return FAKE_INITIAL_DOCUMENT === initiatorType; }],\n    [ResourceType.XHR, function (initiatorType) { return 'xmlhttprequest' === initiatorType; }],\n    [ResourceType.FETCH, function (initiatorType) { return 'fetch' === initiatorType; }],\n    [ResourceType.BEACON, function (initiatorType) { return 'beacon' === initiatorType; }],\n    [ResourceType.CSS, function (_, path) { return /\\.css$/i.test(path); }],\n    [ResourceType.JS, function (_, path) { return /\\.js$/i.test(path); }],\n    [\n        ResourceType.IMAGE,\n        function (initiatorType, path) {\n            return includes(['image', 'img', 'icon'], initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null;\n        },\n    ],\n    [ResourceType.FONT, function (_, path) { return /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null; }],\n    [\n        ResourceType.MEDIA,\n        function (initiatorType, path) {\n            return includes(['audio', 'video'], initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null;\n        },\n    ],\n];\nexport function computeResourceKind(timing) {\n    var url = timing.name;\n    if (!isValidUrl(url)) {\n        addMonitoringMessage(\"Failed to construct URL for \\\"\" + timing.name + \"\\\"\");\n        return ResourceType.OTHER;\n    }\n    var path = getPathName(url);\n    for (var _i = 0, RESOURCE_TYPES_1 = RESOURCE_TYPES; _i < RESOURCE_TYPES_1.length; _i++) {\n        var _a = RESOURCE_TYPES_1[_i], type = _a[0], isType = _a[1];\n        if (isType(timing.initiatorType, path)) {\n            return type;\n        }\n    }\n    return ResourceType.OTHER;\n}\nfunction areInOrder() {\n    var numbers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        numbers[_i] = arguments[_i];\n    }\n    for (var i = 1; i < numbers.length; i += 1) {\n        if (numbers[i - 1] > numbers[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isRequestKind(timing) {\n    return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch';\n}\nexport function computePerformanceResourceDuration(entry) {\n    var duration = entry.duration, startTime = entry.startTime, responseEnd = entry.responseEnd;\n    // Safari duration is always 0 on timings blocked by cross origin policies.\n    if (duration === 0 && startTime < responseEnd) {\n        return toServerDuration(elapsed(startTime, responseEnd));\n    }\n    return toServerDuration(duration);\n}\nexport function computePerformanceResourceDetails(entry) {\n    var validEntry = toValidEntry(entry);\n    if (!validEntry) {\n        return undefined;\n    }\n    var startTime = validEntry.startTime, fetchStart = validEntry.fetchStart, redirectStart = validEntry.redirectStart, redirectEnd = validEntry.redirectEnd, domainLookupStart = validEntry.domainLookupStart, domainLookupEnd = validEntry.domainLookupEnd, connectStart = validEntry.connectStart, secureConnectionStart = validEntry.secureConnectionStart, connectEnd = validEntry.connectEnd, requestStart = validEntry.requestStart, responseStart = validEntry.responseStart, responseEnd = validEntry.responseEnd;\n    var details = {\n        download: formatTiming(startTime, responseStart, responseEnd),\n        first_byte: formatTiming(startTime, requestStart, responseStart),\n    };\n    // Make sure a connection occurred\n    if (connectEnd !== fetchStart) {\n        details.connect = formatTiming(startTime, connectStart, connectEnd);\n        // Make sure a secure connection occurred\n        if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {\n            details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);\n        }\n    }\n    // Make sure a domain lookup occurred\n    if (domainLookupEnd !== fetchStart) {\n        details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);\n    }\n    if (hasRedirection(entry)) {\n        details.redirect = formatTiming(startTime, redirectStart, redirectEnd);\n    }\n    return details;\n}\nexport function toValidEntry(entry) {\n    // Ensure timings are in the right order. On top of filtering out potential invalid\n    // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n    // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n    // it.\n    if (!areInOrder(entry.startTime, entry.fetchStart, entry.domainLookupStart, entry.domainLookupEnd, entry.connectStart, entry.connectEnd, entry.requestStart, entry.responseStart, entry.responseEnd)) {\n        return undefined;\n    }\n    if (!hasRedirection(entry)) {\n        return entry;\n    }\n    var redirectStart = entry.redirectStart, redirectEnd = entry.redirectEnd;\n    // Firefox doesn't provide redirect timings on cross origin requests.\n    // Provide a default for those.\n    if (redirectStart < entry.startTime) {\n        redirectStart = entry.startTime;\n    }\n    if (redirectEnd < entry.startTime) {\n        redirectEnd = entry.fetchStart;\n    }\n    // Make sure redirect timings are in order\n    if (!areInOrder(entry.startTime, redirectStart, redirectEnd, entry.fetchStart)) {\n        return undefined;\n    }\n    return __assign(__assign({}, entry), { redirectEnd: redirectEnd,\n        redirectStart: redirectStart });\n}\nfunction hasRedirection(entry) {\n    // The only time fetchStart is different than startTime is if a redirection occurred.\n    return entry.fetchStart !== entry.startTime;\n}\nfunction formatTiming(origin, start, end) {\n    return {\n        duration: toServerDuration(elapsed(start, end)),\n        start: toServerDuration(elapsed(origin, start)),\n    };\n}\nexport function computeSize(entry) {\n    // Make sure a request actually occurred\n    if (entry.startTime < entry.responseStart) {\n        return entry.decodedBodySize;\n    }\n    return undefined;\n}\nexport function isAllowedRequestUrl(configuration, url) {\n    return url && !configuration.isIntakeUrl(url);\n}\n//# sourceMappingURL=resourceUtils.js.map"]},"metadata":{},"sourceType":"module"}