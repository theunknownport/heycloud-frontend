{"ast":null,"code":"import { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_ALLOW, PRIVACY_ATTR_VALUE_MASK, PRIVACY_ATTR_VALUE_MASK_USER_INPUT, PRIVACY_ATTR_VALUE_HIDDEN, PRIVACY_CLASS_ALLOW, PRIVACY_CLASS_MASK, PRIVACY_CLASS_MASK_USER_INPUT, PRIVACY_CLASS_HIDDEN, FORM_PRIVATE_TAG_NAMES, CENSORED_STRING_MARK, // Deprecated (now aliased) below\nPRIVACY_CLASS_INPUT_IGNORED, PRIVACY_CLASS_INPUT_MASKED, PRIVACY_ATTR_VALUE_INPUT_IGNORED, PRIVACY_ATTR_VALUE_INPUT_MASKED } from '../../constants';\nexport var MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100000;\nimport { makeStylesheetUrlsAbsolute } from './serializationUtils';\nimport { shouldIgnoreElement } from './serialize';\nvar TEXT_MASKING_CHAR = 'x';\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\n\nexport function getNodePrivacyLevel(node, defaultPrivacyLevel) {\n  var parentNodePrivacyLevel = node.parentNode ? getNodePrivacyLevel(node.parentNode, defaultPrivacyLevel) : defaultPrivacyLevel;\n  var selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);\n  return reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);\n}\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\n\nexport function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel;\n  }\n\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel;\n\n    default:\n      return parentNodePrivacyLevel;\n  }\n}\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\n\nexport function getNodeSelfPrivacyLevel(node) {\n  // Only Element types can be have a privacy level set\n  if (!isElement(node)) {\n    return;\n  }\n\n  var privAttr = node.getAttribute(PRIVACY_ATTR_NAME); // Overrules to enforce end-user protection\n\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW;\n  }\n\n  if (node.tagName === 'INPUT') {\n    var inputElement = node;\n\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK;\n    }\n\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK;\n    }\n\n    var autocomplete = inputElement.getAttribute('autocomplete'); // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK;\n    }\n  } // Check HTML privacy attributes\n\n\n  switch (privAttr) {\n    case PRIVACY_ATTR_VALUE_ALLOW:\n      return NodePrivacyLevel.ALLOW;\n\n    case PRIVACY_ATTR_VALUE_MASK:\n      return NodePrivacyLevel.MASK;\n\n    case PRIVACY_ATTR_VALUE_MASK_USER_INPUT:\n    case PRIVACY_ATTR_VALUE_INPUT_IGNORED: // Deprecated, now aliased\n\n    case PRIVACY_ATTR_VALUE_INPUT_MASKED:\n      // Deprecated, now aliased\n      return NodePrivacyLevel.MASK_USER_INPUT;\n\n    case PRIVACY_ATTR_VALUE_HIDDEN:\n      return NodePrivacyLevel.HIDDEN;\n  } // Check HTML privacy classes\n\n\n  if (node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n    return NodePrivacyLevel.ALLOW;\n  } else if (node.classList.contains(PRIVACY_CLASS_MASK)) {\n    return NodePrivacyLevel.MASK;\n  } else if (node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n    return NodePrivacyLevel.HIDDEN;\n  } else if (node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT) || node.classList.contains(PRIVACY_CLASS_INPUT_MASKED) || // Deprecated, now aliased\n  node.classList.contains(PRIVACY_CLASS_INPUT_IGNORED) // Deprecated, now aliased\n  ) {\n    return NodePrivacyLevel.MASK_USER_INPUT;\n  } else if (shouldIgnoreElement(node)) {\n    // such as for scripts\n    return NodePrivacyLevel.IGNORE;\n  }\n}\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\n\nexport function shouldMaskNode(node, privacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true;\n\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node);\n\n    default:\n      return false;\n  }\n}\n\nfunction isElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\nfunction isTextNode(node) {\n  return node.nodeType === node.TEXT_NODE;\n}\n\nfunction isFormElement(node) {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false;\n  }\n\n  var element = node;\n\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false;\n    }\n  }\n\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName];\n}\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\n\n\nexport var censorText = function (text) {\n  return text.replace(/\\S/g, TEXT_MASKING_CHAR);\n};\nexport function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {\n  var _a; // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n\n\n  var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n  var textContent = textNode.textContent || '';\n\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return;\n  }\n\n  var nodePrivacyLevel = parentNodePrivacyLevel;\n  var isStyle = parentTagName === 'STYLE' ? true : undefined;\n  var isScript = parentTagName === 'SCRIPT';\n\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK;\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK;\n  } else if (shouldMaskNode(textNode, nodePrivacyLevel)) {\n    if (isStyle) {\n      // Style tags are `overruled` (Use `hide` to enforce privacy)\n      textContent = makeStylesheetUrlsAbsolute(textContent, location.href);\n    } else if ( // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n    parentTagName === 'DATALIST' || parentTagName === 'SELECT' || parentTagName === 'OPTGROUP') {\n      if (!textContent.trim()) {\n        return;\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK;\n    } else {\n      textContent = censorText(textContent);\n    }\n  }\n\n  return textContent;\n}","map":{"version":3,"sources":["../../../src/domain/record/privacy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_ALLOW, PRIVACY_ATTR_VALUE_MASK, PRIVACY_ATTR_VALUE_MASK_USER_INPUT, PRIVACY_ATTR_VALUE_HIDDEN, PRIVACY_CLASS_ALLOW, PRIVACY_CLASS_MASK, PRIVACY_CLASS_MASK_USER_INPUT, PRIVACY_CLASS_HIDDEN, FORM_PRIVATE_TAG_NAMES, CENSORED_STRING_MARK, \n// Deprecated (now aliased) below\nPRIVACY_CLASS_INPUT_IGNORED, PRIVACY_CLASS_INPUT_MASKED, PRIVACY_ATTR_VALUE_INPUT_IGNORED, PRIVACY_ATTR_VALUE_INPUT_MASKED, } from '../../constants';\nexport var MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100000;\nimport { makeStylesheetUrlsAbsolute } from './serializationUtils';\nimport { shouldIgnoreElement } from './serialize';\nvar TEXT_MASKING_CHAR = 'x';\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node, defaultPrivacyLevel) {\n    var parentNodePrivacyLevel = node.parentNode\n        ? getNodePrivacyLevel(node.parentNode, defaultPrivacyLevel)\n        : defaultPrivacyLevel;\n    var selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);\n    return reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);\n}\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {\n    switch (parentNodePrivacyLevel) {\n        // These values cannot be overridden\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return parentNodePrivacyLevel;\n    }\n    switch (childPrivacyLevel) {\n        case NodePrivacyLevel.ALLOW:\n        case NodePrivacyLevel.MASK:\n        case NodePrivacyLevel.MASK_USER_INPUT:\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return childPrivacyLevel;\n        default:\n            return parentNodePrivacyLevel;\n    }\n}\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node) {\n    // Only Element types can be have a privacy level set\n    if (!isElement(node)) {\n        return;\n    }\n    var privAttr = node.getAttribute(PRIVACY_ATTR_NAME);\n    // Overrules to enforce end-user protection\n    if (node.tagName === 'BASE') {\n        return NodePrivacyLevel.ALLOW;\n    }\n    if (node.tagName === 'INPUT') {\n        var inputElement = node;\n        if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n            return NodePrivacyLevel.MASK;\n        }\n        if (inputElement.type === 'hidden') {\n            return NodePrivacyLevel.MASK;\n        }\n        var autocomplete = inputElement.getAttribute('autocomplete');\n        // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n        if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n            return NodePrivacyLevel.MASK;\n        }\n    }\n    // Check HTML privacy attributes\n    switch (privAttr) {\n        case PRIVACY_ATTR_VALUE_ALLOW:\n            return NodePrivacyLevel.ALLOW;\n        case PRIVACY_ATTR_VALUE_MASK:\n            return NodePrivacyLevel.MASK;\n        case PRIVACY_ATTR_VALUE_MASK_USER_INPUT:\n        case PRIVACY_ATTR_VALUE_INPUT_IGNORED: // Deprecated, now aliased\n        case PRIVACY_ATTR_VALUE_INPUT_MASKED: // Deprecated, now aliased\n            return NodePrivacyLevel.MASK_USER_INPUT;\n        case PRIVACY_ATTR_VALUE_HIDDEN:\n            return NodePrivacyLevel.HIDDEN;\n    }\n    // Check HTML privacy classes\n    if (node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n        return NodePrivacyLevel.ALLOW;\n    }\n    else if (node.classList.contains(PRIVACY_CLASS_MASK)) {\n        return NodePrivacyLevel.MASK;\n    }\n    else if (node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n        return NodePrivacyLevel.HIDDEN;\n    }\n    else if (node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT) ||\n        node.classList.contains(PRIVACY_CLASS_INPUT_MASKED) || // Deprecated, now aliased\n        node.classList.contains(PRIVACY_CLASS_INPUT_IGNORED) // Deprecated, now aliased\n    ) {\n        return NodePrivacyLevel.MASK_USER_INPUT;\n    }\n    else if (shouldIgnoreElement(node)) {\n        // such as for scripts\n        return NodePrivacyLevel.IGNORE;\n    }\n}\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node, privacyLevel) {\n    switch (privacyLevel) {\n        case NodePrivacyLevel.MASK:\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return true;\n        case NodePrivacyLevel.MASK_USER_INPUT:\n            return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node);\n        default:\n            return false;\n    }\n}\nfunction isElement(node) {\n    return node.nodeType === node.ELEMENT_NODE;\n}\nfunction isTextNode(node) {\n    return node.nodeType === node.TEXT_NODE;\n}\nfunction isFormElement(node) {\n    if (!node || node.nodeType !== node.ELEMENT_NODE) {\n        return false;\n    }\n    var element = node;\n    if (element.tagName === 'INPUT') {\n        switch (element.type) {\n            case 'button':\n            case 'color':\n            case 'reset':\n            case 'submit':\n                return false;\n        }\n    }\n    return !!FORM_PRIVATE_TAG_NAMES[element.tagName];\n}\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport var censorText = function (text) { return text.replace(/\\S/g, TEXT_MASKING_CHAR); };\nexport function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {\n    var _a;\n    // The parent node may not be a html element which has a tagName attribute.\n    // So just let it be undefined which is ok in this use case.\n    var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n    var textContent = textNode.textContent || '';\n    if (ignoreWhiteSpace && !textContent.trim()) {\n        return;\n    }\n    var nodePrivacyLevel = parentNodePrivacyLevel;\n    var isStyle = parentTagName === 'STYLE' ? true : undefined;\n    var isScript = parentTagName === 'SCRIPT';\n    if (isScript) {\n        // For perf reasons, we don't record script (heuristic)\n        textContent = CENSORED_STRING_MARK;\n    }\n    else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // Should never occur, but just in case, we set to CENSORED_MARK.\n        textContent = CENSORED_STRING_MARK;\n    }\n    else if (shouldMaskNode(textNode, nodePrivacyLevel)) {\n        if (isStyle) {\n            // Style tags are `overruled` (Use `hide` to enforce privacy)\n            textContent = makeStylesheetUrlsAbsolute(textContent, location.href);\n        }\n        else if (\n        // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n        parentTagName === 'DATALIST' ||\n            parentTagName === 'SELECT' ||\n            parentTagName === 'OPTGROUP') {\n            if (!textContent.trim()) {\n                return;\n            }\n        }\n        else if (parentTagName === 'OPTION') {\n            // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n            textContent = CENSORED_STRING_MARK;\n        }\n        else {\n            textContent = censorText(textContent);\n        }\n    }\n    return textContent;\n}\n//# sourceMappingURL=privacy.js.map"]},"metadata":{},"sourceType":"module"}