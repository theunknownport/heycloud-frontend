{"ast":null,"code":"import { monitor, noop } from '@datadog/browser-core';\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\n\nvar MUTATION_PROCESS_MAX_DELAY = 100;\nexport function createMutationBatch(processMutationBatch) {\n  var cancelScheduledFlush = noop;\n  var pendingMutations = [];\n\n  function flush() {\n    cancelScheduledFlush();\n    processMutationBatch(pendingMutations);\n    pendingMutations = [];\n  }\n\n  return {\n    addMutations: function (mutations) {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = scheduleMutationFlush(flush);\n      }\n\n      pendingMutations.push.apply(pendingMutations, mutations);\n    },\n    flush: flush,\n    stop: function () {\n      cancelScheduledFlush();\n    }\n  };\n}\n\nfunction scheduleMutationFlush(flush) {\n  var browserWindow = window; // Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n  // browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n  // fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n  // browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes\n  // efficiently.\n\n  if (browserWindow.requestIdleCallback) {\n    var id_1 = browserWindow.requestIdleCallback(monitor(flush), {\n      timeout: MUTATION_PROCESS_MAX_DELAY\n    });\n    return function () {\n      return browserWindow.cancelIdleCallback(id_1);\n    };\n  }\n\n  var id = browserWindow.requestAnimationFrame(monitor(flush));\n  return function () {\n    return browserWindow.cancelAnimationFrame(id);\n  };\n}","map":{"version":3,"sources":["../../../src/domain/record/mutationBatch.ts"],"names":[],"mappings":"AAAA,SAAS,OAAT,EAAkB,IAAlB,QAA8B,uBAA9B;AAGA;;;;;AAKG;;AACH,IAAM,0BAA0B,GAAG,GAAnC;AAEA,OAAM,SAAU,mBAAV,CAA8B,oBAA9B,EAA4F;AAChG,MAAI,oBAAoB,GAAG,IAA3B;AACA,MAAI,gBAAgB,GAAwB,EAA5C;;AAEA,WAAS,KAAT,GAAc;AACZ,IAAA,oBAAoB;AACpB,IAAA,oBAAoB,CAAC,gBAAD,CAApB;AACA,IAAA,gBAAgB,GAAG,EAAnB;AACD;;AAED,SAAO;AACL,IAAA,YAAY,EAAE,UAAC,SAAD,EAA+B;AAC3C,UAAI,gBAAgB,CAAC,MAAjB,KAA4B,CAAhC,EAAmC;AACjC,QAAA,oBAAoB,GAAG,qBAAqB,CAAC,KAAD,CAA5C;AACD;;AACD,MAAA,gBAAgB,CAAC,IAAjB,CAAqB,KAArB,CAAA,gBAAA,EAAyB,SAAzB;AACD,KANI;AAQL,IAAA,KAAK,EAAA,KARA;AAUL,IAAA,IAAI,EAAE,YAAA;AACJ,MAAA,oBAAoB;AACrB;AAZI,GAAP;AAcD;;AAED,SAAS,qBAAT,CAA+B,KAA/B,EAAgD;AAK9C,MAAM,aAAa,GAAI,MAAvB,CAL8C,CAO9C;AACA;AACA;AACA;AACA;;AACA,MAAI,aAAa,CAAC,mBAAlB,EAAuC;AACrC,QAAM,IAAE,GAAG,aAAa,CAAC,mBAAd,CAAkC,OAAO,CAAC,KAAD,CAAzC,EAAkD;AAAE,MAAA,OAAO,EAAE;AAAX,KAAlD,CAAX;AACA,WAAO,YAAA;AAAM,aAAA,aAAa,CAAC,kBAAd,CAAA,IAAA,CAAA;AAAoC,KAAjD;AACD;;AACD,MAAM,EAAE,GAAG,aAAa,CAAC,qBAAd,CAAoC,OAAO,CAAC,KAAD,CAA3C,CAAX;AACA,SAAO,YAAA;AAAM,WAAA,aAAa,CAAC,oBAAd,CAAA,EAAA,CAAA;AAAsC,GAAnD;AACD","sourceRoot":"","sourcesContent":["import { monitor, noop } from '@datadog/browser-core';\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nvar MUTATION_PROCESS_MAX_DELAY = 100;\nexport function createMutationBatch(processMutationBatch) {\n    var cancelScheduledFlush = noop;\n    var pendingMutations = [];\n    function flush() {\n        cancelScheduledFlush();\n        processMutationBatch(pendingMutations);\n        pendingMutations = [];\n    }\n    return {\n        addMutations: function (mutations) {\n            if (pendingMutations.length === 0) {\n                cancelScheduledFlush = scheduleMutationFlush(flush);\n            }\n            pendingMutations.push.apply(pendingMutations, mutations);\n        },\n        flush: flush,\n        stop: function () {\n            cancelScheduledFlush();\n        },\n    };\n}\nfunction scheduleMutationFlush(flush) {\n    var browserWindow = window;\n    // Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n    // browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n    // fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n    // browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes\n    // efficiently.\n    if (browserWindow.requestIdleCallback) {\n        var id_1 = browserWindow.requestIdleCallback(monitor(flush), { timeout: MUTATION_PROCESS_MAX_DELAY });\n        return function () { return browserWindow.cancelIdleCallback(id_1); };\n    }\n    var id = browserWindow.requestAnimationFrame(monitor(flush));\n    return function () { return browserWindow.cancelAnimationFrame(id); };\n}\n//# sourceMappingURL=mutationBatch.js.map"]},"metadata":{},"sourceType":"module"}