{"ast":null,"code":"import { addEventListener, monitor } from '@datadog/browser-core';\nimport { LifeCycleEventType } from '@datadog/browser-rum-core';\nimport { SEND_BEACON_BYTE_LENGTH_LIMIT } from '../../transport/send';\nimport { Segment } from './segment';\nexport var MAX_SEGMENT_DURATION = 30000;\nvar MAX_SEGMENT_SIZE = SEND_BEACON_BYTE_LENGTH_LIMIT; // Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (meta), so our goal is to\n// build segments containing as much records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment size reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(lifeCycle, applicationId, session, parentContexts, send, worker) {\n  return doStartSegmentCollection(lifeCycle, function () {\n    return computeSegmentContext(applicationId, session, parentContexts);\n  }, send, worker);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, send, worker, emitter) {\n  if (emitter === void 0) {\n    emitter = window;\n  }\n\n  var state = {\n    status: 0\n    /* WaitingForInitialRecord */\n    ,\n    nextSegmentCreationReason: 'init'\n  };\n  var unsubscribeViewCreated = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, function () {\n    flushSegment('view_change');\n  }).unsubscribe;\n  var unsubscribeBeforeUnload = lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, function () {\n    flushSegment('before_unload');\n  }).unsubscribe;\n  var unsubscribeVisibilityChange = addEventListener(emitter, \"visibilitychange\"\n  /* VISIBILITY_CHANGE */\n  , function () {\n    if (document.visibilityState === 'hidden') {\n      flushSegment('visibility_hidden');\n    }\n  }, {\n    capture: true\n  }).stop;\n\n  function flushSegment(nextSegmentCreationReason) {\n    if (state.status === 1\n    /* SegmentPending */\n    ) {\n      state.segment.flush(nextSegmentCreationReason || 'sdk_stopped');\n      clearTimeout(state.expirationTimeoutId);\n    }\n\n    if (nextSegmentCreationReason) {\n      state = {\n        status: 0\n        /* WaitingForInitialRecord */\n        ,\n        nextSegmentCreationReason: nextSegmentCreationReason\n      };\n    } else {\n      state = {\n        status: 2\n        /* Stopped */\n\n      };\n    }\n  }\n\n  function createNewSegment(creationReason, initialRecord) {\n    var context = getSegmentContext();\n\n    if (!context) {\n      return;\n    }\n\n    var segment = new Segment(worker, context, creationReason, initialRecord, function (compressedSegmentSize) {\n      if (!segment.isFlushed && compressedSegmentSize > MAX_SEGMENT_SIZE) {\n        flushSegment('max_size');\n      }\n    }, function (data, rawSegmentSize) {\n      send(data, segment.meta, rawSegmentSize, segment.flushReason);\n    });\n    state = {\n      status: 1\n      /* SegmentPending */\n      ,\n      segment: segment,\n      expirationTimeoutId: setTimeout(monitor(function () {\n        flushSegment('max_duration');\n      }), MAX_SEGMENT_DURATION)\n    };\n  }\n\n  return {\n    addRecord: function (record) {\n      switch (state.status) {\n        case 0\n        /* WaitingForInitialRecord */\n        :\n          createNewSegment(state.nextSegmentCreationReason, record);\n          break;\n\n        case 1\n        /* SegmentPending */\n        :\n          state.segment.addRecord(record);\n          break;\n      }\n    },\n    stop: function () {\n      flushSegment();\n      unsubscribeViewCreated();\n      unsubscribeBeforeUnload();\n      unsubscribeVisibilityChange();\n    }\n  };\n}\nexport function computeSegmentContext(applicationId, session, parentContexts) {\n  if (!session.isTracked()) {\n    return undefined;\n  }\n\n  var viewContext = parentContexts.findView();\n\n  if (!(viewContext === null || viewContext === void 0 ? void 0 : viewContext.session.id) || viewContext.session.id !== session.getId()) {\n    return undefined;\n  }\n\n  return {\n    application: {\n      id: applicationId\n    },\n    session: {\n      id: viewContext.session.id\n    },\n    view: {\n      id: viewContext.view.id\n    }\n  };\n}\nexport function setMaxSegmentSize(newSize) {\n  if (newSize === void 0) {\n    newSize = SEND_BEACON_BYTE_LENGTH_LIMIT;\n  }\n\n  MAX_SEGMENT_SIZE = newSize;\n}","map":{"version":3,"sources":["../../../src/domain/segmentCollection/segmentCollection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { addEventListener, monitor } from '@datadog/browser-core';\nimport { LifeCycleEventType } from '@datadog/browser-rum-core';\nimport { SEND_BEACON_BYTE_LENGTH_LIMIT } from '../../transport/send';\nimport { Segment } from './segment';\nexport var MAX_SEGMENT_DURATION = 30000;\nvar MAX_SEGMENT_SIZE = SEND_BEACON_BYTE_LENGTH_LIMIT;\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (meta), so our goal is to\n// build segments containing as much records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment size reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\nexport function startSegmentCollection(lifeCycle, applicationId, session, parentContexts, send, worker) {\n    return doStartSegmentCollection(lifeCycle, function () { return computeSegmentContext(applicationId, session, parentContexts); }, send, worker);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, send, worker, emitter) {\n    if (emitter === void 0) { emitter = window; }\n    var state = {\n        status: 0 /* WaitingForInitialRecord */,\n        nextSegmentCreationReason: 'init',\n    };\n    var unsubscribeViewCreated = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, function () {\n        flushSegment('view_change');\n    }).unsubscribe;\n    var unsubscribeBeforeUnload = lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, function () {\n        flushSegment('before_unload');\n    }).unsubscribe;\n    var unsubscribeVisibilityChange = addEventListener(emitter, \"visibilitychange\" /* VISIBILITY_CHANGE */, function () {\n        if (document.visibilityState === 'hidden') {\n            flushSegment('visibility_hidden');\n        }\n    }, { capture: true }).stop;\n    function flushSegment(nextSegmentCreationReason) {\n        if (state.status === 1 /* SegmentPending */) {\n            state.segment.flush(nextSegmentCreationReason || 'sdk_stopped');\n            clearTimeout(state.expirationTimeoutId);\n        }\n        if (nextSegmentCreationReason) {\n            state = {\n                status: 0 /* WaitingForInitialRecord */,\n                nextSegmentCreationReason: nextSegmentCreationReason,\n            };\n        }\n        else {\n            state = {\n                status: 2 /* Stopped */,\n            };\n        }\n    }\n    function createNewSegment(creationReason, initialRecord) {\n        var context = getSegmentContext();\n        if (!context) {\n            return;\n        }\n        var segment = new Segment(worker, context, creationReason, initialRecord, function (compressedSegmentSize) {\n            if (!segment.isFlushed && compressedSegmentSize > MAX_SEGMENT_SIZE) {\n                flushSegment('max_size');\n            }\n        }, function (data, rawSegmentSize) {\n            send(data, segment.meta, rawSegmentSize, segment.flushReason);\n        });\n        state = {\n            status: 1 /* SegmentPending */,\n            segment: segment,\n            expirationTimeoutId: setTimeout(monitor(function () {\n                flushSegment('max_duration');\n            }), MAX_SEGMENT_DURATION),\n        };\n    }\n    return {\n        addRecord: function (record) {\n            switch (state.status) {\n                case 0 /* WaitingForInitialRecord */:\n                    createNewSegment(state.nextSegmentCreationReason, record);\n                    break;\n                case 1 /* SegmentPending */:\n                    state.segment.addRecord(record);\n                    break;\n            }\n        },\n        stop: function () {\n            flushSegment();\n            unsubscribeViewCreated();\n            unsubscribeBeforeUnload();\n            unsubscribeVisibilityChange();\n        },\n    };\n}\nexport function computeSegmentContext(applicationId, session, parentContexts) {\n    if (!session.isTracked()) {\n        return undefined;\n    }\n    var viewContext = parentContexts.findView();\n    if (!(viewContext === null || viewContext === void 0 ? void 0 : viewContext.session.id) || viewContext.session.id !== session.getId()) {\n        return undefined;\n    }\n    return {\n        application: {\n            id: applicationId,\n        },\n        session: {\n            id: viewContext.session.id,\n        },\n        view: {\n            id: viewContext.view.id,\n        },\n    };\n}\nexport function setMaxSegmentSize(newSize) {\n    if (newSize === void 0) { newSize = SEND_BEACON_BYTE_LENGTH_LIMIT; }\n    MAX_SEGMENT_SIZE = newSize;\n}\n//# sourceMappingURL=segmentCollection.js.map"]},"metadata":{},"sourceType":"module"}